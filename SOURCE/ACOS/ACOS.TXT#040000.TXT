                   1             TR               
                   2             TR    ADR        
                   3    ********************************
                   4    *                              *
                   5    *    GBBS Pro Version 2.30     *
                   6    *                              *
                   7    ********************************
                   8    
                   9    * Copyright 1986-2023 by Kevin Smallwood
                   10   
                   11   * LST OFF
                   12   *N = 0
                   13   *n = 0
                   14   *Y = 1
                   15   *y = 1
                   16   
                   17   *L_SOURCE KBD "List this assembly? (Y/N)"
                   18   
                   19            DSK   ACOS.OBJ   
                   20   
                   21   * DO L_SOURCE
                   22   * LST
                   23   * FIN
                   25   
                   26            PUT   EQUATES    
                  >1             ORG   $800       
                  >2    ********************************
                  >3    *                              *
                  >4    *   ACOS.OBJ Equates File      *
                  >5    *                              *
                  >6    ********************************
                                  3-MAR-23   9:23:01 AM
                  >8    *-------------------------------
                  >9    
          =0040   >10   ctrl     =     $40        
          =0004   >11   eot      =     'D'-ctrl   
          =000C   >12   ff       =     'L'-ctrl   
                  >13   
          =0001   >14   chat     =     'A'-ctrl   
          =0002   >15   bol      =     'B'-ctrl   
          =0003   >16   ctr      =     'C'-ctrl   
          =0004   >17   dc       =     'D'-ctrl   
          =0005   >18   eol      =     'E'-ctrl   
          =0006   >19   ic       =     'F'-ctrl   
          =0007   >20   bel      =     'G'-ctrl   
          =0008   >21   bs       =     'H'-ctrl   
          =0009   >22   tab      =     'I'-ctrl   
          =000A   >23   lf       =     'J'-ctrl   
          =001D   >24   toglpw   =     ']'-ctrl   
          =000C   >25   logout   =     'L'-ctrl   
          =000D   >26   cr       =     'M'-ctrl   
          =000F   >27   bartog   =     'O'-ctrl   
          =0010   >28   prnscr   =     'P'-ctrl   
          =0011   >29   lwd      =     'Q'-ctrl   
          =0011   >30   xon      =     'Q'-ctrl   
          =0012   >31   revtop   =     'R'-ctrl   
          =0013   >32   xoff     =     'S'-ctrl   
          =0014   >33   hak      =     'T'-ctrl   
          =0015   >34   fs       =     'U'-ctrl   
          =0016   >35   execon   =     'V'-ctrl   
          =0017   >36   nwd      =     'W'-ctrl   
          =0018   >37   can      =     'X'-ctrl   
          =001E   >38   clb      =     '^'-ctrl   
          =001F   >39   pass     =     '_'-ctrl   
          =007F   >40   del      =     $7F        
          =007F   >41   clrhi    =     $7F        
          =0080   >42   hibit    =     $80        
          =0000   >43   LABEL    =     0          
          =007F   >44   QUIT     =     $7F        
                  >45   
                  >46   *-------------------------------
                  >47   * addresses
                  >48   *-------------------------------
                  >49   
          =9E00   >50   ENDMOD   =     $9E00      
                  >51   
          =9E00   >52   EDBUF    =     ENDMOD     ;editor buffer
          =1000   >53   EDSIZE   =     $1000      ;$1000   4k
          =ADFF   >54   EBUFEND  =     EDBUF+EDSIZE-1 
                  >55   
          =9E00   >56   LBLTAB   =     ENDMOD     ;compiler labels
          =A600   >57   SYMTAB   =     LBLTAB+$800 ;compiler symbols
                  >58   
          =AE00   >59   FBUF2    =     $AE00      ;file 2 buffer
          =B200   >60   FBUF1    =     $B200      ;file 1 buffer
                  >61   
          =B600   >62   INTBUF   =     $B600      ;interrupt char flags
          =B680   >63   RAMDRV   =     $B680      ;ram drive area
          =B700   >64   TYPBUF   =     $B700      ;type ahead buffer
          =B780   >65   BITBUF   =     $B780      ;msg file bitmap buffer
          =B800   >66   BLKBUF   =     $B800      ;msg file block buffer 1
          =B880   >67   BLKBUF2  =     $B880      ;msg file block buffer 2
          =B900   >68   DIRBUF   =     $B900      ;msg file directory buffer
          =BB00   >69   MSGBUF   =     $BB00      ;msg file data buffer
          =D500   >70   RAMCARD  =     $D500      ;in 1st lc bank
                  >71   
                  >72   *-------------------------------
                  >73   * general offsets
                  >74   *-------------------------------
                  >75   
          =0000   >76   L0       =     0          ;label offsets
          =0100   >77   L1       =     $100       
          =0200   >78   L2       =     $200       
          =0300   >79   L3       =     $300       
          =0400   >80   L4       =     $400       
          =0500   >81   L5       =     $500       
          =0600   >82   L6       =     $600       
          =0700   >83   L7       =     $700       
          =0800   >84   L8       =     $800       
          =0900   >85   L9       =     $900       
                  >86   
                  >87   *-------------------------------
                  >88   * disk file stuff
                  >89   *-------------------------------
                  >90   
          =0004   >91   txt      =     4          ;txst file
          =002B   >92   a2obj    =     $2B        ;standard file
          =002D   >93   a2data   =     $2D        ;data file
                  >94   
                  >95   * file sub types
                  >96   
          =0000   >97   notype   =     0          ;no sub type
                  >98   
          =8001   >99   comfile  =     $8001      ;compiled program/variables
          =8002   >100  usefile  =     $8002      ;USE files
                  >101  
          =8001   >102  stdfile  =     $8001      ;text or data files
          =8002   >103  packfile =     $8002      ;packed message files
                  >104  
                  >105  *-------------------------------
                  >106  * message equates
                  >107  *-------------------------------
                  >108  
          =0001   >109  nostart  =     1          ;Starting Module Not Found
          =0002   >110  seg2big  =     2          ;Module Too Large
          =0003   >111  lblnf    =     3          ;Label Not Found
          =0004   >112  symfull  =     4          ;Symbol Table Full
          =0005   >113  syntax   =     5          ;Syntax Error
          =0006   >114  nosymbol =     6          ;Missing Symbol
          =0007   >115  nolabel  =     7          ;Undefined Label
          =0008   >116  nodata   =     8          ;Missing Data
          =0009   >117  badtype  =     9          ;Type Mismatch
          =000A   >118  num2big  =     10         ;Overflow > 32767
          =000B   >119  divby0   =     11         ;Division By 0
          =000C   >120  str2big  =     12         ;String Too Long
          =000D   >121  gsbfull  =     13         ;Gosub Stack Full
          =000E   >122  nogosub  =     14         ;Return Without Gosub
          =000F   >123  baddev   =     15         ;Bad Device Number
          =0010   >124  badfn    =     16         ;Illegal Filename
          =0011   >125  forfull  =     17         ;For Stack Full
          =0012   >126  nofor    =     18         ;Next Without For
          =0013   >127  nolink   =     19         ;Link Label Not Found
          =0014   >128  nomsg    =     20         ;Message File Not Found
          =0015   >129  endprog  =     21         ;END of Program
          =0016   >130  baddrive =     22         ;Bad Drive Specifier
          =0017   >131  badxtrn  =     23         ;Unable to Load External
          =0018   >132  noquote  =     24         ;Unclosed quote at EOF......
                  >133  
          =0001   >134  sysopon  =     1          ;Sysop is on-line...
          =0002   >135  sysopoff =     2          ;Sysop is off-line...
          =0003   >136  timeup   =     3          ;Sorry, time limit exceeded
          =0004   >137  hangon   =     4          ;...please wait...
          =0005   >138  exitexec =     5          ;...exiting exec mode...
          =0006   >139  nofile   =     6          ;Error: Help file could not be opened
          =0007   >140  badwrite =     7          ;File Write Error
          =0008   >141  onesec   =     8          ;One moment please...
                  >142  
                  >143  *-------------------------------
                  >144  * editor messages
                  >145  *-------------------------------
                  >146  
          =0001   >147  editing  =     1          ;Editing (?=Help):
          =0002   >148  thats4k  =     2          ;That is 4k worth
          =0003   >149  badcmd   =     3          ;Illegal Command
          =0004   >150  abort?   =     4          ;Abort: Are you sure?'
          =0005   >151  aborted  =     5          ;Aborted
          =0006   >152  continue =     6          ;Continue message now...
          =0007   >153  delete?  =     7          ;Delete Line (L,x-y):
          =0008   >154  edit?    =     8          ;Edit Line (L,x):
          =0009   >155  badln    =     9          ;Illegal line number
          =000A   >156  insert?  =     10         ;Insert Line (L,x):
          =000B   >157  list?    =     11         ;List Line (x-y):
          =000C   >158  insert   =     12         ;Insert text: Type 'DONE' when finished
          =000D   >159  new?     =     13         ;New: Erase and start over?'
          =000E   >160  enter    =     14         ;Enter message now...
          =000F   >161  readfn?  =     15         ;Read File (name):'
          =0010   >162  writefn? =     16         ;Write File (name):'
          =0011   >163  edithelp =     17         ;A)bort, C)ontinue, D)elete, E)dit
                  >164                            ;H)elp, I)nsert, L)ist, N)ew, S)ave
                  >165                            ;Z) Space Used
          =0012   >166  legaldot =     18         ;Valid editor commands:
                  >167                            ;("/commmand" and ".command" acceptable)
                  >168                            ; A = Abort  Dx-y = Delete line(s) x-y  N = New
                  >169                            ; H = Help     Ix = Insert at line x    S = Save
                  >170                            ; Z = Space    Ex = Edit line x      Lx-y = List line(s) x-y
          =0013   >171  bytsused =     19         ;Bytes Used.
                  >172  
                  >173  *-------------------------------
                  >174  * compiler messages
                  >175  *-------------------------------
                  >176  
          =0001   >177  compile1 =     1          ;One moment, compiling segment.
          =0002   >178  compile2 =     2          ;..
          =0003   >179  compwipe =     3          
                  >180  
          =000A   >181  ERVAL    =     10         
                  >182  
                  >183  *-------------------------------
                  >184  * Zero Page Locations
                  >185  *-------------------------------
                  >186  
                  >187           DUM   0          
                  >188  
0000: 00 00       >189  TEMP     DW    0          ;0
0002: 00 00       >190  TEMP2    DW    0          ;2
0004: 00 00       >191  PRGPTR   DW    0          ;4   pointer into program
0006: 00          >192  SAVE_X   DB    0          ;6
0007: 00          >193  SAVE_Y   DB    0          ;7
0008: 00 00       >194  VARSTR   DW    0          ;8   top of string space
000A: 00 00       >195  PRN      DW    0          ;$A  print pointer
000C: 00          >196  CMD      DB    0          ;$C
000D: 00 00       >197  STRLOC   DW    0          ;$D  current string location
000F: 00          >198  STRLEN   DB    0          ;$F  current string length
0010: 00          >199  TTLLEN   DB    0          ;$10 concat total length
0011: 00 00       >200  LSTPTR   DW    0          ;$11 token list pointer
0013: 00 00       >201  TEMP3    DW    0          ;$13
0015: 00 00       >202  VECTOR   DW    0          ;$15 output vector
0017: 00 00       >203  WHNPTR   DW    0          ;$17 pointer to when word
0019: 00 00       >204  EDPTR    DW    0          ;$19 editor buffer pointer
001B: 00          >205  LASTIN   DB    0          ;$1B
001C: 00          >206  EXEC     DB    0          ;$1C exec user flag
001D: 00 00       >207  ARGPTR   DW    0          ;$1D
001F: 00          >208  DEVCLR   DB    0          ;$1F reset device flag
                  >209  
0020: 00          >210  WNDLFT   DB    0          ;$20 window left
0021: 00          >211  WNDWDTH  DB    0          ;$21 window width
0022: 00          >212  WNDTOP   DB    0          ;$22 window top
0023: 00          >213  WNDBTM   DB    0          ;$23 window bottom
0024: 00          >214  CH       DB    0          ;$24 cursor column
0025: 00          >215  CV       DB    0          ;$25 cursor row
0026: 00 00       >216           DW    0          ;$26 GBAS, Used by graphics
0028: 00 00       >217           DW    0          ;$28  BAS, Used by video
002A: 00 00       >218           DW    0          ;$2A BAS2, Used by video
002C: 00 00       >219           DW    0          ;$2C
002E: 00          >220           DB    0          ;$2E
002F: 00          >221  LSTTOK   DB    0          ;$2F token storage for list
0030: 00          >222           DB    0          ;$30
0031: 00          >223           DB    0          ;$31
0032: 00          >224  INVFLG   DB    0          ;$32 video inverse flag
0033: 00          >225  PWHIDE   DB    0          ;$33 password hide flag
0034: 00          >226  INTOUT   DB    0          ;$34 output interrupt flag
                  >227  
                  >228           ORG   $4E        
                  >229  
004E: 00 00       >230  MONRND   DW    0          ;$4E
                  >231  
0050: 00 00       >232  X_ARG    DW    0          ;$50 editor X argument
0052: 00 00       >233  Y_ARG    DW    0          ;$52 editor Y argument
0054: 00 00       >234  EDLINE   DW    0          ;$54 editor line number
0056: 00 00       >235  VECTOR2  DW    0          ;$56 input routine vector
0058: 00          >236  MSG_X    DB    0          ;$58
0059: 00          >237  MSG_Y    DB    0          ;$59
005A: 00          >238  OLDCH    DB    0          ;$5A
005B: 00          >239  OLDCV    DB    0          ;$5B
005C: 00          >240  LASTCHR  DB    0          ;$5C
005D: 00          >241  DOCHAT   DB    0          ;$5D do chat next flag
005E: 00          >242  INCHAT   DB    0          ;$5E chatting flag
005F: 00 00       >243           DW    0          ;$5F
0061: 00          >244  LOGOFF   DB    0          ;$61 carrier loss flag
0062: 00          >245  BUF_X    DB    0          ;$62
0063: 00          >246  TYPIN    DB    0          ;$63 type ahead input flag
0064: 00          >247  TYPOUT   DB    0          ;$64 type ahead out flag
0065: 00 00       >248  NIBPTR   DW    0          ;$65 pointer to nibbles
0067: 00 00       >249  BYTPTR   DW    0          ;$67 pointer to bytes
                  >250  
                  >251  ********************************
                  >252  *                              *
                  >253  *     Applesoft Locations      *
                  >254  *                              *
                  >255  ********************************
                  >256  
0069: 00 00       >257  LOMEM    DW    0          ;$69
006B: 00          >258  IMMDEF   DB    0          ;$6B immediate/deferred flag
006C: 00          >259  LSTTXT   DB    0          ;$6C
006D: 00 00       >260  MIDMEM   DW    0          ;$6D
006F: 00 00       >261  CLKBASE  DW    0          ;$6F starting seconds
0071: 00 00       >262  TIMEON   DW    0          ;$71 seconds used
0073: 00 00       >263  HIMEM    DW    0          ;$73
0075: 00          >264  RAMPTR   DB    0          ;$75 ramdisk pointer
0076: 00          >265  SHOW_X   DB    0          ;$76
0077: 00          >266  SHW_CNT  DB    0          ;$77 copy line count
0078: 00          >267  GSBLVL   DB    0          ;$78 gosub stack level
0079: 00          >268  FORLVL   DB    0          ;$79 for stack level
007A: 00 00 00 00 >269           DS    7          ;$7A - $80
                  >270  
0081: 00 00       >271  VNAME    DW    0          ;$81 variable name
0083: 00 00       >272  VPTR     DW    0          ;$83 variable pointer
                  >273  
                  >274           ORG   $C9        
00C9: 00 00       >275  RND      DW    0          
                  >276           DEND             
                  >277  
          =00DE   >278  ERRNO    =     $DE        
                  >279  
          =0200   >280  LNBUF    =     $200       ;input buffer
          =0300   >281  SCRATCH  =     $300       ;ram area
          =03F2   >282  RESETVEC =     $3F2       ;reset vector
          =03F4   >283  SOFTEV   =     $3F4       
          =03F5   >284  USERVEC  =     $3F5       
          =0427   >285  TOPRIGHT =     $427       
                  >286  
          =C010   >287  KBDSTRB  =     $C010      ;clear keyboard strobe
          =C01F   >288  RD80VID  =     $C01F      ;80/40 column switch flag
          =C030   >289  SPKR     =     $C030      ;toggle speaker
          =C056   >290  LORESMD  =     $C056      ;set lores mode
          =C064   >291  PDLS     =     $C064      ;game controls
          =C070   >292  PTRIG    =     $C070      ;game control trigger
          =C082   >293  SETROM   =     $C082      
          =C083   >294  SETRAM   =     $C083      
          =C05B   >295  ANU_ON   =     $C05B      ;annunc 1 ON
          =C05A   >296  ANU_OFF  =     $C05A      ;annunc 1 OFF
          =C063   >297  MLBUS    =     $C063      ;button 2 Multiline Status BUS
                  >298  
                  >299  *-------------------------------
                  >300  * addresses
                  >301  *-------------------------------
                  >302  
          =BF00   >303  MLI      =     $BF00      ;ProDOS MLI entry point
          =BF90   >304  MLIDATE  =     $BF90      ;ProDOS date storage
          =BF92   >305  MLITIME  =     $BF92      ;ProDOS time storage
          =BF58   >306  BITMAP   =     $BF58      ;ProDOS memory protect map
                  >307  
          =FF59   >308  ENTRMON  =     $FF59      ;monitor entry point
          =FFFE   >309  IRQVECT  =     $FFFE      ;IRQ vector
                   27   
                   28            ORG   $800       
                   29   
                   30            PUT   DRVSPEC    
                  >2    *-------------------------------
                  >3    * Default Drivspecs
                  >4    *-------------------------------
                  >5    * to be created by the config program
                  >6    *-------------------------------
                  >7    
0800: 60          >8    START    RTS              
                  >9    
0801: 9F          >10   TOVAL    DB    159        ;value for timeout (159 = 5 mins)
0802: A6 13       >11            DA    BBS_PRG    ;location of startup setment name
0804: 51          >12            DB    #>CODEND   ;location of start of segment space
                  >13   
0805: 48          >14            DB    #>FILTER-START ;location of filter
                  >15   
0806: 00 51       >16            DA    START1     ;init acos w/ modem interupt
0808: 0C 51       >17            DA    START2     ;init acos w/out modem interupt
080A: 82 12       >18            DA    FATAL6     
080C: 06 DE       >19            DA    TOPBUF     
                  >20   
080E: 20          >21   STPCHR   ASC   ' '        ;stop message char
080F: 4E          >22   NXTCHR   ASC   'N'        ;next message char
                  >23   
0810: 04          >24   WIDTH    DB    4          ;index for default
0811: 20 28 40 50 >25            DB    32,40,64,80 
                  >26   
0815: 11 2F 47 42 >27   DEVNAM   STR   '/GBBS.PRO/PROGRAM' A
0827: 10 2F 47 42 >28            STR   '/GBBS.PRO/SYSTEM' B
0838: 10 2F 47 42 >29            STR   '/GBBS.PRO/GFILES' C
0849: 12 2F 47 42 >30            STR   '/GBBS.PRO/DOWNLOAD' D
085C: 10 2F 47 42 >31            STR   '/GBBS.PRO/UPLOAD' E
086D: 13 2F 47 42 >32            STR   '/GBBS.PRO/BULLETINS' F
0881: 0E 2F 47 42 >33            STR   '/GBBS.PRO/MAIL' G
0890: 0E 2F 47 42 >34            STR   '/GBBS.PRO/TEMP' H
089F: 00          >35            DB    0          I
08A0: 00          >36            DB    0          J
08A1: 00          >37            DB    0          K
08A2: 13 2F 47 42 >38            STR   '/GBBS.PRO/STAC/VOL.'  L
08B6: 00 00 00 00 >39            DS    \          
                   31            PUT   DRIVERS    
                  >1    *-------------------------------
                  >2    *    CONSOLE
                  >3    *-------------------------------
                  >4    
0900: 4C 00 00    >5    VIDINIT  JMP   0          
0903: 4C 00 00    >6    VIDCLS   JMP   0          
0906: 4C 00 00    >7    VIDCOUT  JMP   0          
0909: 4C 00 00    >8    VIDSCRL  JMP   0          
090C: 4C 00 00    >9    VIDBAN   JMP   0          
090F: 4C 00 00    >10   VIDLST   JMP   0          
0912: 4C 00 00    >11   VIDRDST  JMP   0          
0915: 4C 00 00    >12   VIDRDKY  JMP   0          
0918: 4C 00 00    >13   VIDRDFN  JMP   0          
091B: 4C 00 00    >14   VIDWND   JMP   0          
091E: 4C 00 00    >15   VIDRD    JMP   0          
0921: 4C 00 00    >16   VIDKEY   JMP   0          
0924: 4C 00 00    >17   VIDPOS   JMP   0          
0927: 4C 00 00    >18   VIDCHAT  JMP   0          
092A: 00 00 00 00 >19            DS    $300-*+VIDINIT 
                  >20   
                  >21   *-------------------------------
                  >22   *    PRINTER
                  >23   *-------------------------------
                  >24   
0C00: 00          >25   PRSLOT   DB    0          
0C01: 4C 00 00    >26   PRINIT   JMP   0          
0C04: 4C 00 00    >27   PRCOUT   JMP   0          
0C07: 4C 00 00    >28   PRCLEAR  JMP   0          
0C0A: 00 00 00 00 >29            DS    \          
                  >30   
                  >31   *-------------------------------
                  >32   *   CLOCK
                  >33   *-------------------------------
                  >34   
0D00: 00          >35   CLKSLOT  DB    0          
0D01: 00          >36   CLKMODE  DB    0          
0D02: 4C 00 00    >37   GETDATE  JMP   0          
0D05: 4C 00 00    >38   GETTIME  JMP   0          
0D08: 4C 00 00    >39   SETDATE  JMP   0          
0D0B: 00 00 00 00 >40            DS    \          
                  >41   
                  >42   *-------------------------------
                  >43   *    MODEM
                  >44   *-------------------------------
                  >45   
0E00: 00          >46   MDMSLOT  DB    0          
0E01: 00          >47   MDMEXTRA DB    0          
0E02: 00          >48   SPCINIT  DB    0          
0E03: 00 00 00    >49   BYTCNT   DS    3          
0E06: 4C 00 00    >50   MDMINIT  JMP   0          
0E09: 4C 00 00    >51   MDMRSET  JMP   0          
0E0C: 4C 00 00    >52   MDMRING  JMP   0          
0E0F: 4C 00 00    >53   MDMANS   JMP   0          
0E12: 4C 00 00    >54   MDMHANG  JMP   0          
0E15: 4C 00 00    >55   MDMIN    JMP   0          
0E18: 4C 00 00    >56   MDMOUT   JMP   0          
0E1B: 4C 00 00    >57   MDMDCD   JMP   0          
0E1E: 4C 00 00    >58   MDMSPD   JMP   0          
0E21: 4C 00 00    >59   MDMINT   JMP   0          
0E24: 4C 00 00    >60   MDMDTR   JMP   0          
0E27: 4C 00 00    >61   MDMCBUF  JMP   0          
0E2A: 4C 00 00    >62   MDMQUIT  JMP   0          
0E2D: 00 00 00 00 >63            DS    $400-*+MDMSLOT 
                   32            PUT   START      
                  >1    ********************************
                  >2    *                              *
                  >3    *       ACOS.OBJ - Start       *
                  >4    *                              *
                  >5    ********************************
                                  3-MAR-23   9:23:03 AM
                  >7    *-------------------------------
                  >8    
                  >9                              ;FATAL SEI
1200: 20 06 0E    >10   FATAL    JSR   MDMINIT    
1203: 20 00 09    >11   FATAL1   JSR   VIDINIT    
1206: 20 01 0C    >12            JSR   PRINIT     
1209: 8D 10 C0    >13            STA   KBDSTRB    
                  >14                             ; SEI
120C: 20 3A 18    >15            JSR   CLRBUF     
120F: AD 56 C0    >16            LDA   LORESMD    ;** it makes things work !! **
                  >17   
1212: AD 83 C0    >18            LDA   SETRAM     ;select ram card
1215: AD 83 C0    >19            LDA   SETRAM     
                  >20   
1218: A2 00       >21            LDX   #0         
121A: 8E 35 DF    >22            STX   REMOTE     
121D: 86 5D       >23            STX   DOCHAT     ;turn off chat
121F: 86 5E       >24            STX   INCHAT     
1221: 86 71       >25            STX   TIMEON     
1223: 86 72       >26            STX   TIMEON+1   
1225: 86 61       >27            STX   LOGOFF     
                  >28   
1227: 8E 42 DF    >29            STX   MSGREF     
122A: 86 6C       >30            STX   LSTTXT     
                  >31   
122C: 86 78       >32            STX   GSBLVL     
122E: 86 79       >33            STX   FORLVL     
                  >34   
1230: 8E 5B C0    >35            STX   ANU_ON     
1233: CA          >36            DEX              
1234: 86 33       >37            STX   PWHIDE     
                  >38   
1236: A9 60       >39            LDA   #$60       
1238: 8D F5 03    >40            STA   USERVEC    ;put RTS in modem-user-routine
                  >41   
123B: A9 04       >42            LDA   #4         
123D: 8D CD 03    >43            STA   REFNUM     ;close all files
1240: 20 D8 30    >44   :FATAL2  JSR   CLOSE      
1243: CE CD 03    >45            DEC   REFNUM     
1246: 10 F8 =1240 >46            BPL   :FATAL2    
                  >47   
1248: A9 01       >48            LDA   #1         
124A: A2 17       >49            LDX   #23        
124C: 9D 58 BF    >50   :FATAL3  STA   BITMAP,X   ;move 1 - 000 pattern
124F: A9 00       >51            LDA   #0         ;and free up memory
1251: CA          >52            DEX              
1252: D0 F8 =124C >53            BNE   :FATAL3    
                  >54   
1254: A9 CF       >55            LDA   #$CF       
1256: 8D 58 BF    >56            STA   BITMAP     ;protect bottom pages
                  >57   
1259: A0 0A       >58            LDY   #10        ;reset device table
125B: B9 07 DD    >59   :FATAL4  LDA   DEVTBL,Y   
125E: 99 06 DF    >60            STA   DEVUSE,Y   
1261: 88          >61            DEY              
1262: 10 F7 =125B >62            BPL   :FATAL4    
                  >63   
1264: A9 C9       >64            LDA   #<RESET    ;set up reset vector
1266: 8D F2 03    >65            STA   RESETVEC   
1269: A9 12       >66            LDA   #>RESET    
126B: 8D F3 03    >67            STA   RESETVEC+1 
                  >68   
126E: 49 A5       >69            EOR   #$A5       ;get power-up byte
1270: 8D F4 03    >70            STA   SOFTEV     
                  >71   
1273: 60          >72            RTS              
                  >73   
1274: A2 0F       >74   FATAL5   LDX   #15        
1276: BD A6 13    >75   :STARTUP LDA   BBS_PRG,X  ;copy default filename
1279: 20 6E 17    >76            JSR   CONV       ;convert to upper case
127C: 9D 72 30    >77            STA   FLNAME,X   
127F: CA          >78            DEX              
1280: 10 F4 =1276 >79            BPL   :STARTUP   
                  >80   
1282: A9 41       >81   FATAL6   LDA   #'A'       
1284: A2 00       >82            LDX   #0         
1286: 20 D6 2F    >83            JSR   LOGSPEC    ;log to A:
                  >84   
1289: 20 50 32    >85            JSR   LD_MOD     ;load module
                  >86   
128C: 20 71 38    >87            JSR   CLEAR      
                  >88   
128F: A9 00       >89   RUNMOD1  LDA   #<CODEND   ;point at program
1291: 85 04       >90            STA   PRGPTR     
1293: A9 51       >91            LDA   #>CODEND   
1295: 85 05       >92            STA   PRGPTR+1   
                  >93   
1297: A2 FF       >94            LDX   #$FF       ;set up stack
1299: 9A          >95            TXS              
                  >96   
129A: 20 E4 16    >97   RUNMOD2  JSR   CHKBYT     ;get token
129D: C9 03       >98            CMP   #end       
129F: 90 07 =12A8 >99            BLT   :RUNMOD3   ;if 'let', don't get byte
                  >100  
12A1: 20 CC 16    >101           JSR   GETBYT     ;gobble
12A4: C9 00       >102           CMP   #0         
12A6: 30 2F =12D7 >103           BMI   SYNTAX     ;special character? Y = error
                  >104  
12A8: 85 0C       >105  :RUNMOD3 STA   CMD        ;save cmd
12AA: 38          >106           SEC              ;mark as command
12AB: 20 58 19    >107           JSR   EX_TOK     ;execute it
12AE: 24 61       >108           BIT   LOGOFF     ;drop user?
12B0: 10 E8 =129A >109           BPL   RUNMOD2    ;nope
                  >110  
12B2: 20 32 24    >111           JSR   DO_CL3     ;close all open files
12B5: AD 2D DF    >112           LDA   NOCDVEC    ;point to no cd routine
12B8: 85 04       >113           STA   PRGPTR     
12BA: AD 2E DF    >114           LDA   NOCDVEC+1  
12BD: 85 05       >115           STA   PRGPTR+1   
                  >116  
12BF: A9 00       >117           LDA   #0         
12C1: 8D 2C DF    >118           STA   NOCDFLG    ;reset cd flag
12C4: 85 61       >119           STA   LOGOFF     
                  >120  
12C6: 4C 9A 12    >121           JMP   RUNMOD2    ;keep going
                  >122  
12C9: EE F4 03    >123  RESET    INC   SOFTEV     ;make sure next reset reboots
12CC: A9 00       >124           LDA   #0         
12CE: 8D 9B 16    >125           STA   SHWTRC     ;clear trace mode
12D1: 8D BD 13    >126           STA   AUTORST    ;disable auto reset
                  >127  
12D4: 4C 07 13    >128           JMP   RESTART1   
                  >129  
                  >130  *-------------------------------
                  >131  * enter error dispatch routines
                  >132  *-------------------------------
                  >133  
12D7: A2 05       >134  SYNTAX   LDX   #syntax    ;syntax error
12D9: D0 06 =12E1 >135           BNE   BADERR     
                  >136  
12DB: A2 07       >137  NOLBLDEF LDX   #nolabel   ;undefined label
12DD: D0 02 =12E1 >138           BNE   BADERR     
                  >139  
12DF: A2 15       >140  DO_END   LDX   #endprog   ;end of program
                  >141  
12E1: 86 DE       >142  BADERR   STX   ERRNO      ;save error #
12E3: 2C 2F DF    >143           BIT   ONERRFLG   
12E6: 10 1C =1304 >144           BPL   :KILLIT    
                  >145  
12E8: A5 04       >146           LDA   PRGPTR     ;save where error occurred
12EA: 8D 32 DF    >147           STA   FROMERR    
12ED: A5 05       >148           LDA   PRGPTR+1   
12EF: 8D 33 DF    >149           STA   FROMERR+1  
                  >150  
12F2: AD 30 DF    >151           LDA   ONERRVEC   ;point to error handler routine
12F5: 85 04       >152           STA   PRGPTR     
12F7: AD 31 DF    >153           LDA   ONERRVEC+1 
12FA: 85 05       >154           STA   PRGPTR+1   
                  >155  
12FC: A9 00       >156           LDA   #0         
12FE: 8D 2F DF    >157           STA   ONERRFLG   ;reset onerr flag
1301: 4C 9A 12    >158           JMP   RUNMOD2    
                  >159  
1304: 20 91 19    >160  :KILLIT  JSR   ERROR      ;show error
                  >161  
1307: AD 83 C0    >162  RESTART1 LDA   SETRAM     ;select ram card
130A: AD 83 C0    >163           LDA   SETRAM     
                  >164  
130D: A9 00       >165           LDA   #0         
130F: 8D 35 DF    >166           STA   REMOTE     ;turn off remote
                  >167  
1312: 20 E7 39    >168           JSR   MDM1_2     ;hang up modem
                  >169  
1315: 20 28 19    >170           JSR   PR         
1318: AA AA AA A0 >171           ASC   "*** RESTART: S,M,Q ?"00 
                  >172  
132D: A9 00       >173           LDA   #0         
132F: 85 00       >174           STA   TEMP       ;start restart timeout
1331: 85 01       >175           STA   TEMP+1     
1333: A9 F6       >176           LDA   #-10       
1335: 85 02       >177           STA   TEMP2      
                  >178  
1337: AD BD 13    >179  :REST2   LDA   AUTORST    ;auto-restart?
133A: F0 12 =134E >180           BEQ   :REST2A    ;nope
                  >181  
133C: E6 00       >182           INC   TEMP       
133E: D0 0E =134E >183           BNE   :REST2A    
1340: E6 01       >184           INC   TEMP+1     ;do low/med counter
1342: D0 0A =134E >185           BNE   :REST2A    
                  >186  
1344: E6 02       >187           INC   TEMP2      
1346: D0 06 =134E >188           BNE   :REST2A    
                  >189  
1348: CE BD 13    >190           DEC   AUTORST    ;countdown auto-restart count
134B: 4C 70 13    >191           JMP   REST3      ;restart system
                  >192  
134E: 20 CC 15    >193  :REST2A  JSR   GET        ;get input
1351: 20 6E 17    >194           JSR   CONV       ;make upper case
                  >195  
1354: C9 53       >196           CMP   #'S'       
1356: F0 18 =1370 >197           BEQ   REST3      ;restart system
                  >198  
1358: C9 4D       >199           CMP   #'M'       
135A: F0 1F =137B >200           BEQ   REST4      ;restart module
                  >201  
135C: C9 51       >202           CMP   #'Q'       
135E: D0 D7 =1337 >203           BNE   :REST2     ;quit
                  >204  
                  >205  * Clean exit via ProDOS 'Quit'
                  >206  
                  >207  * JSR MDMQUIT ;reset the modem before quiting
                  >208  
1360: A9 FF       >209           LDA   #$FF       
1362: 85 32       >210           STA   INVFLG     
                  >211  
1364: 20 00 BF    >212           JSR   MLI        ;close all files
1367: CC          >213           DB    $CC        
1368: 1D 32       >214           DA    P_CLOSE    
                  >215  
136A: 20 00 BF    >216           JSR   MLI        
136D: 65          >217           DB    $65        
136E: B6 13       >218           DA    P_QUIT     
                  >219  
1370: A9 03       >220  REST3    LDA   #3         ;reset auto-restart byte
1372: 8D BD 13    >221           STA   AUTORST    
                  >222  
1375: 20 00 12    >223           JSR   FATAL      ;cold start
1378: 4C 74 12    >224           JMP   FATAL5     
                  >225  
137B: 4C 8F 12    >226  REST4    JMP   RUNMOD1    ;warm start
                  >227  
                  >228  
                  >229  *-------------------------------
                  >230  * handle an incoming irq (and fix it)
                  >231  *-------------------------------
                  >232  
137E: 8D BE 13    >233  IRQ_FIX  STA   IRQ_A      
1381: 68          >234           PLA              
1382: 48          >235           PHA              
1383: 29 10       >236           AND   #%00010000 
1385: D0 19 =13A0 >237           BNE   :BRKD      
1387: AD BE 13    >238           LDA   IRQ_A      
138A: 48          >239           PHA              
138B: 8A          >240           TXA              
138C: 48          >241           PHA              
138D: 98          >242           TYA              
138E: 48          >243           PHA              
138F: A9 09       >244           LDA   #'I'-ctrl  
1391: 8D 27 04    >245           STA   TOPRIGHT   
1394: 20 15 0E    >246           JSR   MDMIN      
1397: 20 15 0E    >247           JSR   MDMIN      
139A: 68          >248           PLA              
139B: A8          >249           TAY              
139C: 68          >250           PLA              
139D: AA          >251           TAX              
139E: 68          >252           PLA              
139F: 40          >253           RTI              
                  >254  
13A0: 8D 82 C0    >255  :BRKD    STA   SETROM     
13A3: 6C FE FF    >256           JMP   (IRQVECT)  
                  >257  
                  >258  * save buffers & variables
                  >259  
13A6: 09 4C 4F 47 >260  BBS_PRG  STR   'LOGON.SEG' ;main segment name
13B0: 20 20 20 20 >261           DS    16-*+BBS_PRG,$20 
                  >262  
13B6: 04          >263  P_QUIT   DB    4          
13B7: 00 00 00 00 >264           DS    6          
                  >265  
13BD: 03          >266  AUTORST  DB    3          ;allow auto-restart 3 times
                  >267  
13BE: 00          >268  IRQ_A    DB    0          
                   33            PUT   ROUTINE    
                  >2    ********************************
                  >3    *                              *
                  >4    *      ACOS.OBJ - Routine      *
                  >5    *                              *
                  >6    ********************************
                                  3-MAR-23   9:23:03 AM
                  >8    *-------------------------------
                  >9    * get a line of input
                  >10   *-------------------------------
                  >11   
13BF: A9 0D       >12   INPLNA   LDA   #cr        ;print cr before getting line
13C1: 20 7B 17    >13            JSR   COUT       
                  >14   
13C4: 24 5E       >15   INPLN    BIT   INCHAT     ;in chat?
13C6: 30 05 =13CD >16            BMI   :INPLN1C   ;don't bug them
                  >17   
13C8: 20 26 17    >18            JSR   CHKTIME    ;is time ok?
13CB: 90 1C =13E9 >19            BCC   :INPLN1A   ;opps, timeout!
                  >20   
13CD: A0 00       >21   :INPLN1C LDY   #0         
13CF: 20 C3 14    >22   :INPLN1  JSR   KEYIN      
13D2: 24 5D       >23            BIT   DOCHAT     ;do chat?
13D4: 10 13 =13E9 >24            BPL   :INPLN1A   ;no
                  >25   
13D6: 24 5E       >26            BIT   INCHAT     ;in chat?
13D8: 10 01 =13DB >27            BPL   :INPLN1B   ;no
                  >28   
13DA: 60          >29            RTS              ;return early
                  >30   
13DB: A9 18       >31   :INPLN1B LDA   #can       ;do we need to del line?
13DD: C0 00       >32            CPY   #0         
13DF: D0 1C =13FD >33            BNE   :INPLN2    ;yep
                  >34   
13E1: C6 5E       >35            DEC   INCHAT     ;set inchat mode
13E3: 20 9F 1C    >36            JSR   DO_CHAT    ;do actual chat
13E6: 4C C4 13    >37            JMP   INPLN      
                  >38   
13E9: 24 61       >39   :INPLN1A BIT   LOGOFF     ;check for no carrier/timeout
13EB: 30 72 =145F >40            BMI   :JINPLN8   
                  >41   
13ED: C9 0D       >42            CMP   #cr        
13EF: F0 70 =1461 >43            BEQ   :JINPLN6   ;return
13F1: C9 08       >44            CMP   #bs        
13F3: F0 08 =13FD >45            BEQ   :INPLN2    ;back space
13F5: C9 18       >46            CMP   #can       
13F7: F0 04 =13FD >47            BEQ   :INPLN2    ;ctrl-x / cancel
13F9: C9 7F       >48            CMP   #del       
13FB: D0 10 =140D >49            BNE   :INPLN3    ;delete
                  >50   
13FD: C0 00       >51   :INPLN2  CPY   #0         
13FF: F0 CE =13CF >52            BEQ   :INPLN1    ;can we back up?, nope
                  >53   
1401: 48          >54            PHA              
1402: 20 B4 14    >55            JSR   PRBACK     ;do backspace
1405: 88          >56            DEY              ;decrease char count
1406: 68          >57            PLA              
1407: C9 18       >58            CMP   #can       
1409: F0 F2 =13FD >59            BEQ   :INPLN2    
140B: D0 C2 =13CF >60            BNE   :INPLN1    ;if its a cancel, keep going
                  >61   
140D: C9 20       >62   :INPLN3  CMP   #' '       
140F: 90 BE =13CF >63            BLT   :INPLN1    ;if its a control char...
                  >64   
1411: CC 4D 4C    >65            CPY   VIDLEN     
1414: D0 55 =146B >66            BNE   :INPLN4    ;check for max length
                  >67   
1416: 99 00 02    >68            STA   LNBUF,Y    ;save last character
                  >69   
1419: AD 99 16    >70            LDA   INPMODE    
141C: 29 10       >71            AND   #%00010000 ;do word-wrap?
141E: F0 43 =1463 >72            BEQ   :INPLN3E   ;nope
                  >73   
1420: 84 00       >74            STY   TEMP       ;save line length
1422: B9 00 02    >75            LDA   LNBUF,Y    ;get last char
1425: C9 20       >76            CMP   #' '       
1427: F0 96 =13BF >77            BEQ   INPLNA     ;all is well, just restart
                  >78   
1429: A2 00       >79            LDX   #0         ;setup for inpln3b
142B: B9 00 02    >80   :INPLN3A LDA   LNBUF,Y    ;check data
142E: C9 20       >81            CMP   #' '       
1430: F0 07 =1439 >82            BEQ   :INPLN3B   ;we found a space
1432: 88          >83            DEY              
1433: D0 F6 =142B >84            BNE   :INPLN3A   ;keep checking
                  >85   
1435: A4 00       >86            LDY   TEMP       ;get back length
1437: D0 2A =1463 >87            BNE   :INPLN3E   ;opps, cant do word-wrap
                  >88   
1439: C8          >89   :INPLN3B INY              
143A: 20 B4 14    >90            JSR   PRBACK     ;back up
143D: B9 00 02    >91            LDA   LNBUF,Y    
1440: 9D 00 02    >92            STA   LNBUF,X    
1443: E8          >93            INX              
1444: C4 00       >94            CPY   TEMP       
1446: D0 F1 =1439 >95            BNE   :INPLN3B   ;loop until all bs's and data copied
                  >96   
1448: 86 00       >97            STX   TEMP       ;save end pointer
144A: A9 0D       >98            LDA   #cr        ;start a new line
144C: 20 7B 17    >99            JSR   COUT       
                  >100  
144F: A0 00       >101           LDY   #0         
1451: B9 00 02    >102  :INPLN3C LDA   LNBUF,Y    
1454: 20 7B 17    >103           JSR   COUT       ;print data
1457: C8          >104           INY              
1458: C4 00       >105           CPY   TEMP       
145A: D0 F5 =1451 >106           BNE   :INPLN3C   
145C: 4C CF 13    >107           JMP   :INPLN1    ;go back for more input
                  >108  
145F: 30 4D =14AE >109  :JINPLN8 BMI   INPLN8     
1461: F0 33 =1496 >110  :JINPLN6 BEQ   :INPLN6    
                  >111  
1463: A9 07       >112  :INPLN3E LDA   #7         
1465: 20 7B 17    >113           JSR   COUT       ;beep the stupid bell
1468: 4C CF 13    >114           JMP   :INPLN1    
                  >115  
146B: 2C 99 16    >116  :INPLN4  BIT   INPMODE    ;do we convert?
146E: 10 03 =1473 >117           BPL   :INPLN4A   ;nope
                  >118  
1470: 20 6E 17    >119           JSR   CONV       ;convert to upper
                  >120  
1473: 2C 99 16    >121  :INPLN4A BIT   INPMODE    ;check the inpmode
1476: 50 0C =1484 >122           BVC   :INPLN5    
1478: C9 2C       >123           CMP   #','       
147A: F0 17 =1493 >124           BEQ   :INPLN5B   ;don't accept a comma
147C: C9 20       >125           CMP   #' '       
147E: D0 04 =1484 >126           BNE   :INPLN5    ;don't accept a space
1480: C0 00       >127           CPY   #0         
1482: F0 0F =1493 >128           BEQ   :INPLN5B   ;for first char of the line
                  >129  
1484: 99 00 02    >130  :INPLN5  STA   LNBUF,Y    ;save char
1487: C8          >131           INY              
1488: 2C 40 3B    >132           BIT   VIDECHO    ;special echo?
148B: 30 03 =1490 >133           BMI   :INPLN5A   ;nope
                  >134  
148D: AD 40 3B    >135           LDA   VIDECHO    
1490: 20 7B 17    >136  :INPLN5A JSR   COUT       ;print it
1493: 4C CF 13    >137  :INPLN5B JMP   :INPLN1    ;loop
                  >138  
1496: A9 0D       >139  :INPLN6  LDA   #cr        
1498: 99 00 02    >140           STA   LNBUF,Y    ;save the return
149B: C0 00       >141           CPY   #0         
149D: D0 0C =14AB >142           BNE   INPLN7     ;was is just a return?, nope
                  >143  
149F: AD 99 16    >144           LDA   INPMODE    ;can we accept a blank line?
14A2: 29 20       >145           AND   #%00100000 
14A4: D0 03 =14A9 >146           BNE   CROUT      ;yep
                  >147  
14A6: 4C C4 13    >148           JMP   INPLN      ;don't take, cr, start over
                  >149  
14A9: A9 0D       >150  CROUT    LDA   #cr        
14AB: 4C 7B 17    >151  INPLN7   JMP   COUT       ;print the return and exit
                  >152  
14AE: A9 0D       >153  INPLN8   LDA   #cr        
14B0: 8D 00 02    >154           STA   LNBUF      ;return blank line
14B3: 60          >155           RTS              
                  >156  
                  >157  *-------------------------------
                  >158  * print a backspace
                  >159  *-------------------------------
                  >160  
14B4: A9 08       >161  PRBACK   LDA   #bs        ;print bs - space - bs
14B6: 20 7B 17    >162           JSR   COUT       
14B9: A9 20       >163           LDA   #' '       
14BB: 20 7B 17    >164           JSR   COUT       
14BE: A9 08       >165           LDA   #bs        
14C0: 4C 7B 17    >166           JMP   COUT       
                  >167  
                  >168  *-------------------------------
                  >169  * get a character
                  >170  *-------------------------------
                  >171  
14C3: 20 43 18    >172  KEYIN    JSR   GETCHR     ;get char from buffer
14C6: D0 6A =1532 >173           BNE   KEYIN5     ;(if present)
                  >174  
14C8: A9 DF       >175  KEYIN2   LDA   #"_"       
14CA: 20 06 09    >176           JSR   VIDCOUT    ;print cursor
14CD: A9 08       >177           LDA   #bs        
14CF: 20 06 09    >178           JSR   VIDCOUT    
                  >179  
14D2: AD 01 08    >180           LDA   TOVAL      
14D5: 8D 35 15    >181           STA   TIMEOUT+2  ;[32=1 minute] - 5 minutes
14D8: A9 00       >182           LDA   #0         
14DA: 8D 34 15    >183           STA   TIMEOUT+1  ;reset medium counter
                  >184  
14DD: A9 96       >185           LDA   #150       ;local time constant
14DF: 2C 35 DF    >186           BIT   REMOTE     ;don't change anything
14E2: 10 02 =14E6 >187           BPL   :KEYIN2B   
                  >188  
14E4: A9 24       >189           LDA   #36        ;get modem time constant
14E6: 8D 33 15    >190  :KEYIN2B STA   TIMEOUT    
14E9: 8D 36 15    >191           STA   TIMEOUT+3  
                  >192  
14EC: CE 33 15    >193  :KEYIN3  DEC   TIMEOUT    
14EF: D0 2A =151B >194           BNE   :KEYIN3A   ;count down
                  >195  
14F1: AD 36 15    >196           LDA   TIMEOUT+3  
14F4: 8D 33 15    >197           STA   TIMEOUT    ;reset low-byte constant
                  >198  
14F7: EE 34 15    >199           INC   TIMEOUT+1  
14FA: D0 1F =151B >200           BNE   :KEYIN3A   ;cycle 256 counter
                  >201  
14FC: AD 35 15    >202           LDA   TIMEOUT+2  ;check time
14FF: 29 1F       >203           AND   #$1F       ;do bell?
1501: D0 05 =1508 >204           BNE   :KEYIN3B   
                  >205  
1503: A9 07       >206           LDA   #7         ;beep bell
1505: 20 CF 17    >207           JSR   COUT2      
                  >208  
1508: 2C 2C DF    >209  :KEYIN3B BIT   NOCDFLG    ;if no carrier vector
150B: 10 0E =151B >210           BPL   :KEYIN3A   ;don't bother
                  >211  
150D: 24 1C       >212           BIT   EXEC       ;check for exec user
150F: 30 0A =151B >213           BMI   :KEYIN3A   ;skip logoff
                  >214  
1511: CE 35 15    >215           DEC   TIMEOUT+2  
1514: D0 05 =151B >216           BNE   :KEYIN3A   ;count down minutes, still time left
                  >217  
1516: A9 FF       >218           LDA   #-1        ;signal logoff
1518: 85 61       >219           STA   LOGOFF     
151A: 60          >220           RTS              
                  >221  
151B: 20 CC 15    >222  :KEYIN3A JSR   GET        ;wait for keypress
151E: D0 06 =1526 >223           BNE   :KEYIN4    ;got one!
                  >224  
1520: 24 5D       >225           BIT   DOCHAT     ;check chat flag
1522: 10 C8 =14EC >226           BPL   :KEYIN3    
                  >227  
1524: A9 00       >228           LDA   #0         ;return early
1526: 48          >229  :KEYIN4  PHA              
1527: A9 A0       >230           LDA   #" "       
1529: 20 06 09    >231           JSR   VIDCOUT    ;remove cursor
152C: A9 08       >232           LDA   #bs        
152E: 20 06 09    >233           JSR   VIDCOUT    
1531: 68          >234           PLA              
1532: 60          >235  KEYIN5   RTS              
                  >236  
1533: 00 00 00 00 >237  TIMEOUT  DS    4          ;timeout counters
                  >238  
                  >239  *-------------------------------
                  >240  * get a character -- non destructable
                  >241  *-------------------------------
                  >242  
1537: 20 43 18    >243  RDKEY    JSR   GETCHR     ;get char from buffer
153A: D0 2F =156B >244           BNE   :RDKEY5    ;(if present)
153C: 20 12 09    >245           JSR   VIDRDST    
                  >246  
153F: 20 15 09    >247  :RDKEY2  JSR   VIDRDKY    
                  >248  
1542: 2C 35 DF    >249           BIT   REMOTE     ;we are local
1545: 10 10 =1557 >250           BPL   :RDKEY3    
                  >251  
1547: 20 26 17    >252           JSR   CHKTIME    
154A: B0 0B =1557 >253           BCS   :RDKEY3    
                  >254  
154C: 20 18 09    >255           JSR   VIDRDFN    
154F: 20 E7 39    >256           JSR   MDM1_2     
1552: A9 FF       >257           LDA   #-1        ;return without carrier
1554: 85 61       >258           STA   LOGOFF     
1556: 60          >259           RTS              
                  >260  
1557: E6 4E       >261  :RDKEY3  INC   MONRND     
1559: D0 08 =1563 >262           BNE   :RDKEY4    ;count down time
155B: E6 4F       >263           INC   MONRND+1   
                  >264  
155D: A5 4F       >265           LDA   MONRND+1   ;count down high?
155F: 29 0F       >266           AND   #%00001111 ;blink?
1561: F0 DC =153F >267           BEQ   :RDKEY2    ;yep
                  >268  
1563: 20 CC 15    >269  :RDKEY4  JSR   GET        ;check for keypress
1566: F0 EF =1557 >270           BEQ   :RDKEY3    ;nope
1568: 20 18 09    >271           JSR   VIDRDFN    ;put back original char
                  >272  
156B: 60          >273  :RDKEY5  RTS              
                  >274  
                  >275  *-------------------------------
                  >276  * do a screen dump
                  >277  *-------------------------------
                  >278  
156C: 8A          >279  SDUMP    TXA              
156D: 48          >280           PHA              ;save x & y
156E: 98          >281           TYA              
156F: 48          >282           PHA              
                  >283  
1570: A2 00       >284           LDX   #0         ;start at line 0
1572: A0 00       >285  :SDUMP2  LDY   #0         ;start at char zero
1574: 20 1E 09    >286  :SDUMP3  JSR   VIDRD      ;read char from screen
1577: 20 04 0C    >287           JSR   PRCOUT     ;print char on printer
157A: C8          >288           INY              
157B: C4 21       >289           CPY   WNDWDTH    
157D: D0 F5 =1574 >290           BNE   :SDUMP3    ;at window width?
                  >291  
157F: A9 0D       >292           LDA   #cr        ;add cr to line
1581: 20 04 0C    >293           JSR   PRCOUT     
1584: E8          >294           INX              
1585: E0 18       >295           CPX   #24        
1587: D0 E9 =1572 >296           BNE   :SDUMP2    ;at last line?, nope
                  >297  
1589: 20 04 0C    >298           JSR   PRCOUT     ;add extra cr
158C: 68          >299           PLA              
158D: A8          >300           TAY              ;restore x & y
158E: 68          >301           PLA              
158F: AA          >302           TAX              
1590: 4C 32 16    >303           JMP   GET2       ;go back to get
                  >304  
1593: A5 33       >305  GET5     LDA   PWHIDE     ;toggle hide password flag
1595: 49 FF       >306           EOR   #-1        
1597: 85 33       >307           STA   PWHIDE     
1599: 4C AC 15    >308           JMP   GET6A      ;show screen top
                  >309  
159C: A5 21       >310  GET6     LDA   WNDWDTH    ;show other half of top
159E: C9 50       >311           CMP   #80        
15A0: F0 11 =15B3 >312           BEQ   JGET2      
                  >313  
15A2: CE 27 19    >314           DEC   TOPSEG     
15A5: D0 05 =15AC >315           BNE   GET6A      
                  >316  
15A7: A9 03       >317           LDA   #3         
15A9: 8D 27 19    >318           STA   TOPSEG     
                  >319  
15AC: A5 22       >320  GET6A    LDA   WNDTOP     ;show user stats
15AE: F0 03 =15B3 >321           BEQ   JGET2      
15B0: 20 DC 18    >322           JSR   TOPSHOW    
15B3: 4C 32 16    >323  JGET2    JMP   GET2       ;go back to get
                  >324  
15B6: A9 FF       >325  GET7     LDA   #$FF       
15B8: 85 5D       >326           STA   DOCHAT     ;signal chat is needed
15BA: 4C 32 16    >327           JMP   GET2       ;finish up
                  >328  
15BD: A9 FF       >329  GET8     LDA   #-1        
15BF: 85 61       >330           STA   LOGOFF     ;signal logoff
15C1: 60          >331           RTS              ;return no carrier status
                  >332  
15C2: A9 80       >333  GET9     LDA   #$80       
15C4: 85 5D       >334           STA   DOCHAT     ;signal exec mode is wanted
15C6: 4C 32 16    >335           JMP   GET2       
                  >336  
15C9: 4C 6C 15    >337  GET4     JMP   SDUMP      ;go to get4 (screen dump)
                  >338  
                  >339  *-------------------------------
                  >340  * scan modem / keyboard for chars
                  >341  *-------------------------------
                  >342  
15CC: E6 C9       >343  GET      INC   RND        
15CE: D0 02 =15D2 >344           BNE   :GET0      ;setup random seed
15D0: E6 CA       >345           INC   RND+1      
                  >346  
15D2: 20 21 09    >347  :GET0    JSR   VIDKEY     ;check local keyboard
15D5: 10 5B =1632 >348           BPL   GET2       ;nope
                  >349  
15D7: 29 7F       >350           AND   #clrhi     
15D9: 85 1B       >351           STA   LASTIN     ;last char from local
15DB: 8D 10 C0    >352           STA   KBDSTRB    ;get char
15DE: C9 16       >353           CMP   #execon    
15E0: F0 E0 =15C2 >354           BEQ   GET9       ;exec mode?
15E2: C9 0C       >355           CMP   #logout    
15E4: F0 D7 =15BD >356           BEQ   GET8       ;quick logoff?
15E6: C9 01       >357           CMP   #chat      
15E8: F0 CC =15B6 >358           BEQ   GET7       ;chat?
15EA: C9 12       >359           CMP   #revtop    
15EC: F0 AE =159C >360           BEQ   GET6       
15EE: C9 1D       >361           CMP   #toglpw    
15F0: F0 A1 =1593 >362           BEQ   GET5       
15F2: C9 10       >363           CMP   #prnscr    
15F4: F0 D3 =15C9 >364           BEQ   GET4       ;print screen?
15F6: C9 0F       >365           CMP   #bartog    
15F8: D0 4D =1647 >366           BNE   GET3       ;toggle bottom bar?
                  >367  
15FA: 2C 9A 16    >368           BIT   SHWTXT     ;go into program trace mode?
15FD: 30 62 =1661 >369           BMI   GET8A      ;yep
                  >370  
15FF: 2C 9B 16    >371           BIT   SHWTRC     ;exit program trace mode?
1602: 10 03 =1607 >372           BPL   :NO8B      
1604: 4C 7E 16    >373           JMP   GET8B      ;yep
                  >374  
1607: CE 9A 16    >375  :NO8B    DEC   SHWTXT     ;show user input
                  >376  
160A: 98          >377           TYA              
160B: 48          >378           PHA              
160C: A4 25       >379           LDY   CV         
160E: C0 16       >380           CPY   #22        
1610: 90 0A =161C >381           BLT   :GET1A     ;do we need to scroll?, nope
1612: 88          >382           DEY              ;move cursor up 2 lines
1613: 88          >383           DEY              
1614: 84 25       >384           STY   CV         ;save new cursor position
1616: 20 09 09    >385           JSR   VIDSCRL    ;scroll data
1619: 20 09 09    >386           JSR   VIDSCRL    
                  >387  
161C: A9 17       >388  :GET1A   LDA   #23        
161E: 20 9C 16    >389           JSR   SVCHCV     ;save current horiz / very position
                  >390  
1621: 20 28 19    >391           JSR   PR         ;print message
1624: 49 4E 50 3A >392           ASC   'INP:'00   
                  >393  
1629: 20 AD 16    >394           JSR   LDCHCV     ;restore position
162C: C6 23       >395           DEC   WNDBTM     ;shorten screen
162E: C6 23       >396           DEC   WNDBTM     
1630: 68          >397           PLA              
1631: A8          >398           TAY              
                  >399  
1632: A9 00       >400  GET2     LDA   #0         ;no data
1634: 2C 35 DF    >401           BIT   REMOTE     ;check modem?
1637: 10 25 =165E >402           BPL   GET3B      ;nope
                  >403  
1639: 20 0D 17    >404           JSR   CHKDCD     ;is there carrier?
163C: 90 20 =165E >405           BCC   GET3B      ;nope!
                  >406  
163E: 20 15 0E    >407           JSR   MDMIN      ;check modem
1641: 90 1B =165E >408           BCC   GET3B      ;no data
                  >409  
1643: 66 1B       >410           ROR   LASTIN     ;put carry [set] into high bit
1645: 29 7F       >411           AND   #clrhi     ;strip high bit
                  >412  
1647: 2C 9A 16    >413  GET3     BIT   SHWTXT     ;show input?
164A: 10 12 =165E >414           BPL   GET3B      ;nope
                  >415  
164C: 48          >416           PHA              
164D: 09 80       >417           ORA   #hibit     
164F: C9 A0       >418           CMP   #" "       
1651: B0 07 =165A >419           BGE   :GET3A     ;is it a control?, nope
                  >420  
1653: 48          >421           PHA              
1654: A9 DE       >422           LDA   #"^"       ;show control lead-in
1656: 20 0C 09    >423           JSR   VIDBAN     
1659: 68          >424           PLA              
165A: 20 0C 09    >425  :GET3A   JSR   VIDBAN     
165D: 68          >426           PLA              
                  >427  
165E: C9 00       >428  GET3B    CMP   #0         ;set status
1660: 60          >429           RTS              
                  >430  
1661: EE 9A 16    >431  GET8A    INC   SHWTXT     ;select program trace
1664: CE 9B 16    >432           DEC   SHWTRC     
                  >433  
1667: 98          >434           TYA              
1668: 48          >435           PHA              ;save Y
1669: A9 17       >436           LDA   #23        
166B: 20 9C 16    >437           JSR   SVCHCV     ;save current horiz / vert
                  >438  
166E: 20 28 19    >439           JSR   PR         ;print message
1671: 50 52 47 3A >440           ASC   'PRG:'00   
                  >441  
1676: 20 AD 16    >442           JSR   LDCHCV     ;restore position
1679: 68          >443           PLA              
167A: A8          >444           TAY              ;restore Y
167B: 4C 32 16    >445           JMP   GET2       
                  >446  
167E: 20 9C 16    >447  GET8B    JSR   SVCHCV     
1681: EE 9B 16    >448           INC   SHWTRC     ;select nothing
1684: E6 23       >449           INC   WNDBTM     ;select bottom 2 lines
1686: E6 23       >450           INC   WNDBTM     
1688: 98          >451           TYA              
1689: 48          >452           PHA              
168A: 8A          >453           TXA              
168B: 48          >454           PHA              
168C: 20 0F 09    >455           JSR   VIDLST     ;clear line 24
168F: 20 AD 16    >456           JSR   LDCHCV     
1692: 68          >457           PLA              
1693: AA          >458           TAX              
1694: 68          >459           PLA              
1695: A8          >460           TAY              
1696: 4C 32 16    >461           JMP   GET2       
                  >462  
1699: 00          >463  INPMODE  DB    0          
169A: 00          >464  SHWTXT   DB    0          ;show users input
169B: 00          >465  SHWTRC   DB    0          ;show program trace
                  >466  
                  >467  *-------------------------------
                  >468  * save current ch / cv
                  >469  *-------------------------------
                  >470  
169C: 48          >471  SVCHCV   PHA              
169D: A5 24       >472           LDA   CH         
169F: 85 5A       >473           STA   OLDCH      ;save old values
16A1: A5 25       >474           LDA   CV         
16A3: 85 5B       >475           STA   OLDCV      
                  >476  
16A5: A9 00       >477           LDA   #0         
16A7: 85 24       >478           STA   CH         ;position to 0,[inparg]
16A9: 68          >479           PLA              
16AA: 85 25       >480           STA   CV         
16AC: 60          >481           RTS              
                  >482  
                  >483  *-------------------------------
                  >484  * restore old ch / cv
                  >485  *-------------------------------
                  >486  
16AD: 8A          >487  LDCHCV   TXA              
16AE: 48          >488           PHA              ;save both x & y
16AF: 98          >489           TYA              
16B0: 48          >490           PHA              
16B1: A6 5A       >491           LDX   OLDCH      ;position
16B3: A4 5B       >492           LDY   OLDCV      
16B5: 20 24 09    >493           JSR   VIDPOS     
16B8: 68          >494           PLA              
16B9: A8          >495           TAY              
16BA: 68          >496           PLA              
16BB: AA          >497           TAX              
16BC: 60          >498           RTS              
                  >499  
                  >500  *-------------------------------
                  >501  * get a program byte
                  >502  *-------------------------------
                  >503  
16BD: 84 07       >504  GETRAW   STY   SAVE_Y     
16BF: A0 00       >505           LDY   #0         
16C1: B1 04       >506           LDA   (PRGPTR),Y ;get byte
16C3: E6 04       >507           INC   PRGPTR     
16C5: D0 02 =16C9 >508           BNE   :GETRAW2   ;inc pointers
16C7: E6 05       >509           INC   PRGPTR+1   
                  >510  
16C9: A4 07       >511  :GETRAW2 LDY   SAVE_Y     
16CB: 60          >512           RTS              
                  >513  
                  >514  *-------------------------------
                  >515  * get a byte, test for text
                  >516  *-------------------------------
                  >517  
16CC: 20 BD 16    >518  GETBYT   JSR   GETRAW     ;get raw data
16CF: C9 A2       >519           CMP   #"""       
16D1: D0 06 =16D9 >520           BNE   :GETBYT3   ;is it text?, nope
                  >521  
16D3: 48          >522           PHA              
16D4: 45 6C       >523           EOR   LSTTXT     ;toggle text mode
16D6: 85 6C       >524           STA   LSTTXT     
16D8: 68          >525           PLA              
                  >526  
16D9: 2C 9B 16    >527  :GETBYT3 BIT   SHWTRC     ;show trace?
16DC: 10 03 =16E1 >528           BPL   :GETBYT4   
                  >529  
16DE: 20 5B 1B    >530           JSR   LIST       ;show trace
                  >531  
16E1: C9 00       >532  :GETBYT4 CMP   #0         ;set flags
16E3: 60          >533           RTS              
                  >534  
                  >535  *-------------------------------
                  >536  * check current program byte
                  >537  * get program byte but
                  >538  * dont inc pointers
                  >539  *-------------------------------
                  >540  
16E4: 84 07       >541  CHKBYT   STY   SAVE_Y     
16E6: A0 00       >542           LDY   #0         
16E8: B1 04       >543           LDA   (PRGPTR),Y 
16EA: A4 07       >544           LDY   SAVE_Y     
16EC: C9 00       >545           CMP   #0         ;set flags
16EE: 60          >546  GOBBLE2  RTS              
                  >547  
                  >548  *-------------------------------
                  >549  * gobble an equal's
                  >550  *-------------------------------
                  >551  
16EF: A2 60       >552  GOBEQU   LDX   #equal     
16F1: D0 02 =16F5 >553           BNE   GOBBLE     
                  >554  
                  >555  *-------------------------------
                  >556  * gobble a comma
                  >557  *-------------------------------
                  >558  
16F3: A2 AC       >559  GOBCOM   LDX   #","       
16F5: 8E 05 17    >560  GOBBLE   STX   GOBBYT     ;save byte
16F8: 20 CC 16    >561           JSR   GETBYT     ;get data
16FB: CD 05 17    >562           CMP   GOBBYT     
16FE: F0 EE =16EE >563           BEQ   GOBBLE2    ;all is well
                  >564  
1700: A2 05       >565           LDX   #syntax    
1702: 4C E1 12    >566           JMP   BADERR     ;syntax error
                  >567  
1705: 00          >568  GOBBYT   DB    0          
                  >569  
                  >570  *-------------------------------
                  >571  * increment temp
                  >572  *-------------------------------
                  >573  
1706: E6 00       >574  INCTMP   INC   TEMP       
1708: D0 02 =170C >575           BNE   :INCTMP    ;increment temp by 1
170A: E6 01       >576           INC   TEMP+1     
170C: 60          >577  :INCTMP  RTS              
                  >578  
                  >579  *-------------------------------
                  >580  * check carrier
                  >581  *-------------------------------
                  >582  
170D: 38          >583  CHKDCD   SEC              
170E: 2C 2C DF    >584           BIT   NOCDFLG    ;bother to check?
1711: 10 12 =1725 >585           BPL   :CHKDCD2   ;nope
                  >586  
1713: 2C 35 DF    >587           BIT   REMOTE     ;are we remote?
1716: 10 0D =1725 >588           BPL   :CHKDCD2   
                  >589  
1718: 20 1B 0E    >590           JSR   MDMDCD     ;is there carrier?
171B: B0 08 =1725 >591           BCS   :CHKDCD2   ;yep
                  >592  
171D: 20 E7 39    >593           JSR   MDM1_2     ;hang up user
1720: A9 FF       >594           LDA   #-1        ;signal logoff needed
1722: 85 61       >595           STA   LOGOFF     
1724: 18          >596           CLC              ;no carrier!
1725: 60          >597  :CHKDCD2 RTS              
                  >598  
                  >599  *-------------------------------
                  >600  * check for timeout (total time online)
                  >601  *-------------------------------
                  >602  
1726: 2C 2C DF    >603  CHKTIME  BIT   NOCDFLG    ;bother to check?
1729: 10 24 =174F >604           BPL   :CHKTM5    ;nope
                  >605  
172B: 24 61       >606           BIT   LOGOFF     ;in logoff mode already?
172D: 30 1E =174D >607           BMI   :CHKTM4    ;yep
                  >608  
172F: A5 71       >609           LDA   TIMEON     ;is there a limit?
1731: 05 72       >610           ORA   TIMEON+1   
1733: F0 1A =174F >611           BEQ   :CHKTM5    ;nope
                  >612  
1735: 20 E3 43    >613           JSR   SECON      ;get time on
                  >614  
1738: C5 72       >615           CMP   TIMEON+1   ;check low byte
173A: F0 04 =1740 >616           BEQ   :CHKTM2    
173C: B0 06 =1744 >617           BGE   :CHKTM3    
173E: 90 0F =174F >618           BLT   :CHKTM5    
                  >619  
1740: E4 71       >620  :CHKTM2  CPX   TIMEON     
1742: 90 0B =174F >621           BLT   :CHKTM5    ;check low, all is well
                  >622  
1744: A2 03       >623  :CHKTM3  LDX   #timeup    
1746: 20 CA 19    >624           JSR   PRMSG      
1749: A9 FF       >625           LDA   #-1        
174B: 85 61       >626           STA   LOGOFF     
174D: 18          >627  :CHKTM4  CLC              ;no carrier / timeout
174E: 60          >628           RTS              
                  >629  
174F: 38          >630  :CHKTM5  SEC              ;all is well
1750: 60          >631           RTS              
                  >632  
                  >633  *-------------------------------
                  >634  * is byte a letter? clc=yep, sec=nope
                  >635  *-------------------------------
                  >636  
1751: 48          >637  TST_ALF  PHA              
1752: 20 6E 17    >638           JSR   CONV       ;change to uppercase
1755: C9 41       >639           CMP   #'A'       
1757: 90 04 =175D >640           BLT   :TST_AL2   
                  >641  
1759: C9 5B       >642           CMP   #'Z'+1     
175B: 90 01 =175E >643           BLT   :TST_AL3   
                  >644  
175D: 38          >645  :TST_AL2 SEC              
175E: 68          >646  :TST_AL3 PLA              
175F: 60          >647           RTS              
                  >648  
                  >649  *-------------------------------
                  >650  * is byte a number? clc=yep, sec=nope
                  >651  *-------------------------------
                  >652  
1760: 48          >653  TST_NUM  PHA              
1761: 29 7F       >654           AND   #clrhi     ;strip high bit
1763: C9 30       >655           CMP   #'0'       
1765: 90 04 =176B >656           BLT   :TST_NM2   
                  >657  
1767: C9 3A       >658           CMP   #'9'+1     
1769: 90 01 =176C >659           BLT   :TST_NM3   
                  >660  
176B: 38          >661  :TST_NM2 SEC              
176C: 68          >662  :TST_NM3 PLA              
176D: 60          >663           RTS              
                  >664  
                  >665  *-------------------------------
                  >666  * convert lower to upper and clear high bit
                  >667  *-------------------------------
                  >668  
176E: 29 7F       >669  CONV     AND   #clrhi     ;strip high bit
1770: C9 61       >670           CMP   #'a'       
1772: 90 06 =177A >671           BLT   CONV2      
                  >672  
1774: C9 7B       >673           CMP   #'z'+1     
1776: B0 02 =177A >674           BGE   CONV2      
                  >675  
1778: E9 1F       >676           SBC   #$1F       ;since carry is clear, -$20
177A: 60          >677  CONV2    RTS              
                  >678  
                  >679  *-------------------------------
                  >680  * output byte in A
                  >681  *-------------------------------
                  >682  
177B: 24 34       >683  COUT     BIT   INTOUT     ;output interrupt?
177D: 30 FB =177A >684           BMI   CONV2      ;skip
177F: 85 06       >685           STA   SAVE_X     
                  >686  
1781: 20 CC 15    >687           JSR   GET        ;check for a char
1784: F0 47 =17CD >688           BEQ   COUT1B     
                  >689  
1786: C9 13       >690           CMP   #xoff      
1788: D0 13 =179D >691           BNE   COUT0      ;check for ctrl-s
                  >692  
178A: 20 C8 14    >693           JSR   KEYIN2     ;get a char
178D: 4C CD 17    >694           JMP   COUT1B     
                  >695  
1790: 20 C8 14    >696  COUT0A   JSR   KEYIN2     ;check for serial # show access
1793: C9 1F       >697           CMP   #pass      
1795: D0 03 =179A >698           BNE   COUT0C     
                  >699  
1797: 20 51 44    >700           JSR   CHK4SN     
                  >701  
179A: 4C CD 17    >702  COUT0C   JMP   COUT1B     ;dont check for int
                  >703  
179D: 2C 00 B6    >704  COUT0    BIT   INTBUF     ;see if int's enabled
17A0: 10 28 =17CA >705           BPL   COUT1A     ;nope
                  >706  
17A2: 48          >707           PHA              
17A3: 20 6E 17    >708           JSR   CONV       ;convert to upper
17A6: 8D AB 17    >709           STA   COUT1+1    ;point to parm [0-127]
17A9: 68          >710           PLA              
17AA: 2C 00 B6    >711  COUT1    BIT   INTBUF     ;*** self-modified
17AD: 10 1B =17CA >712           BPL   COUT1A     
                  >713  
17AF: A9 00       >714           LDA   #0         
17B1: 8D 00 B6    >715           STA   INTBUF     ;no more int's
17B4: C6 34       >716           DEC   INTOUT     ;turn on output interupt
                  >717  
17B6: A9 0D       >718           LDA   #cr        ;was last char a cr?
17B8: C5 5C       >719           CMP   LASTCHR    
17BA: F0 03 =17BF >720           BEQ   COUT1C     ;nope
                  >721  
17BC: 20 CF 17    >722           JSR   COUT2      ;print cr
                  >723  
17BF: AD AB 17    >724  COUT1C   LDA   COUT1+1    
17C2: 8D 19 18    >725           STA   INTCHR     ;get converted byte
17C5: 2C 7F B6    >726           BIT   INTBUF+127 ;special flag for (ctrl-x,ctrl-n)
17C8: 30 4E =1818 >727           BMI   COUT3      
                  >728  
17CA: 20 1A 18    >729  COUT1A   JSR   PUTCHR     ;save char in buffer
                  >730  
17CD: A5 06       >731  COUT1B   LDA   SAVE_X     
                  >732  
17CF: C9 00       >733  COUT2    CMP   #0         
17D1: F0 45 =1818 >734           BEQ   COUT3      ;any data?, nope
17D3: 85 5C       >735           STA   LASTCHR    
17D5: 2C 35 DF    >736           BIT   REMOTE     ;remote call?
17D8: 10 20 =17FA >737           BPL   :COUT2M    ;nope
                  >738  
17DA: 20 18 0E    >739           JSR   MDMOUT     
17DD: C9 0D       >740           CMP   #cr        
17DF: D0 19 =17FA >741           BNE   :COUT2M    
                  >742  
17E1: A9 0A       >743           LDA   #lf        
17E3: 20 18 0E    >744           JSR   MDMOUT     
17E6: AD 34 DF    >745           LDA   NULLS      ;add nulls?
17E9: F0 0D =17F8 >746           BEQ   :COUT2N    ;nope
17EB: 86 06       >747           STX   SAVE_X     ;save x
17ED: AA          >748           TAX              
17EE: A9 00       >749           LDA   #0         
17F0: 20 18 0E    >750  ]LOOP    JSR   MDMOUT     ;send a null
17F3: CA          >751           DEX              
17F4: D0 FA =17F0 >752           BNE   ]LOOP      
17F6: A6 06       >753           LDX   SAVE_X     ;restore x
                  >754  
17F8: A9 0D       >755  :COUT2N  LDA   #cr        
17FA: C9 07       >756  :COUT2M  CMP   #bel       
17FC: F0 13 =1811 >757           BEQ   :DOIT      
                  >758  
17FE: C9 0C       >759           CMP   #ff        
1800: F0 03 =1805 >760           BEQ   :DO_CLS    
1802: 4C 06 09    >761           JMP   VIDCOUT    
                  >762  
1805: 86 06       >763  :DO_CLS  STX   SAVE_X     
1807: 84 07       >764           STY   SAVE_Y     
1809: 20 03 09    >765           JSR   VIDCLS     
180C: A6 06       >766           LDX   SAVE_X     
180E: A4 07       >767           LDY   SAVE_Y     
1810: 60          >768           RTS              
                  >769  
1811: 24 1B       >770  :DOIT    BIT   LASTIN     
1813: 30 03 =1818 >771           BMI   COUT3      
1815: 4C 03 1C    >772           JMP   DO_BELL    
                  >773  
1818: 60          >774  COUT3    RTS              
                  >775  
1819: 00          >776  INTCHR   DB    0          
                  >777  
                  >778  *-------------------------------
                  >779  * save character in input buffer
                  >780  *-------------------------------
                  >781  
181A: C9 1E       >782  PUTCHR   CMP   #clb       
181C: F0 1C =183A >783           BEQ   CLRBUF     ;clear the buffer?, yep
                  >784  
181E: 86 62       >785           STX   BUF_X      ;save X
1820: A6 63       >786           LDX   TYPIN      ;any room?
1822: 9D 00 B7    >787           STA   TYPBUF,X   ;save data
1825: E8          >788           INX              
1826: 10 02 =182A >789           BPL   :PUTCHR1   ;all is well
                  >790  
1828: A2 00       >791           LDX   #0         ;reset pointer
182A: E4 64       >792  :PUTCHR1 CPX   TYPOUT     
182C: F0 05 =1833 >793           BEQ   :PUTCHR2   ;overflow?, yep
                  >794  
182E: 86 63       >795           STX   TYPIN      ;save pointer
1830: A6 62       >796           LDX   BUF_X      ;restore X
1832: 60          >797           RTS              
                  >798  
1833: A6 62       >799  :PUTCHR2 LDX   BUF_X      ;restore X
1835: 48          >800           PHA              
1836: A9 07       >801           LDA   #7         
1838: 68          >802           PLA              
1839: 60          >803           RTS              
                  >804  
                  >805  *-------------------------------
                  >806  * clear the input buffer
                  >807  *-------------------------------
                  >808  
183A: 48          >809  CLRBUF   PHA              
183B: A9 00       >810           LDA   #0         
183D: 85 63       >811           STA   TYPIN      ;zero pointers
183F: 85 64       >812           STA   TYPOUT     
1841: 68          >813           PLA              
1842: 60          >814           RTS              
                  >815  
                  >816  *-------------------------------
                  >817  * get a character from the input buffer
                  >818  *-------------------------------
                  >819  
1843: A9 00       >820  GETCHR   LDA   #0         ;default to no input
1845: 86 62       >821           STX   BUF_X      
1847: A6 64       >822           LDX   TYPOUT     ;get pointer
1849: E4 63       >823           CPX   TYPIN      
184B: F0 0A =1857 >824           BEQ   :GETCHR2   ;any data?, nope
                  >825  
184D: BD 00 B7    >826           LDA   TYPBUF,X   ;get character
1850: E8          >827           INX              
1851: 10 02 =1855 >828           BPL   :GETCHR1   ;inc pointer, still in range?
                  >829  
1853: A2 00       >830           LDX   #0         ;reset pointer
1855: 86 64       >831  :GETCHR1 STX   TYPOUT     ;update
1857: A6 62       >832  :GETCHR2 LDX   BUF_X      ;restore X
1859: C9 00       >833           CMP   #0         
185B: 60          >834           RTS              
                  >835  
                  >836  *-------------------------------
                  >837  * print user stats at top of screen
                  >838  *-------------------------------
                  >839  
185C: 86 06       >840  TOPPRINT STX   SAVE_X     
185E: 48          >841           PHA              
185F: AE DB 18    >842           LDX   TOPSEGNO   
1862: C9 0D       >843           CMP   #'M'-ctrl  
1864: F0 04 =186A >844           BEQ   :TOPPR2    
1866: C9 AC       >845           CMP   #","       
1868: D0 2D =1897 >846           BNE   PRTOPL3    
186A: CA          >847  :TOPPR2  DEX              
186B: E8          >848  :TOPPR3  INX              
186C: BD 06 DE    >849           LDA   TOPBUF,X   
186F: F0 1F =1890 >850           BEQ   PRTOPL2    
1871: C9 2E       >851           CMP   #'.'       
1873: F0 04 =1879 >852           BEQ   :TOPPR4    
1875: C9 2A       >853           CMP   #'*'       
1877: D0 07 =1880 >854           BNE   :TOPPR5    
                  >855  
1879: A9 20       >856  :TOPPR4  LDA   #' '       
187B: 9D 06 DE    >857           STA   TOPBUF,X   
187E: D0 EB =186B >858           BNE   :TOPPR3    
                  >859  
1880: 68          >860  :TOPPR5  PLA              
                  >861  
1881: 48          >862  PRTOPLN  PHA              
1882: E8          >863  :PRTOPL1 INX              
1883: BD 06 DE    >864           LDA   TOPBUF,X   
1886: F0 08 =1890 >865           BEQ   PRTOPL2    
1888: C9 2E       >866           CMP   #'.'       
188A: F0 04 =1890 >867           BEQ   PRTOPL2    
188C: C9 2A       >868           CMP   #'*'       
188E: D0 F2 =1882 >869           BNE   :PRTOPL1   
                  >870  
1890: 8E DB 18    >871  PRTOPL2  STX   TOPSEGNO   
1893: 68          >872           PLA              
1894: A6 06       >873           LDX   SAVE_X     
1896: 60          >874           RTS              
                  >875  
1897: 68          >876  PRTOPL3  PLA              
1898: 29 7F       >877           AND   #clrhi     
189A: 48          >878           PHA              
189B: BD 06 DE    >879           LDA   TOPBUF,X   
189E: F0 16 =18B6 >880           BEQ   PRTOPL5    
18A0: C9 2E       >881           CMP   #'.'       
18A2: F0 08 =18AC >882           BEQ   :PRTOPL4   
18A4: C9 2A       >883           CMP   #'*'       
18A6: D0 0E =18B6 >884           BNE   PRTOPL5    
18A8: 68          >885           PLA              
18A9: 09 80       >886           ORA   #hibit     
18AB: 48          >887           PHA              
18AC: 68          >888  :PRTOPL4 PLA              
18AD: 9D 06 DE    >889           STA   TOPBUF,X   
18B0: EE DB 18    >890           INC   TOPSEGNO   
18B3: A6 06       >891           LDX   SAVE_X     
18B5: 60          >892           RTS              
                  >893  
18B6: 68          >894  PRTOPL5  PLA              
18B7: A6 06       >895           LDX   SAVE_X     
18B9: 60          >896           RTS              
                  >897  
18BA: 86 06       >898  CLRTOP   STX   SAVE_X     
18BC: 48          >899           PHA              
18BD: A2 01       >900           LDX   #1         
18BF: 8E 27 19    >901           STX   TOPSEG     
18C2: CA          >902           DEX              
18C3: 8E DB 18    >903           STX   TOPSEGNO   
                  >904  
18C6: A0 A0       >905           LDY   #160       
18C8: BD 1A DD    >906  :CLRTOP2 LDA   TOPMASK,X  
18CB: 9D 06 DE    >907           STA   TOPBUF,X   
18CE: E8          >908           INX              
18CF: 88          >909           DEY              
18D0: D0 F6 =18C8 >910           BNE   :CLRTOP2   
                  >911  
18D2: A2 FF       >912           LDX   #$FF       
18D4: 20 81 18    >913           JSR   PRTOPLN    
18D7: 68          >914           PLA              
18D8: A6 06       >915           LDX   SAVE_X     
18DA: 60          >916           RTS              
                  >917  
18DB: 00          >918  TOPSEGNO DB    0          
                  >919  
18DC: 98          >920  TOPSHOW  TYA              
18DD: 48          >921           PHA              
18DE: A9 01       >922           LDA   #1         
18E0: 20 9C 16    >923           JSR   SVCHCV     
18E3: A0 00       >924           LDY   #0         
18E5: 20 03 19    >925           JSR   SHOWLINE   
18E8: AC 27 19    >926           LDY   TOPSEG     
18EB: 20 03 19    >927           JSR   SHOWLINE   
                  >928  
18EE: A5 21       >929           LDA   WNDWDTH    
18F0: C9 50       >930           CMP   #80        
18F2: D0 0A =18FE >931           BNE   :TOP2      
                  >932  
18F4: A0 02       >933           LDY   #2         
18F6: 20 03 19    >934           JSR   SHOWLINE   
18F9: A0 03       >935           LDY   #3         
18FB: 20 03 19    >936           JSR   SHOWLINE   
                  >937  
18FE: 68          >938  :TOP2    PLA              
18FF: A8          >939           TAY              
1900: 4C AD 16    >940           JMP   LDCHCV     
                  >941  
1903: 8A          >942  SHOWLINE TXA              
1904: 48          >943           PHA              
1905: C6 32       >944           DEC   INVFLG     
1907: BE 23 19    >945           LDX   TOPSEGS,Y  
190A: A0 28       >946           LDY   #40        
                  >947  
190C: BD 06 DE    >948  :SHOW1   LDA   TOPBUF,X   
190F: 10 06 =1917 >949           BPL   :SHOW2     
1911: 24 33       >950           BIT   PWHIDE     
1913: 10 02 =1917 >951           BPL   :SHOW2     
1915: A9 2A       >952           LDA   #'*'       
1917: 20 06 09    >953  :SHOW2   JSR   VIDCOUT    
191A: E8          >954           INX              
191B: 88          >955           DEY              
191C: D0 EE =190C >956           BNE   :SHOW1     
                  >957  
191E: E6 32       >958           INC   INVFLG     
1920: 68          >959           PLA              
1921: AA          >960           TAX              
1922: 60          >961           RTS              
                  >962  
1923: 00 28 50 78 >963  TOPSEGS  DB    0,40,80,120 
                  >964  
1927: 01          >965  TOPSEG   DB    1          
                  >966  
                  >967  *-------------------------------
                  >968  * jsr pr data 0 -- quick print routine
                  >969  *-------------------------------
                  >970  
1928: 68          >971  PR       PLA              
1929: 85 0A       >972           STA   PRN        ;save calling address
192B: 68          >973           PLA              
192C: 85 0B       >974           STA   PRN+1      
192E: 98          >975           TYA              
192F: 48          >976           PHA              ;save Y
                  >977  
1930: E6 0A       >978  :PR2     INC   PRN        
1932: D0 02 =1936 >979           BNE   :PR3       ;get next byte
1934: E6 0B       >980           INC   PRN+1      
                  >981  
1936: A0 00       >982  :PR3     LDY   #0         
1938: B1 0A       >983           LDA   (PRN),Y    ;get byte
193A: F0 11 =194D >984           BEQ   :PR6       ;we're done
193C: 30 06 =1944 >985           BMI   :PR4       ;if high bit set use banner print
                  >986  
193E: 20 06 09    >987           JSR   VIDCOUT    ;otherwise use normal
1941: 4C 47 19    >988           JMP   :PR5       
                  >989  
1944: 20 0C 09    >990  :PR4     JSR   VIDBAN     ;print it
1947: 20 E8 1B    >991  :PR5     JSR   PAUSE      
194A: 4C 30 19    >992           JMP   :PR2       
                  >993  
194D: E6 0A       >994  :PR6     INC   PRN        
194F: D0 02 =1953 >995           BNE   :PR7       ;inc for return
1951: E6 0B       >996           INC   PRN+1      
                  >997  
1953: 68          >998  :PR7     PLA              
1954: A8          >999           TAY              ;restore Y
1955: 6C 0A 00    >1000          JMP   (PRN)      
                  >1001 
                  >1002 *-------------------------------
                  >1003 * execute a token
                  >1004 *-------------------------------
                  >1005 
1958: 08          >1006 EX_TOK   PHP              
1959: 66 6B       >1007          ROR   IMMDEF     ;save execution status
195B: 0A          >1008          ASL              ;a = a * 2
195C: B0 0F =196D >1009          BCS   :EX_TOK2   ;opps, not a token!
195E: A8          >1010          TAY              ;move to index
195F: B9 A2 D6    >1011          LDA   SYMADR,Y   
1962: 85 00       >1012          STA   TEMP       
1964: B9 A3 D6    >1013          LDA   SYMADR+1,Y 
1967: 85 01       >1014          STA   TEMP+1     
1969: 28          >1015          PLP              ;restore run state
196A: 6C 00 00    >1016          JMP   (TEMP)     ;exec command
                  >1017 
196D: 28          >1018 :EX_TOK2 PLP              ;remove from stack
196E: A2 02       >1019          LDX   #seg2big   
1970: 4C E1 12    >1020          JMP   BADERR     ;syntax error
                  >1021 
                  >1022 *-------------------------------
                  >1023 * show an error message
                  >1024 *-------------------------------
                  >1025 
1973: 20 91 19    >1026 SHERR    JSR   ERROR      ;show error message
1976: A9 3E       >1027          LDA   #'>'       
1978: 20 06 09    >1028          JSR   VIDCOUT    
197B: AD 38 DF    >1029          LDA   LNCNT      
197E: 48          >1030          PHA              
197F: A2 00       >1031          LDX   #0         ;reset line count
1981: BD 00 02    >1032 :SHERR2  LDA   LNBUF,X    ;print line
1984: E8          >1033          INX              
1985: 20 06 09    >1034          JSR   VIDCOUT    
1988: C9 0D       >1035          CMP   #cr        
198A: D0 F5 =1981 >1036          BNE   :SHERR2    
198C: 68          >1037          PLA              
198D: 8D 38 DF    >1038          STA   LNCNT      
1990: 60          >1039          RTS              
                  >1040 
                  >1041 *-------------------------------
                  >1042 * print an error message
                  >1043 *-------------------------------
                  >1044 
1991: 86 06       >1045 ERROR    STX   SAVE_X     
1993: E0 00       >1046          CPX   #0         
1995: F0 1C =19B3 >1047          BEQ   ERROR2     ;error?, nope
1997: A9 0D       >1048          LDA   #cr        
1999: 20 06 09    >1049          JSR   VIDCOUT    
199C: 20 06 09    >1050          JSR   VIDCOUT    
199F: A9 7C       >1051          LDA   #<ERRMSGS  ;point to error messages
19A1: 85 0A       >1052          STA   PRN        
19A3: A9 D7       >1053          LDA   #>ERRMSGS  
19A5: 85 0B       >1054          STA   PRN+1      
19A7: A6 06       >1055          LDX   SAVE_X     
19A9: 20 D2 19    >1056          JSR   PRMSG2     
19AC: A9 0D       >1057          LDA   #cr        ;print cr/lf
19AE: 20 06 09    >1058          JSR   VIDCOUT    
19B1: A6 06       >1059          LDX   SAVE_X     
19B3: 60          >1060 ERROR2   RTS              
                  >1061 
                  >1062 *-------------------------------
                  >1063 * print an editor message
                  >1064 *-------------------------------
                  >1065 
19B4: A9 DA       >1066 PREDMSG  LDA   #<EDMSGS   ;point to editor messages
19B6: 85 0A       >1067          STA   PRN        
19B8: A9 D9       >1068          LDA   #>EDMSGS   
19BA: 85 0B       >1069          STA   PRN+1      
19BC: 4C D2 19    >1070          JMP   PRMSG2     
                  >1071 
                  >1072 *-------------------------------
                  >1073 * print compiler messages
                  >1074 *-------------------------------
                  >1075 
19BF: A9 43       >1076 PRCMPMSG LDA   #<COMPMSGS ;point to compiler messages
19C1: 85 0A       >1077          STA   PRN        
19C3: A9 DC       >1078          LDA   #>COMPMSGS 
19C5: 85 0B       >1079          STA   PRN+1      
19C7: 4C D2 19    >1080          JMP   PRMSG2     
                  >1081 
                  >1082 *-------------------------------
                  >1083 * print misc messages
                  >1084 *-------------------------------
                  >1085 
19CA: A9 14       >1086 PRMSG    LDA   #<MISCMSGS ;point to misc messages
19CC: 85 0A       >1087          STA   PRN        
19CE: A9 D9       >1088          LDA   #>MISCMSGS 
19D0: 85 0B       >1089          STA   PRN+1      
                  >1090 
                  >1091 *-------------------------------
                  >1092 * print error messages
                  >1093 *-------------------------------
                  >1094 
19D2: A0 00       >1095 PRMSG2   LDY   #0         ;get data
19D4: B1 0A       >1096 :PRMSG3  LDA   (PRN),Y    
19D6: C8          >1097          INY              
19D7: D0 02 =19DB >1098          BNE   :PRMSG4    ;move pointers
19D9: E6 0B       >1099          INC   PRN+1      
19DB: 0A          >1100 :PRMSG4  ASL              ;done?
19DC: 90 F6 =19D4 >1101          BCC   :PRMSG3    ;nope
                  >1102 
19DE: CA          >1103          DEX              
19DF: D0 F3 =19D4 >1104          BNE   :PRMSG3    ;done?, nope
                  >1105 
19E1: B1 0A       >1106 :PRMSG5  LDA   (PRN),Y    ;get data
19E3: 08          >1107          PHP              
19E4: 29 7F       >1108          AND   #clrhi     
19E6: 20 7B 17    >1109          JSR   COUT       ;show char
19E9: C8          >1110          INY              
19EA: D0 02 =19EE >1111          BNE   :PRMSG6    
19EC: E6 0B       >1112          INC   PRN+1      
19EE: 28          >1113 :PRMSG6  PLP              
19EF: 10 F0 =19E1 >1114          BPL   :PRMSG5    ;end, nope, loop
19F1: 60          >1115          RTS              
                  >1116 
                  >1117 *-------------------------------
                  >1118 * get next type of input
                  >1119 *-------------------------------
                  >1120 
19F2: A0 00       >1121 INPTYP   LDY   #0         
19F4: B1 04       >1122          LDA   (PRGPTR),Y ;get current program byte
19F6: 10 14 =1A0C >1123          BPL   :INPTYP3   ;if some sort of token
                  >1124 
19F8: A2 01       >1125          LDX   #1         
19FA: C9 A8       >1126          CMP   #"("       
19FC: F0 0C =1A0A >1127          BEQ   :INPTYP2   ;is it an expression
                  >1128 
19FE: E8          >1129          INX              
19FF: C9 A2       >1130          CMP   #"""       
1A01: F0 07 =1A0A >1131          BEQ   :INPTYP2   ;is it data?
                  >1132 
1A03: E8          >1133          INX              
1A04: 20 60 17    >1134          JSR   TST_NUM    ;is it a number?
1A07: 90 01 =1A0A >1135          BCC   :INPTYP2   ;yep
                  >1136 
1A09: E8          >1137 :INPTYP1 INX              
1A0A: 8A          >1138 :INPTYP2 TXA              
1A0B: 60          >1139          RTS              
                  >1140 
1A0C: A2 06       >1141 :INPTYP3 LDX   #6         
1A0E: C9 01       >1142          CMP   #number    
1A10: F0 F8 =1A0A >1143          BEQ   :INPTYP2   ;is it a var number?
                  >1144 
1A12: CA          >1145          DEX              
1A13: C9 02       >1146          CMP   #string    
1A15: F0 F3 =1A0A >1147          BEQ   :INPTYP2   ;is it a var string?
                  >1148 
1A17: A2 00       >1149          LDX   #0         
1A19: C9 08       >1150          CMP   #chain     
1A1B: F0 ED =1A0A >1151          BEQ   :INPTYP2   ;is it a statement separator?
1A1D: C9 09       >1152          CMP   #chain2    ;is it an eol (chain2)?
1A1F: F0 E9 =1A0A >1153          BEQ   :INPTYP2   
1A21: D0 E6 =1A09 >1154          BNE   :INPTYP1   ;must be a token
                  >1155 
                  >1156 *-------------------------------
                  >1157 * translate a binary to text [0-99]
                  >1158 *-------------------------------
                  >1159 
1A23: A0 00       >1160 BINDEC8  LDY   #0         ;start 10's counter
1A25: C9 0A       >1161 :BIN8A   CMP   #10        
1A27: 90 05 =1A2E >1162          BLT   :BIN8B     ;less than 10, were done
                  >1163 
1A29: E9 0A       >1164          SBC   #10        ;minus 10
1A2B: C8          >1165          INY              
1A2C: D0 F7 =1A25 >1166          BNE   :BIN8A     ;add 1 to the 10's counter, loop
                  >1167 
1A2E: 09 30       >1168 :BIN8B   ORA   #'0'       ;make 1's into text
1A30: AA          >1169          TAX              ;save
1A31: 98          >1170          TYA              
1A32: 09 30       >1171          ORA   #'0'       ;make 10's into text
1A34: 60          >1172          RTS              ;done
                  >1173 
                  >1174 *-------------------------------
                  >1175 * decimal output without negative translation
                  >1176 *-------------------------------
                  >1177 
1A35: 8E 11 DF    >1178 DECOUT0  STX   NUM        ;save number
1A38: 8D 12 DF    >1179          STA   NUM+1      
1A3B: 4C 50 1A    >1180          JMP   DECOUT1    ;do normal output
                  >1181 
                  >1182 *-------------------------------
                  >1183 * display a decimal number [-32767 to +32767]
                  >1184 *-------------------------------
                  >1185 
1A3E: 48          >1186 DECOUT   PHA              ;save status
1A3F: 20 A1 22    >1187          JSR   DO_ABS1    ;make positive
1A42: 8E 11 DF    >1188          STX   NUM        ;save number
1A45: 8D 12 DF    >1189          STA   NUM+1      
1A48: 68          >1190          PLA              
1A49: 10 05 =1A50 >1191          BPL   DECOUT1    ;display negative sign?
                  >1192 
1A4B: A9 2D       >1193          LDA   #'-'       ;show it is negative
1A4D: 20 B5 37    >1194          JSR   DO_OUT     
                  >1195 
1A50: A9 00       >1196 DECOUT1  LDA   #0         
1A52: 8D 13 DF    >1197          STA   NUM+2      
1A55: 8D 14 DF    >1198          STA   NUM+3      
1A58: 8D 16 DF    >1199          STA   NUM+5      
1A5B: 8D 17 DF    >1200          STA   NUM+6      
1A5E: F8          >1201          SED              
                  >1202 
1A5F: A0 10       >1203          LDY   #16        ;use decimal mode
1A61: 0E 11 DF    >1204 :DECOUT2 ASL   NUM        
1A64: 2E 12 DF    >1205          ROL   NUM+1      
1A67: AD 13 DF    >1206          LDA   NUM+2      
1A6A: 6D 13 DF    >1207          ADC   NUM+2      
1A6D: 8D 13 DF    >1208          STA   NUM+2      ;do actual 'woz' conversion
1A70: AD 14 DF    >1209          LDA   NUM+3      
1A73: 6D 14 DF    >1210          ADC   NUM+3      
1A76: 8D 14 DF    >1211          STA   NUM+3      ;do actual 'woz' conversion
1A79: 2E 15 DF    >1212          ROL   NUM+4      
1A7C: 88          >1213          DEY              
1A7D: D0 E2 =1A61 >1214          BNE   :DECOUT2   ;loop down
                  >1215 
1A7F: D8          >1216          CLD              ;done with decimal
1A80: A0 04       >1217          LDY   #4         ;print 5 digits
                  >1218 
1A82: AD 15 DF    >1219 :DECOUT3 LDA   NUM+4      ;get digit
1A85: 29 0F       >1220          AND   #$F        
1A87: D0 05 =1A8E >1221          BNE   :DECOUT4   ;is it zero?
                  >1222 
1A89: 2C 16 DF    >1223          BIT   NUM+5      ;is this a leading zero?
1A8C: 10 11 =1A9F >1224          BPL   :DECOUT5   ;yep
                  >1225 
1A8E: CE 16 DF    >1226 :DECOUT4 DEC   NUM+5      
1A91: 09 30       >1227          ORA   #'0'       ;print digit
1A93: AE 17 DF    >1228          LDX   NUM+6      
1A96: 9D 19 DF    >1229          STA   TXTNUM+1,X ;save number to memory
1A99: EE 17 DF    >1230          INC   NUM+6      
1A9C: 20 B5 37    >1231          JSR   DO_OUT     
                  >1232 
1A9F: A2 03       >1233 :DECOUT5 LDX   #3         ;move up next digit
1AA1: 0E 12 DF    >1234 :DECOUT6 ASL   NUM+1      
1AA4: 2E 13 DF    >1235          ROL   NUM+2      
1AA7: 2E 14 DF    >1236          ROL   NUM+3      
1AAA: 2E 15 DF    >1237          ROL   NUM+4      
1AAD: CA          >1238          DEX              
1AAE: 10 F1 =1AA1 >1239          BPL   :DECOUT6   
                  >1240 
1AB0: 88          >1241          DEY              
1AB1: 30 07 =1ABA >1242          BMI   :DECOUT7   
1AB3: D0 CD =1A82 >1243          BNE   :DECOUT3   ;count down digits
                  >1244 
1AB5: 8E 16 DF    >1245          STX   NUM+5      ;print last zero for sure
1AB8: 10 C8 =1A82 >1246          BPL   :DECOUT3   
1ABA: AD 17 DF    >1247 :DECOUT7 LDA   NUM+6      
1ABD: 8D 18 DF    >1248          STA   TXTNUM     ;save number length
1AC0: 60          >1249          RTS              
                  >1250 
                  >1251 *-------------------------------
                  >1252 * input a number from memory of from program [0-65535]
                  >1253 *-------------------------------
                  >1254 
1AC1: A9 00       >1255 NUMIN    LDA   #0         ;zero totals
1AC3: 8D 11 DF    >1256          STA   NUM        
1AC6: 8D 12 DF    >1257          STA   NUM+1      
1AC9: 8D 2A DF    >1258          STA   NEGFLG     
                  >1259 
1ACC: 20 E4 16    >1260          JSR   CHKBYT     ;is this negative?
1ACF: C9 67       >1261          CMP   #minus     
1AD1: D0 06 =1AD9 >1262          BNE   NUMIN2     ;nope
1AD3: CE 2A DF    >1263          DEC   NEGFLG     ;flag as neg
1AD6: 20 CC 16    >1264          JSR   GETBYT     ;skip the -
                  >1265 
1AD9: 20 E4 16    >1266 NUMIN2   JSR   CHKBYT     ;get digit
1ADC: 10 0E =1AEC >1267          BPL   NUMIN4     
                  >1268 
1ADE: 20 60 17    >1269          JSR   TST_NUM    
1AE1: B0 09 =1AEC >1270          BCS   NUMIN4     
                  >1271 
1AE3: 20 CC 16    >1272          JSR   GETBYT     ;get digit
1AE6: 20 FB 1A    >1273          JSR   XNUMIN     ;process
1AE9: 4C D9 1A    >1274          JMP   NUMIN2     ;loop
                  >1275 
1AEC: AE 11 DF    >1276 NUMIN4   LDX   NUM        ;get the value
1AEF: AD 12 DF    >1277          LDA   NUM+1      
1AF2: 2C 2A DF    >1278          BIT   NEGFLG     ;was it negative?
1AF5: 10 03 =1AFA >1279          BPL   :POS       ;nope
                  >1280 
1AF7: 20 A5 22    >1281          JSR   NEGXA      ;invert it
1AFA: 60          >1282 :POS     RTS              
                  >1283 
                  >1284 *-------------------------------
                  >1285 * process digit
                  >1286 *-------------------------------
                  >1287 
1AFB: 29 0F       >1288 XNUMIN   AND   #$F        ;make into range 0..9
1AFD: 8D 13 DF    >1289          STA   NUM+2      
1B00: A9 00       >1290          LDA   #0         
1B02: 8D 14 DF    >1291          STA   NUM+3      
                  >1292 
1B05: A2 0A       >1293          LDX   #10        ;(num+2) = (num+2)+(num*10)
1B07: 18          >1294 :XNUMIN3 CLC              
1B08: AD 11 DF    >1295          LDA   NUM        
1B0B: 6D 13 DF    >1296          ADC   NUM+2      
1B0E: 8D 13 DF    >1297          STA   NUM+2      
1B11: AD 12 DF    >1298          LDA   NUM+1      
1B14: 6D 14 DF    >1299          ADC   NUM+3      
1B17: 8D 14 DF    >1300          STA   NUM+3      
1B1A: CA          >1301          DEX              
1B1B: D0 EA =1B07 >1302          BNE   :XNUMIN3   ;num = num * 10
                  >1303 
1B1D: AD 13 DF    >1304          LDA   NUM+2      
1B20: 8D 11 DF    >1305          STA   NUM        ;move new total
1B23: AD 14 DF    >1306          LDA   NUM+3      
1B26: 8D 12 DF    >1307          STA   NUM+1      
1B29: 60          >1308          RTS              ;keep going
                  >1309 
                  >1310 *-------------------------------
                  >1311 * input a number from a pointer
                  >1312 *-------------------------------
                  >1313 
1B2A: A9 00       >1314 ZNUMIN   LDA   #0         ;zero totals
1B2C: 8D 11 DF    >1315          STA   NUM        
1B2F: 8D 12 DF    >1316          STA   NUM+1      
1B32: 8D 2A DF    >1317          STA   NEGFLG     
                  >1318 
1B35: A0 00       >1319          LDY   #0         
1B37: B1 13       >1320          LDA   (TEMP3),Y  ;is this negative?
1B39: C9 2D       >1321          CMP   #'-'       
1B3B: D0 09 =1B46 >1322          BNE   :ZNUMIN2   ;nope
1B3D: CE 2A DF    >1323          DEC   NEGFLG     ;flag as neg
1B40: E6 13       >1324          INC   TEMP3      ;skip the -
1B42: D0 02 =1B46 >1325          BNE   :ZNUMIN2   
1B44: E6 14       >1326          INC   TEMP3+1    
                  >1327 
1B46: A0 00       >1328 :ZNUMIN2 LDY   #0         
1B48: B1 13       >1329          LDA   (TEMP3),Y  ;get char
1B4A: 20 60 17    >1330          JSR   TST_NUM    
1B4D: B0 9D =1AEC >1331          BCS   NUMIN4     ;we're done
                  >1332 
1B4F: E6 13       >1333          INC   TEMP3      
1B51: D0 02 =1B55 >1334          BNE   :ZNUMIN3   
1B53: E6 14       >1335          INC   TEMP3+1    
                  >1336 
1B55: 20 FB 1A    >1337 :ZNUMIN3 JSR   XNUMIN     ;process digit
1B58: 4C 46 1B    >1338          JMP   :ZNUMIN2   ;loop
                  >1339 
                  >1340 *-------------------------------
                  >1341 * show the program as it runs
                  >1342 *-------------------------------
                  >1343 
1B5B: 48          >1344 LIST     PHA              
1B5C: 8D E6 1B    >1345          STA   LSTNUM     ;save all registers
1B5F: 8A          >1346          TXA              
1B60: 48          >1347          PHA              
1B61: 98          >1348          TYA              
1B62: 48          >1349          PHA              
                  >1350 
1B63: AD E6 1B    >1351          LDA   LSTNUM     
1B66: AE E7 1B    >1352          LDX   LSTVAR     ;are we showing a variable?
1B69: D0 33 =1B9E >1353          BNE   :LIST10    ;yep
                  >1354 
1B6B: A6 6C       >1355          LDX   LSTTXT     ;are we in text mode?
1B6D: D0 18 =1B87 >1356          BNE   :LIST11    ;yep
                  >1357 
1B6F: C9 00       >1358          CMP   #0         
1B71: 30 14 =1B87 >1359          BMI   :LIST11    ;is it a token?, nope
                  >1360 
1B73: A2 A4       >1361          LDX   #"$"       
1B75: C9 02       >1362          CMP   #string    
1B77: F0 1C =1B95 >1363          BEQ   :LIST3     ;is it a string?, nope
                  >1364 
1B79: A2 A3       >1365          LDX   #"#"       
1B7B: C9 01       >1366          CMP   #number    
1B7D: F0 16 =1B95 >1367          BEQ   :LIST3     ;is it a number?, nope
                  >1368 
1B7F: C9 09       >1369          CMP   #chain2    
1B81: F0 59 =1BDC >1370          BEQ   :LIST13    ;is it a statement link?, nope
                  >1371 
1B83: C9 00       >1372          CMP   #0         
1B85: 10 1D =1BA4 >1373          BPL   :LIST4     ;is it a token?, yes
                  >1374 
1B87: 09 80       >1375 :LIST11  ORA   #hibit     ;display text
1B89: 20 0C 09    >1376          JSR   VIDBAN     
                  >1377 
1B8C: 20 E8 1B    >1378          JSR   PAUSE      
1B8F: 68          >1379          PLA              
1B90: A8          >1380          TAY              ;restore & return
1B91: 68          >1381          PLA              
1B92: AA          >1382          TAX              
1B93: 68          >1383          PLA              
1B94: 60          >1384          RTS              
                  >1385 
1B95: A0 02       >1386 :LIST3   LDY   #2         ;setup to show next 2 variable
1B97: 8C E7 1B    >1387          STY   LSTVAR     ;bytes
1B9A: 8A          >1388          TXA              
1B9B: 4C 87 1B    >1389          JMP   :LIST11    
                  >1390 
1B9E: CE E7 1B    >1391 :LIST10  DEC   LSTVAR     ;count down display time
1BA1: 4C 87 1B    >1392          JMP   :LIST11    
                  >1393 
1BA4: AA          >1394 :LIST4   TAX              
1BA5: A0 00       >1395          LDY   #0         
1BA7: A9 00       >1396          LDA   #<SYMTXT   
1BA9: 85 11       >1397          STA   LSTPTR     
1BAB: A9 D5       >1398          LDA   #>SYMTXT   
1BAD: 85 12       >1399          STA   LSTPTR+1   
1BAF: CA          >1400          DEX              
                  >1401 
1BB0: B1 11       >1402 :LIST5   LDA   (LSTPTR),Y 
1BB2: C8          >1403          INY              
1BB3: D0 02 =1BB7 >1404          BNE   :LIST5A    ;goto next byte
                  >1405 
1BB5: E6 12       >1406          INC   LSTPTR+1   
1BB7: 0A          >1407 :LIST5A  ASL              ;we done?
1BB8: 90 F6 =1BB0 >1408          BCC   :LIST5     ;nope
1BBA: CA          >1409          DEX              
1BBB: 10 F3 =1BB0 >1410          BPL   :LIST5     ;keep going
                  >1411 
1BBD: B1 11       >1412 :LIST6   LDA   (LSTPTR),Y ;get data
1BBF: 48          >1413          PHA              
                  >1414 
1BC0: 09 80       >1415          ORA   #hibit     ;display it
1BC2: 20 0C 09    >1416          JSR   VIDBAN     
                  >1417 
1BC5: C8          >1418          INY              
1BC6: D0 02 =1BCA >1419          BNE   :LIST6A    ;inc pointers
1BC8: E6 12       >1420          INC   LSTPTR+1   
1BCA: 68          >1421 :LIST6A  PLA              
1BCB: 10 F0 =1BBD >1422          BPL   :LIST6     
                  >1423 
1BCD: AD E6 1B    >1424          LDA   LSTNUM     ;check for tokens that use a label
1BD0: C9 04       >1425          CMP   #goto      
1BD2: F0 08 =1BDC >1426          BEQ   :LIST13    
1BD4: C9 06       >1427          CMP   #push      
1BD6: F0 04 =1BDC >1428          BEQ   :LIST13    
1BD8: C9 05       >1429          CMP   #gosub     
1BDA: D0 05 =1BE1 >1430          BNE   :LIST8B    
                  >1431 
1BDC: A9 BA       >1432 :LIST13  LDA   #":"       ;also do chain statement
1BDE: 20 0C 09    >1433          JSR   VIDBAN     
                  >1434 
1BE1: A9 A0       >1435 :LIST8B  LDA   #" "       
1BE3: 4C 87 1B    >1436          JMP   :LIST11    
                  >1437 
1BE6: 00          >1438 LSTNUM   DB    0          
1BE7: 00          >1439 LSTVAR   DB    0          
                  >1440 
                  >1441 *-------------------------------
                  >1442 * check to see if pause should go into effect
                  >1443 *-------------------------------
                  >1444 
1BE8: 20 21 09    >1445 PAUSE    JSR   VIDKEY     ;check local keyboard
1BEB: C9 9A       >1446          CMP   #"Z"-ctrl  
1BED: F0 04 =1BF3 >1447          BEQ   :PAUSE1    
1BEF: C9 1A       >1448          CMP   #'Z'-ctrl  
1BF1: D0 08 =1BFB >1449          BNE   :PAUSE3    
                  >1450 
1BF3: 8D 10 C0    >1451 :PAUSE1  STA   KBDSTRB    
1BF6: 20 CC 15    >1452 :PAUSE2  JSR   GET        ;wait for a keypress
1BF9: F0 FB =1BF6 >1453          BEQ   :PAUSE2    
1BFB: 60          >1454 :PAUSE3  RTS              
                  >1455 
                  >1456 *-------------------------------
                  >1457 * repeat and print a character
                  >1458 *-------------------------------
                  >1459 
1BFC: 20 06 09    >1460 PRCHR    JSR   VIDCOUT    
1BFF: CA          >1461          DEX              
1C00: D0 FA =1BFC >1462          BNE   PRCHR      
1C02: 60          >1463          RTS              
                  >1464 
                  >1465 *-------------------------------
                  >1466 * standard Apple beep
                  >1467 *-------------------------------
                  >1468 
1C03: 48          >1469 DO_BELL  PHA              
1C04: 98          >1470          TYA              
1C05: 48          >1471          PHA              
1C06: A0 B0       >1472          LDY   #$B0       
1C08: A9 0C       >1473 :BELL2   LDA   #$C        
1C0A: 20 17 1C    >1474          JSR   WAIT       
1C0D: AD 30 C0    >1475          LDA   SPKR       
1C10: 88          >1476          DEY              
1C11: D0 F5 =1C08 >1477          BNE   :BELL2     
1C13: 68          >1478          PLA              
1C14: A8          >1479          TAY              
1C15: 68          >1480          PLA              
1C16: 60          >1481          RTS              
                  >1482 
                  >1483 *-------------------------------
                  >1484 * copy of monitor wait routine
                  >1485 *-------------------------------
                  >1486 
1C17: 38          >1487 WAIT     SEC              
1C18: 48          >1488 :WAIT2   PHA              
1C19: E9 01       >1489 :WAIT3   SBC   #1         
1C1B: D0 FC =1C19 >1490          BNE   :WAIT3     
1C1D: 68          >1491          PLA              
1C1E: E9 01       >1492          SBC   #1         
1C20: D0 F6 =1C18 >1493          BNE   :WAIT2     
1C22: 60          >1494          RTS              
                  >1495 
                  >1496 *-------------------------------
                  >1497 * save current line into buffer
                  >1498 *-------------------------------
                  >1499 
1C23: A6 25       >1500 SVLINE   LDX   CV         
1C25: A4 21       >1501          LDY   WNDWDTH    
1C27: 88          >1502          DEY              
1C28: 20 1E 09    >1503 :SVLINE2 JSR   VIDRD      ;read character
1C2B: 99 66 DF    >1504          STA   CHATBUF+2,Y 
1C2E: 88          >1505          DEY              
1C2F: 10 F7 =1C28 >1506          BPL   :SVLINE2   ;save entire line
                  >1507 
1C31: A5 24       >1508          LDA   CH         
1C33: 8D 64 DF    >1509          STA   CHATBUF    ;save current ch position
1C36: AD 99 16    >1510          LDA   INPMODE    
1C39: 8D 65 DF    >1511          STA   CHATBUF+1  ;save current input mode
1C3C: 60          >1512          RTS              
                  >1513 
                  >1514 *-------------------------------
                  >1515 * restore current line in buffer
                  >1516 *-------------------------------
                  >1517 
1C3D: AE 64 DF    >1518 RSTLINE  LDX   CHATBUF    ;get length
1C40: F0 0C =1C4E >1519          BEQ   :RSTLN3    ;no data
                  >1520 
1C42: A0 00       >1521          LDY   #0         
1C44: B9 66 DF    >1522 :RSTLN2  LDA   CHATBUF+2,Y 
1C47: 20 7B 17    >1523          JSR   COUT       ;print line
1C4A: C8          >1524          INY              
1C4B: CA          >1525          DEX              
1C4C: D0 F6 =1C44 >1526          BNE   :RSTLN2    
                  >1527 
1C4E: AD 65 DF    >1528 :RSTLN3  LDA   CHATBUF+1  
1C51: 8D 99 16    >1529          STA   INPMODE    
1C54: 60          >1530          RTS              
                  >1531 
                  >1532 *-------------------------------
                  >1533 * set exec mode to verify users, etc...
                  >1534 *-------------------------------
                  >1535 
1C55: A9 02       >1536 DO_EXEC  LDA   #2         
1C57: 20 27 09    >1537          JSR   VIDCHAT    ;show exec on message
                  >1538 
1C5A: A5 1C       >1539          LDA   EXEC       
1C5C: 8D 9D 1C    >1540          STA   OLDEXEC    ;save old status
1C5F: AD 35 DF    >1541          LDA   REMOTE     
1C62: 8D 9E 1C    >1542          STA   OLDRMT     
                  >1543 
1C65: A9 FF       >1544          LDA   #$FF       
1C67: 85 1C       >1545          STA   EXEC       ;set exec mode on
                  >1546 
1C69: A2 04       >1547          LDX   #hangon    ;show ...please wait... msg
1C6B: 20 CA 19    >1548          JSR   PRMSG      
                  >1549 
1C6E: A9 00       >1550          LDA   #0         
1C70: 8D 35 DF    >1551          STA   REMOTE     ;set to local input/output mode
1C73: 85 5D       >1552          STA   DOCHAT     ;reset chat flag
1C75: 85 5E       >1553          STA   INCHAT     ;no actually in chat
1C77: 4C 3D 1C    >1554          JMP   RSTLINE    ;restore copy of line
                  >1555 
1C7A: A9 00       >1556 EXEC2    LDA   #0         ;get rid of exec mode flag
1C7C: 20 27 09    >1557          JSR   VIDCHAT    
                  >1558 
1C7F: A2 05       >1559          LDX   #exitexec  ;print ...exiting.. msg
1C81: 20 CA 19    >1560          JSR   PRMSG      
                  >1561 
1C84: AD 9D 1C    >1562          LDA   OLDEXEC    
1C87: 85 1C       >1563          STA   EXEC       ;restore exec state
1C89: AD 9E 1C    >1564          LDA   OLDRMT     
1C8C: 8D 35 DF    >1565          STA   REMOTE     ;restore remote state
                  >1566 
1C8F: 20 3D 1C    >1567          JSR   RSTLINE    ;put back extra
                  >1568 
1C92: 24 5D       >1569          BIT   DOCHAT     ;check chat mode
1C94: 70 14 =1CAA >1570          BVS   CHAT2      ;go directly into chat
                  >1571 
1C96: A9 00       >1572          LDA   #0         
1C98: 85 5D       >1573          STA   DOCHAT     ;reset all modes
1C9A: 85 5E       >1574          STA   INCHAT     
1C9C: 60          >1575          RTS              
                  >1576 
1C9D: 00          >1577 OLDEXEC  DB    0          
1C9E: 00          >1578 OLDRMT   DB    0          
                  >1579 
                  >1580 *-------------------------------
                  >1581 * chat with user routine
                  >1582 *-------------------------------
                  >1583 
1C9F: 20 23 1C    >1584 DO_CHAT  JSR   SVLINE     ;save current line
1CA2: 24 1C       >1585          BIT   EXEC       ;exit exec mode
1CA4: 70 D4 =1C7A >1586          BVS   EXEC2      
                  >1587 
1CA6: 24 5D       >1588          BIT   DOCHAT     
1CA8: 50 AB =1C55 >1589          BVC   DO_EXEC    ;opps, we really want exec mode
                  >1590 
1CAA: A2 01       >1591 CHAT2    LDX   #sysopon   ;sysop online msg
1CAC: 20 CA 19    >1592          JSR   PRMSG      
1CAF: A9 30       >1593          LDA   #$30       
1CB1: 8D 99 16    >1594          STA   INPMODE    ;accept u/l, cr, word-wrap, etc
1CB4: A9 00       >1595          LDA   #0         
1CB6: 85 5D       >1596          STA   DOCHAT     ;reset chat
1CB8: 20 27 09    >1597          JSR   VIDCHAT    ;turn off chat message
                  >1598 
1CBB: 20 C4 13    >1599 :CHAT4   JSR   INPLN      ;get a line of type
1CBE: 24 61       >1600          BIT   LOGOFF     
1CC0: 30 13 =1CD5 >1601          BMI   :CHAT6     
                  >1602 
1CC2: 24 5D       >1603          BIT   DOCHAT     ;exit?
1CC4: 10 F5 =1CBB >1604          BPL   :CHAT4     ;nope
                  >1605 
1CC6: A2 02       >1606          LDX   #sysopoff  ;sysop offline msg
1CC8: 20 CA 19    >1607          JSR   PRMSG      
1CCB: 20 3D 1C    >1608          JSR   RSTLINE    ;restore line
                  >1609 
1CCE: 24 5D       >1610          BIT   DOCHAT     ;do they want to exec?
1CD0: 70 03 =1CD5 >1611          BVS   :CHAT6     
1CD2: 4C 55 1C    >1612          JMP   DO_EXEC    ;yep
                  >1613 
1CD5: A9 00       >1614 :CHAT6   LDA   #0         
1CD7: 85 5D       >1615          STA   DOCHAT     ;clear chat flag
1CD9: 85 5E       >1616          STA   INCHAT     
1CDB: 60          >1617          RTS              
                  >1618 
                  >1619 *-------------------------------
                  >1620 * handle ram drive input
                  >1621 *-------------------------------
                  >1622 
1CDC: 84 07       >1623 RAMIN    STY   SAVE_Y     
1CDE: A9 00       >1624          LDA   #0         ;default to no data
1CE0: A4 75       >1625          LDY   RAMPTR     ;get pointer
1CE2: 30 05 =1CE9 >1626          BMI   :RAMIN2    ;opps, out of range
                  >1627 
1CE4: B9 80 B6    >1628          LDA   RAMDRV,Y   ;get data
1CE7: E6 75       >1629          INC   RAMPTR     ;move pointer
1CE9: A4 07       >1630 :RAMIN2  LDY   SAVE_Y     
1CEB: 60          >1631          RTS              ;we are done
                  >1632 
                  >1633 *-------------------------------
                  >1634 * handle ram drive output
                  >1635 *-------------------------------
                  >1636 
1CEC: 84 07       >1637 RAMOUT   STY   SAVE_Y     
1CEE: A4 75       >1638          LDY   RAMPTR     ;is pointer in range?
1CF0: 30 05 =1CF7 >1639          BMI   :RAMOUT2   ;nope
                  >1640 
1CF2: 99 80 B6    >1641          STA   RAMDRV,Y   ;save data
1CF5: E6 75       >1642          INC   RAMPTR     ;move pointer
1CF7: A4 07       >1643 :RAMOUT2 LDY   SAVE_Y     
1CF9: 60          >1644          RTS              
                  >1645 
                  >1646 *-------------------------------
                  >1647 * setup input vector
                  >1648 *-------------------------------
                  >1649 
1CFA: 98          >1650 SETIVEC  TYA              
1CFB: 0A          >1651          ASL              
1CFC: AA          >1652          TAX              
1CFD: BD C9 DC    >1653          LDA   INPVEC,X   
1D00: 85 56       >1654          STA   VECTOR2    
1D02: BD CA DC    >1655          LDA   INPVEC+1,X 
1D05: 85 57       >1656          STA   VECTOR2+1  
1D07: 60          >1657          RTS              
                  >1658 
                  >1659 *-------------------------------
                  >1660 * setup output vector
                  >1661 *-------------------------------
                  >1662 
1D08: 98          >1663 SETOVEC  TYA              
1D09: 0A          >1664          ASL              
1D0A: AA          >1665          TAX              
1D0B: BD DF DC    >1666          LDA   OUTVEC,X   
1D0E: 85 15       >1667          STA   VECTOR     
1D10: BD E0 DC    >1668          LDA   OUTVEC+1,X 
1D13: 85 16       >1669          STA   VECTOR+1   
1D15: 60          >1670          RTS              
                  >1671 
                  >1672 *-------------------------------
                  >1673 * send to modem only
                  >1674 *-------------------------------
                  >1675 
1D16: 20 18 0E    >1676 ZMDMOUT  JSR   MDMOUT     ;send data
1D19: C9 0D       >1677          CMP   #cr        ;add LF to CR?, nope
1D1B: D0 07 =1D24 >1678          BNE   :ZMDM2     
                  >1679 
1D1D: A9 0A       >1680          LDA   #lf        ;send LF
1D1F: 20 18 0E    >1681          JSR   MDMOUT     
1D22: A9 0D       >1682          LDA   #cr        ;set back to CR
1D24: 60          >1683 :ZMDM2   RTS              
                   34            PUT   VAR        
                  >2    ********************************
                  >3    *                              *
                  >4    *     ACOS.OBJ - Variables     *
                  >5    *                              *
                  >6    ********************************
                                  3-MAR-23   9:23:08 AM
                  >8    *-------------------------------
                  >9    * set up pointers to variables
                  >10   *-------------------------------
                  >11   
1D25: 20 CC 16    >12   VARSET   JSR   GETBYT     ;get string or number indicator
1D28: 48          >13            PHA              
1D29: 20 CC 16    >14            JSR   GETBYT     ;get name
1D2C: 85 81       >15            STA   VNAME      
1D2E: 20 CC 16    >16            JSR   GETBYT     
1D31: 85 82       >17            STA   VNAME+1    
1D33: 68          >18            PLA              
1D34: C9 01       >19            CMP   #number    
1D36: F0 0F =1D47 >20            BEQ   VARSET3    ;handle number
                  >21   
1D38: C9 02       >22            CMP   #string    
1D3A: F0 05 =1D41 >23            BEQ   :VARSET2   ;handle string
                  >24   
1D3C: A2 05       >25            LDX   #syntax    
1D3E: 4C E1 12    >26            JMP   BADERR     ;syntax error!
                  >27   
1D41: A5 81       >28   :VARSET2 LDA   VNAME      ;show it's a string
1D43: 09 80       >29            ORA   #hibit     
1D45: 85 81       >30            STA   VNAME      ;point to start of pointers
1D47: A5 73       >31   VARSET3  LDA   HIMEM      
1D49: 85 00       >32            STA   TEMP       
1D4B: A5 74       >33            LDA   HIMEM+1    
1D4D: 85 01       >34            STA   TEMP+1     
1D4F: 38          >35   :VARSET5 SEC              ;temp = temp - 6
1D50: A5 00       >36            LDA   TEMP       
1D52: E9 06       >37            SBC   #6         
1D54: 85 00       >38            STA   TEMP       
1D56: A5 01       >39            LDA   TEMP+1     
1D58: E9 00       >40            SBC   #0         
1D5A: 85 01       >41            STA   TEMP+1     
                  >42   
1D5C: A0 00       >43            LDY   #0         
1D5E: B1 00       >44            LDA   (TEMP),Y   ;check low byte
1D60: F0 1A =1D7C >45            BEQ   :VARSET8   ;create new var
                  >46   
1D62: C5 81       >47            CMP   VNAME      
1D64: D0 E9 =1D4F >48            BNE   :VARSET5   ;no match
                  >49   
1D66: C8          >50            INY              
1D67: B1 00       >51            LDA   (TEMP),Y   ;check high byte
1D69: C5 82       >52            CMP   VNAME+1    
1D6B: D0 E2 =1D4F >53            BNE   :VARSET5   ;no match
                  >54   
1D6D: 18          >55   :VARSET7 CLC              ;vptr = temp + 2
1D6E: A9 02       >56            LDA   #2         
1D70: 65 00       >57            ADC   TEMP       
1D72: 85 83       >58            STA   VPTR       
1D74: AA          >59            TAX              ;return with A & X pointing at var
1D75: A9 00       >60            LDA   #0         
1D77: 65 01       >61            ADC   TEMP+1     
1D79: 85 84       >62            STA   VPTR+1     
1D7B: 60          >63            RTS              
                  >64   
1D7C: 38          >65   :VARSET8 SEC              
1D7D: A5 01       >66            LDA   TEMP+1     
1D7F: E5 6A       >67            SBC   LOMEM+1    ;find total string space
1D81: 4A          >68            LSR              
1D82: 18          >69            CLC              
1D83: 65 6A       >70            ADC   LOMEM+1    ;find boundary
1D85: 85 6E       >71            STA   MIDMEM+1   ;save high byte
1D87: A9 00       >72            LDA   #0         ;save low byte
1D89: 85 6D       >73            STA   MIDMEM     
                  >74   
1D8B: C6 01       >75            DEC   TEMP+1     
1D8D: A0 F9       >76            LDY   #$F9       ;do next entry also
1D8F: A2 0A       >77            LDX   #10        ;fill rest with 0's
1D91: A9 00       >78            LDA   #0         
1D93: C8          >79   :VARSET9 INY              
1D94: D0 02 =1D98 >80            BNE   :VARSETA   
1D96: E6 01       >81            INC   TEMP+1     
1D98: 91 00       >82   :VARSETA STA   (TEMP),Y   
1D9A: CA          >83            DEX              
1D9B: D0 F6 =1D93 >84            BNE   :VARSET9   
                  >85   
1D9D: A0 00       >86            LDY   #0         
1D9F: A5 81       >87            LDA   VNAME      
1DA1: 91 00       >88            STA   (TEMP),Y   ;save the var name
1DA3: C8          >89            INY              
1DA4: A5 82       >90            LDA   VNAME+1    
1DA6: 91 00       >91            STA   (TEMP),Y   
1DA8: 4C 6D 1D    >92            JMP   :VARSET7   ;set up pointers
                  >93   
                  >94   *-------------------------------
                  >95   * input a number or expression
                  >96   *-------------------------------
                  >97   
1DAB: A5 00       >98   INPNUM   LDA   TEMP       ;save temp var's
1DAD: 48          >99            PHA              
1DAE: A5 01       >100           LDA   TEMP+1     
1DB0: 48          >101           PHA              
1DB1: A5 02       >102           LDA   TEMP2      
1DB3: 48          >103           PHA              
1DB4: A5 03       >104           LDA   TEMP2+1    
1DB6: 48          >105           PHA              
                  >106  
1DB7: 20 0D 1E    >107           JSR   INPNUM0    ;get initial number
1DBA: 20 E4 16    >108  :INPNUM3 JSR   CHKBYT     
1DBD: 30 04 =1DC3 >109           BMI   :INPNM3A   
                  >110  
1DBF: C9 5A       >111           CMP   #compare   
1DC1: B0 0F =1DD2 >112           BGE   :INPNUM5   ;don't do compare operands
                  >113  
1DC3: 68          >114  :INPNM3A PLA              
1DC4: 85 03       >115           STA   TEMP2+1    ;restore stuff
1DC6: 68          >116           PLA              
1DC7: 85 02       >117           STA   TEMP2      
1DC9: 68          >118           PLA              
1DCA: 85 01       >119           STA   TEMP+1     
1DCC: 68          >120           PLA              
1DCD: 85 00       >121           STA   TEMP       
1DCF: 4C FF 1D    >122           JMP   GETNUMB    
                  >123  
1DD2: 20 6E 1E    >124  :INPNUM5 JSR   INPNUM2    ;exec token
1DD5: 4C BA 1D    >125           JMP   :INPNUM3   
                  >126  
                  >127  *-------------------------------
                  >128  * input a number of expression for math operations
                  >129  *-------------------------------
                  >130  
1DD8: 20 0D 1E    >131  INPMATH  JSR   INPNUM0    ;get initial number
1DDB: 20 E4 16    >132  INPMTH1  JSR   CHKBYT     
1DDE: 30 1F =1DFF >133           BMI   GETNUMB    
                  >134  
1DE0: C9 66       >135           CMP   #math      
1DE2: 90 1B =1DFF >136           BLT   GETNUMB    ;check for math operand, we're done
                  >137  
1DE4: 20 6E 1E    >138           JSR   INPNUM2    
1DE7: 4C DB 1D    >139           JMP   INPMTH1    
                  >140  
                  >141  *-------------------------------
                  >142  * input a paren
                  >143  *-------------------------------
                  >144  
1DEA: 20 CC 16    >145  INPPAR   JSR   GETBYT     ;get the byte
1DED: 20 AB 1D    >146           JSR   INPNUM     
1DF0: 20 06 1E    >147           JSR   SAVNUMB    ;save number
                  >148  
1DF3: 20 CC 16    >149           JSR   GETBYT     
1DF6: C9 A9       >150           CMP   #")"       
1DF8: F0 0B =1E05 >151           BEQ   INPPAR2    ;was close there?, yep
                  >152  
1DFA: A2 05       >153           LDX   #syntax    ;syntax error
1DFC: 4C E1 12    >154           JMP   BADERR     
                  >155  
                  >156  *-------------------------------
                  >157  * finish up here
                  >158  *-------------------------------
                  >159  
1DFF: AE 28 DF    >160  GETNUMB  LDX   NUMB       
1E02: AD 29 DF    >161           LDA   NUMB+1     
1E05: 60          >162  INPPAR2  RTS              
                  >163  
1E06: 8E 28 DF    >164  SAVNUMB  STX   NUMB       
1E09: 8D 29 DF    >165           STA   NUMB+1     
1E0C: 60          >166           RTS              
                  >167  
                  >168  *-------------------------------
                  >169  * input a number
                  >170  *-------------------------------
                  >171  
1E0D: A9 00       >172  INPNUM0  LDA   #0         ;init number
1E0F: AA          >173           TAX              
1E10: 20 06 1E    >174           JSR   SAVNUMB    
1E13: 20 E4 16    >175           JSR   CHKBYT     ;get next token
1E16: C9 08       >176           CMP   #chain     
1E18: F0 40 =1E5A >177           BEQ   :INPNM0A   ;missing data
1E1A: C9 09       >178           CMP   #chain2    
1E1C: F0 3C =1E5A >179           BEQ   :INPNM0A   
                  >180  
1E1E: C9 01       >181           CMP   #number    
1E20: F0 22 =1E44 >182           BEQ   :INPNM0    ;check if var
1E22: C9 02       >183           CMP   #string    
1E24: F0 2C =1E52 >184           BEQ   :INPNM1    
1E26: C9 A2       >185           CMP   #"""       
1E28: F0 28 =1E52 >186           BEQ   :INPNM1    
                  >187  
1E2A: C9 A8       >188           CMP   #"("       
1E2C: F0 BC =1DEA >189           BEQ   INPPAR     ;if an expression
                  >190  
1E2E: C9 50       >191           CMP   #strtyp    
1E30: 90 3C =1E6E >192           BLT   INPNUM2    ;check if other token
1E32: C9 5A       >193           CMP   #compare   
1E34: 90 1C =1E52 >194           BLT   :INPNM1    ;is it a string?
1E36: C9 00       >195           CMP   #0         
1E38: 10 34 =1E6E >196           BPL   INPNUM2    ;is it a token?
                  >197  
1E3A: 20 60 17    >198           JSR   TST_NUM    
1E3D: 90 20 =1E5F >199           BCC   :INPNUM1   
                  >200  
1E3F: A2 05       >201           LDX   #syntax    ;syntax error
1E41: 4C E1 12    >202           JMP   BADERR     
                  >203  
1E44: 20 25 1D    >204  :INPNM0  JSR   VARSET     
                  >205  
1E47: A0 00       >206           LDY   #0         ;get value of variable in X,A
1E49: B1 83       >207           LDA   (VPTR),Y   
1E4B: AA          >208           TAX              
1E4C: C8          >209           INY              
1E4D: B1 83       >210           LDA   (VPTR),Y   
1E4F: 4C 06 1E    >211           JMP   SAVNUMB    ;save it
                  >212  
1E52: 20 DC 1F    >213  :INPNM1  JSR   STRCMP     ;get value of expression
1E55: A9 00       >214           LDA   #0         ;save the number
1E57: 4C 06 1E    >215           JMP   SAVNUMB    
                  >216  
1E5A: A2 08       >217  :INPNM0A LDX   #nodata    ;missing data
1E5C: 4C E1 12    >218           JMP   BADERR     
                  >219  
1E5F: 20 C1 1A    >220  :INPNUM1 JSR   NUMIN      
1E62: 20 06 1E    >221           JSR   SAVNUMB    ;save number
1E65: C9 00       >222           CMP   #0         
1E67: 10 96 =1DFF >223           BPL   GETNUMB    
1E69: A2 06       >224           LDX   #nosymbol  
1E6B: 4C E1 12    >225           JMP   BADERR     
                  >226  
1E6E: A9 00       >227  INPNUM2  LDA   #0         
1E70: 8D 24 DF    >228           STA   DATA       ;reset data
1E73: 20 CC 16    >229           JSR   GETBYT     
1E76: 18          >230           CLC              ;call from somewhere else
1E77: 20 58 19    >231           JSR   EX_TOK     ;exec the token
1E7A: AD 24 DF    >232           LDA   DATA       
1E7D: 29 01       >233           AND   #1         ;did we get valid data?
1E7F: D0 05 =1E86 >234           BNE   INPNM2     ;yep
                  >235  
1E81: A2 09       >236  INPNM3   LDX   #badtype   ;type mismatch error
1E83: 4C E1 12    >237           JMP   BADERR     
                  >238  
1E86: AE 25 DF    >239  INPNM2   LDX   DATA+1     ;transfer data
1E89: AD 26 DF    >240           LDA   DATA+2     
1E8C: 4C 06 1E    >241           JMP   SAVNUMB    
                  >242  
                  >243  *-------------------------------
                  >244  * input a numeric argument
                  >245  *-------------------------------
                  >246  
1E8F: 20 A1 1E    >247  INPNARG  JSR   INPARG     ;do input
1E92: 29 01       >248           AND   #1         
1E94: D0 EB =1E81 >249           BNE   INPNM3     ;if string, error
1E96: 4C FF 1D    >250           JMP   GETNUMB    ;return values
                  >251  
                  >252  *-------------------------------
                  >253  * input a string argument
                  >254  *-------------------------------
                  >255  
1E99: 20 A1 1E    >256  INPSARG  JSR   INPARG     ;do input
1E9C: 29 01       >257           AND   #1         
1E9E: F0 E1 =1E81 >258           BEQ   INPNM3     ;if number, error
1EA0: 60          >259           RTS              
                  >260  
                  >261  *-------------------------------
                  >262  * input a argument
                  >263  *-------------------------------
                  >264  
1EA1: 20 CC 16    >265  INPARG   JSR   GETBYT     ;get data
1EA4: C9 A8       >266           CMP   #"("       
1EA6: F0 09 =1EB1 >267           BEQ   :INPARG2   ;check for start or continuation
1EA8: C9 AC       >268           CMP   #","       
1EAA: F0 05 =1EB1 >269           BEQ   :INPARG2   ;of an argument
                  >270  
1EAC: A2 08       >271  :INPARG1 LDX   #nodata    ;missing data
1EAE: 4C E1 12    >272           JMP   BADERR     
                  >273  
1EB1: 20 D8 1E    >274  :INPARG2 JSR   ARGTYP     ;find out type (number or string)
1EB4: 08          >275           PHP              
1EB5: B0 06 =1EBD >276           BCS   :INPARG3   
                  >277  
1EB7: 20 AB 1D    >278           JSR   INPNUM     
1EBA: 4C C0 1E    >279           JMP   :INPARG4   
                  >280  
1EBD: 20 07 1F    >281  :INPARG3 JSR   INPSTR     
1EC0: 20 E4 16    >282  :INPARG4 JSR   CHKBYT     ;check next byte
1EC3: A2 01       >283           LDX   #1         
1EC5: C9 AC       >284           CMP   #","       
1EC7: F0 09 =1ED2 >285           BEQ   :INPARG5   ;is there more?, yep
                  >286  
1EC9: 20 CC 16    >287           JSR   GETBYT     ;get the rest
1ECC: A2 00       >288           LDX   #0         
1ECE: C9 A9       >289           CMP   #")"       
1ED0: D0 DA =1EAC >290           BNE   :INPARG1   ;of arg, nope, error
                  >291  
1ED2: 8A          >292  :INPARG5 TXA              ;bit 0 : clear = number  set = string
1ED3: 28          >293           PLP              ;bit 1 : clear = done    set = more args
1ED4: 2A          >294           ROL              
1ED5: C9 00       >295           CMP   #0         
1ED7: 60          >296           RTS              
                  >297  
                  >298  *-------------------------------
                  >299  * find out type of data/token
                  >300  *-------------------------------
                  >301  
1ED8: 20 E4 16    >302  ARGTYP   JSR   CHKBYT     
1EDB: C9 A2       >303           CMP   #"""       
1EDD: F0 14 =1EF3 >304           BEQ   :ARGTYP1   ;if it's text
                  >305  
1EDF: C9 A8       >306           CMP   #"("       
1EE1: F0 12 =1EF5 >307           BEQ   :ARGTYP2   ;if it's an expression
                  >308  
1EE3: C9 00       >309           CMP   #0         
1EE5: 30 0E =1EF5 >310           BMI   :ARGTYP2   ;if it's other than text
                  >311  
1EE7: C9 02       >312           CMP   #string    
1EE9: F0 08 =1EF3 >313           BEQ   :ARGTYP1   ;if it's a string var
                  >314  
1EEB: C9 50       >315           CMP   #strtyp    
1EED: 90 06 =1EF5 >316           BLT   :ARGTYP2   ;if it's a string, set the carry
                  >317  
1EEF: C9 5A       >318           CMP   #compare   
1EF1: B0 02 =1EF5 >319           BGE   :ARGTYP2   ;make sure it's in range
                  >320  
1EF3: 38          >321  :ARGTYP1 SEC              ;it's a string
1EF4: 60          >322           RTS              
                  >323  
1EF5: 18          >324  :ARGTYP2 CLC              ;it's a number
1EF6: 60          >325           RTS              
                  >326  
                  >327  *-------------------------------
                  >328  * input a string without allocating memory
                  >329  *-------------------------------
                  >330  
1EF7: A5 08       >331  INSTR2   LDA   VARSTR     
1EF9: 48          >332           PHA              
1EFA: A5 09       >333           LDA   VARSTR+1   
1EFC: 48          >334           PHA              
1EFD: 20 07 1F    >335           JSR   INPSTR     
1F00: 68          >336           PLA              
1F01: 85 09       >337           STA   VARSTR+1   
1F03: 68          >338           PLA              
1F04: 85 08       >339           STA   VARSTR     
1F06: 60          >340           RTS              
                  >341  
                  >342  *-------------------------------
                  >343  * input a string
                  >344  *-------------------------------
                  >345  
1F07: 20 60 1F    >346  INPSTR   JSR   INPSTR0    
1F0A: 85 0E       >347           STA   STRLOC+1   ;save length and location
1F0C: 86 0D       >348           STX   STRLOC     
1F0E: 84 0F       >349           STY   STRLEN     
                  >350  
1F10: 20 E4 16    >351           JSR   CHKBYT     
1F13: C9 66       >352           CMP   #math      
1F15: D0 42 =1F59 >353           BNE   GTSTRINF   ;a quick exit point
                  >354  
1F17: A5 09       >355           LDA   VARSTR+1   ;save the new pointer
1F19: 48          >356           PHA              
1F1A: A5 08       >357           LDA   VARSTR     
1F1C: 48          >358           PHA              
1F1D: 98          >359           TYA              
1F1E: 48          >360           PHA              
                  >361  
1F1F: 20 CC 16    >362           JSR   GETBYT     ;save start of working string space
1F22: 20 B9 1F    >363           JSR   STRCOPY    
                  >364  
1F25: A5 09       >365  :INPSTRB LDA   VARSTR+1   ;save current pointer
1F27: 48          >366           PHA              
1F28: A5 08       >367           LDA   VARSTR     
1F2A: 48          >368           PHA              
                  >369  
1F2B: 20 60 1F    >370           JSR   INPSTR0    ;get new string
1F2E: 85 0E       >371           STA   STRLOC+1   ;save length and location
1F30: 86 0D       >372           STX   STRLOC     
1F32: 84 0F       >373           STY   STRLEN     
                  >374  
1F34: 68          >375           PLA              
1F35: 85 08       >376           STA   VARSTR     ;restore var pointers
1F37: 68          >377           PLA              
1F38: 85 09       >378           STA   VARSTR+1   
1F3A: 68          >379           PLA              
1F3B: 85 10       >380           STA   TTLLEN     ;update length
1F3D: 20 B9 1F    >381           JSR   STRCOPY    ;copy the new string
1F40: A5 10       >382           LDA   TTLLEN     
1F42: 48          >383           PHA              
                  >384  
1F43: 20 E4 16    >385           JSR   CHKBYT     
1F46: C9 66       >386           CMP   #math      
1F48: D0 06 =1F50 >387           BNE   :INPSTRC   ;if there more, do it
                  >388  
1F4A: 20 CC 16    >389           JSR   GETBYT     ;gobble and continue
1F4D: 4C 25 1F    >390           JMP   :INPSTRB   
                  >391  
1F50: 68          >392  :INPSTRC PLA              
1F51: 85 0F       >393           STA   STRLEN     ;put back data
1F53: 68          >394           PLA              
1F54: 85 0D       >395           STA   STRLOC     
1F56: 68          >396           PLA              
1F57: 85 0E       >397           STA   STRLOC+1   
                  >398  
1F59: A5 0E       >399  GTSTRINF LDA   STRLOC+1   ;get back stuff
1F5B: A6 0D       >400           LDX   STRLOC     
1F5D: A4 0F       >401           LDY   STRLEN     
1F5F: 60          >402           RTS              
                  >403  
                  >404  *-------------------------------
                  >405  * actually get the string
                  >406  *-------------------------------
                  >407  
1F60: 20 E4 16    >408  INPSTR0  JSR   CHKBYT     
1F63: C9 A2       >409           CMP   #"""       
1F65: F0 17 =1F7E >410           BEQ   :INPSTR1   ;if text
                  >411  
1F67: C9 02       >412           CMP   #string    
1F69: D0 2F =1F9A >413           BNE   :INPSTR5   ;handle token
                  >414  
1F6B: 20 25 1D    >415           JSR   VARSET     ;point to var
1F6E: A0 01       >416           LDY   #1         
1F70: B1 83       >417           LDA   (VPTR),Y   ;get the high-byte of pointer
1F72: 48          >418           PHA              
1F73: 88          >419           DEY              
1F74: B1 83       >420           LDA   (VPTR),Y   ;get the low-byte of pointer
1F76: AA          >421           TAX              
1F77: A0 02       >422           LDY   #2         
1F79: B1 83       >423           LDA   (VPTR),Y   ;get the length
1F7B: A8          >424           TAY              
1F7C: 68          >425           PLA              
1F7D: 60          >426           RTS              
                  >427  
1F7E: 20 CC 16    >428  :INPSTR1 JSR   GETBYT     ;and gobble first quote
1F81: A6 04       >429           LDX   PRGPTR     ;save string location
1F83: A5 05       >430           LDA   PRGPTR+1   
1F85: 48          >431           PHA              
1F86: A0 00       >432           LDY   #0         
1F88: 20 CC 16    >433  :INPSTR2 JSR   GETBYT     ;calc string length
1F8B: C9 A2       >434           CMP   #"""       
1F8D: F0 09 =1F98 >435           BEQ   :INPSTR4   ;check for end
                  >436  
1F8F: C8          >437           INY              
1F90: D0 F6 =1F88 >438           BNE   :INPSTR2   
                  >439  
1F92: 68          >440           PLA              
1F93: A2 0C       >441           LDX   #str2big   ;string overflow
1F95: 4C E1 12    >442  :INPSTR3 JMP   BADERR     
                  >443  
1F98: 68          >444  :INPSTR4 PLA              ;a,x,y now have string data
1F99: 60          >445           RTS              
                  >446  
1F9A: A9 00       >447  :INPSTR5 LDA   #0         
1F9C: 8D 24 DF    >448           STA   DATA       ;reset data type
1F9F: 20 CC 16    >449           JSR   GETBYT     
1FA2: 18          >450           CLC              ;called from somewhere else
1FA3: 20 58 19    >451           JSR   EX_TOK     ;exec token
1FA6: AD 24 DF    >452           LDA   DATA       
1FA9: A2 09       >453           LDX   #badtype   
1FAB: 29 02       >454           AND   #2         
1FAD: F0 E6 =1F95 >455           BEQ   :INPSTR3   ;string overflow
                  >456  
1FAF: AE 25 DF    >457           LDX   DATA+1     ;get data
1FB2: AD 26 DF    >458           LDA   DATA+2     
1FB5: AC 27 DF    >459           LDY   DATA+3     
1FB8: 60          >460           RTS              
                  >461  
                  >462  *-------------------------------
                  >463  * copy a string from pointers to current varstr
                  >464  *-------------------------------
                  >465  
1FB9: A0 00       >466  STRCOPY  LDY   #0         
1FBB: C4 0F       >467  :STRCOP2 CPY   STRLEN     
1FBD: F0 0B =1FCA >468           BEQ   :STRCOP3   ;go until done
                  >469  
1FBF: B1 0D       >470           LDA   (STRLOC),Y 
1FC1: 91 08       >471           STA   (VARSTR),Y ;copy byte
1FC3: E6 10       >472           INC   TTLLEN     ;increase total length
1FC5: F0 10 =1FD7 >473           BEQ   :STR2BIG   ;now it's too big
1FC7: C8          >474           INY              
1FC8: D0 F1 =1FBB >475           BNE   :STRCOP2   
                  >476  
1FCA: 98          >477  :STRCOP3 TYA              ;add in bytes copied
1FCB: 18          >478           CLC              
1FCC: 65 08       >479           ADC   VARSTR     
1FCE: 85 08       >480           STA   VARSTR     
1FD0: A9 00       >481           LDA   #0         
1FD2: 65 09       >482           ADC   VARSTR+1   
1FD4: 85 09       >483           STA   VARSTR+1   
1FD6: 60          >484           RTS              
                  >485  
1FD7: A2 0C       >486  :STR2BIG LDX   #str2big   ;String too long
1FD9: 4C E1 12    >487           JMP   BADERR     
                  >488  
                  >489  *-------------------------------
                  >490  * compare 2 strings
                  >491  *-------------------------------
                  >492  
1FDC: A5 08       >493  STRCMP   LDA   VARSTR     ;don't gobble any space
1FDE: 48          >494           PHA              
1FDF: A5 09       >495           LDA   VARSTR+1   
1FE1: 48          >496           PHA              
                  >497  
1FE2: 20 07 1F    >498           JSR   INPSTR     ;get string 1
1FE5: A5 0D       >499           LDA   STRLOC     ;save pointers to data
1FE7: 85 13       >500           STA   TEMP3      
1FE9: A5 0E       >501           LDA   STRLOC+1   
1FEB: 85 14       >502           STA   TEMP3+1    
1FED: A5 0F       >503           LDA   STRLEN     
1FEF: 85 02       >504           STA   TEMP2      ;save length of data
                  >505  
1FF1: 20 E4 16    >506           JSR   CHKBYT     
1FF4: C9 5A       >507           CMP   #compare   
1FF6: 90 1E =2016 >508           BLT   :STRCMP8   ;see if there is actually a compare
                  >509  
1FF8: C9 63       >510           CMP   #logic     
1FFA: B0 1A =2016 >511           BGE   :STRCMP8   
                  >512  
1FFC: 20 CC 16    >513           JSR   GETBYT     ;gobble token
1FFF: 38          >514           SEC              
2000: E9 5A       >515           SBC   #compare   
2002: 0A          >516           ASL              
2003: 48          >517           PHA              
2004: 20 07 1F    >518           JSR   INPSTR     ;get second string
2007: 68          >519           PLA              
2008: AA          >520           TAX              
                  >521  
2009: BD F5 DC    >522           LDA   JSTRCP,X   
200C: 85 00       >523           STA   TEMP       
200E: BD F6 DC    >524           LDA   JSTRCP+1,X 
2011: 85 01       >525           STA   TEMP+1     
2013: 6C 00 00    >526           JMP   (TEMP)     
                  >527  
2016: A2 00       >528  :STRCMP8 LDX   #0         ;if length = 0, not valid
2018: A5 02       >529           LDA   TEMP2      ;if length > 0, return valid
201A: F0 02 =201E >530           BEQ   STRCMP9    
                  >531  
201C: A2 01       >532           LDX   #1         
201E: 68          >533  STRCMP9  PLA              
201F: 85 09       >534           STA   VARSTR+1   ;restore stuff
2021: 68          >535           PLA              
2022: 85 08       >536           STA   VARSTR     
2024: A9 00       >537           LDA   #0         
2026: 60          >538           RTS              
                  >539  
2027: 20 54 20    >540  ST_EQ    JSR   STREQ      
202A: 4C 1E 20    >541           JMP   STRCMP9    
                  >542  
202D: 20 54 20    >543  ST_NOT   JSR   STREQ      
2030: 20 B3 23    >544           JSR   INVERT     
2033: 4C 1E 20    >545           JMP   STRCMP9    
                  >546  
2036: 20 6D 20    >547  ST_LT    JSR   STRLT      
2039: 4C 1E 20    >548           JMP   STRCMP9    
                  >549  
203C: 20 94 20    >550  ST_GT    JSR   STRGT      
203F: 4C 1E 20    >551           JMP   STRCMP9    
                  >552  
2042: 20 94 20    >553  ST_LTEQ  JSR   STRGT      
2045: 20 B3 23    >554           JSR   INVERT     
2048: 4C 1E 20    >555           JMP   STRCMP9    
                  >556  
204B: 20 6D 20    >557  ST_GTEQ  JSR   STRLT      
204E: 20 B3 23    >558           JSR   INVERT     
2051: 4C 1E 20    >559           JMP   STRCMP9    
                  >560  
                  >561  *-------------------------------
                  >562  * ----- compare algorithms -----
                  >563  *-------------------------------
                  >564  
2054: A6 02       >565  STREQ    LDX   TEMP2      ;check string length's
2056: E4 0F       >566           CPX   STRLEN     
2058: D0 0D =2067 >567           BNE   :STREQ0    
                  >568  
205A: A0 FF       >569           LDY   #-1        
205C: C8          >570  :STREQ2  INY              
205D: C4 0F       >571           CPY   STRLEN     
205F: F0 09 =206A >572           BEQ   :STREQ1    ;are we done?, yep
                  >573  
2061: B1 13       >574           LDA   (TEMP3),Y  
2063: D1 0D       >575           CMP   (STRLOC),Y 
2065: F0 F5 =205C >576           BEQ   :STREQ2    ;do check, keep going
                  >577  
2067: A2 00       >578  :STREQ0  LDX   #0         
2069: 60          >579           RTS              
                  >580  
206A: A2 01       >581  :STREQ1  LDX   #1         
206C: 60          >582           RTS              
                  >583  
206D: A6 02       >584  STRLT    LDX   TEMP2      ;save smaller length
206F: E4 0F       >585           CPX   STRLEN     
2071: B0 04 =2077 >586           BGE   :STRLT2    
                  >587  
2073: A6 0F       >588           LDX   STRLEN     
2075: 86 02       >589           STX   TEMP2      
                  >590  
2077: A0 FF       >591  :STRLT2  LDY   #-1        
2079: C8          >592  :STRLT3  INY              
207A: C4 02       >593           CPY   TEMP2      
207C: F0 13 =2091 >594           BEQ   :STRLT0    
                  >595  
207E: B1 13       >596           LDA   (TEMP3),Y  
2080: D1 0D       >597           CMP   (STRLOC),Y 
2082: F0 F5 =2079 >598           BEQ   :STRLT3    
2084: 90 08 =208E >599           BLT   :STRLT1    
2086: B0 09 =2091 >600           BGE   :STRLT0    
                  >601  
2088: A5 02       >602           LDA   TEMP2      
208A: C5 0F       >603           CMP   STRLEN     
208C: B0 03 =2091 >604           BCS   :STRLT0    
                  >605  
208E: A2 01       >606  :STRLT1  LDX   #1         
2090: 60          >607           RTS              
                  >608  
2091: A2 00       >609  :STRLT0  LDX   #0         
2093: 60          >610           RTS              
                  >611  
2094: A6 0F       >612  STRGT    LDX   STRLEN     ;save smaller length
2096: E4 02       >613           CPX   TEMP2      
2098: B0 04 =209E >614           BGE   :STRGT2    
                  >615  
209A: A6 02       >616           LDX   TEMP2      
209C: 86 0F       >617           STX   STRLEN     
                  >618  
209E: A0 FF       >619  :STRGT2  LDY   #-1        
20A0: C8          >620  :STRGT3  INY              
20A1: C4 0F       >621           CPY   STRLEN     
20A3: F0 13 =20B8 >622           BEQ   :STRGT0    
                  >623  
20A5: B1 0D       >624           LDA   (STRLOC),Y 
20A7: D1 13       >625           CMP   (TEMP3),Y  
20A9: F0 F5 =20A0 >626           BEQ   :STRGT3    
20AB: 90 08 =20B5 >627           BLT   :STRGT1    
20AD: B0 09 =20B8 >628           BGE   :STRGT0    
                  >629  
20AF: A5 0F       >630           LDA   STRLEN     
20B1: C5 02       >631           CMP   TEMP2      
20B3: B0 03 =20B8 >632           BCS   :STRGT0    
                  >633  
20B5: A2 01       >634  :STRGT1  LDX   #1         
20B7: 60          >635           RTS              
                  >636  
20B8: A2 00       >637  :STRGT0  LDX   #0         
20BA: 60          >638  STRRTS   RTS              
                  >639  
                  >640  *-------------------------------
                  >641  * check and see if we need to clear up
                  >642  *-------------------------------
                  >643  
20BB: A6 09       >644  CHKFRE   LDX   VARSTR+1   ;get high of current pointer
20BD: E8          >645           INX              
20BE: E4 6E       >646           CPX   MIDMEM+1   
20C0: 90 F8 =20BA >647           BLT   STRRTS     ;are we ok?, all is well
                  >648  
                  >649  *-------------------------------
                  >650  * clean up strings in memory
                  >651  *-------------------------------
                  >652  
20C2: A5 73       >653  DO_FRE   LDA   HIMEM      ;point to pointers
20C4: 85 00       >654           STA   TEMP       
20C6: A5 74       >655           LDA   HIMEM+1    
20C8: 85 01       >656           STA   TEMP+1     
                  >657  
20CA: A5 6D       >658           LDA   MIDMEM     ;point to working space
20CC: 85 13       >659           STA   TEMP3      
20CE: A5 6E       >660           LDA   MIDMEM+1   
20D0: 85 14       >661           STA   TEMP3+1    
                  >662  
20D2: 38          >663           SEC              
20D3: A5 6D       >664           LDA   MIDMEM     
20D5: E5 69       >665           SBC   LOMEM      
20D7: 85 02       >666           STA   TEMP2      ;compute offset
20D9: A5 6E       >667           LDA   MIDMEM+1   
20DB: E5 6A       >668           SBC   LOMEM+1    
20DD: 85 03       >669           STA   TEMP2+1    
                  >670  
20DF: A9 01       >671           LDA   #1         
20E1: 8D 2B DF    >672           STA   FREMEM     ;move minimum of 1 page
                  >673  
20E4: 38          >674  :FRE2    SEC              
20E5: A5 00       >675           LDA   TEMP       
20E7: E9 06       >676           SBC   #6         
20E9: 85 00       >677           STA   TEMP       ;move pointers
20EB: A5 01       >678           LDA   TEMP+1     
20ED: E9 00       >679           SBC   #0         
20EF: 85 01       >680           STA   TEMP+1     
                  >681  
20F1: A0 00       >682           LDY   #0         
20F3: B1 00       >683           LDA   (TEMP),Y   
20F5: F0 45 =213C >684           BEQ   :FRE4      ;we are done
20F7: 10 EB =20E4 >685           BPL   :FRE2      ;don't do numbers
                  >686  
20F9: A0 02       >687           LDY   #2         
20FB: B1 00       >688           LDA   (TEMP),Y   
20FD: 85 83       >689           STA   VPTR       ;point to string
20FF: C8          >690           INY              
2100: B1 00       >691           LDA   (TEMP),Y   
2102: 85 84       >692           STA   VPTR+1     
2104: F0 DE =20E4 >693           BEQ   :FRE2      ;new string
                  >694  
2106: C9 51       >695           CMP   #>CODEND   
2108: 90 DA =20E4 >696           BLT   :FRE2      ;if protected string, don't move it
                  >697  
210A: C8          >698           INY              
210B: B1 00       >699           LDA   (TEMP),Y   
210D: AA          >700           TAX              
210E: F0 D4 =20E4 >701           BEQ   :FRE2      ;if empty...
                  >702  
2110: A0 02       >703           LDY   #2         ;put in new pointer
                  >704  
2112: 38          >705           SEC              
2113: A5 13       >706           LDA   TEMP3      
2115: E5 02       >707           SBC   TEMP2      
2117: 91 00       >708           STA   (TEMP),Y   
2119: C8          >709           INY              
211A: A5 14       >710           LDA   TEMP3+1    
211C: E5 03       >711           SBC   TEMP2+1    
211E: 91 00       >712           STA   (TEMP),Y   
                  >713  
2120: A0 00       >714           LDY   #0         
2122: B1 83       >715  :FRE3    LDA   (VPTR),Y   
2124: 91 13       >716           STA   (TEMP3),Y  
2126: C8          >717           INY              
2127: CA          >718           DEX              
2128: D0 F8 =2122 >719           BNE   :FRE3      
                  >720  
212A: 18          >721           CLC              
212B: 98          >722           TYA              
212C: 65 13       >723           ADC   TEMP3      ;move up pointer
212E: 85 13       >724           STA   TEMP3      
2130: A5 14       >725           LDA   TEMP3+1    
2132: 90 B0 =20E4 >726           BCC   :FRE2      ;keep looping
                  >727  
2134: E6 14       >728           INC   TEMP3+1    
2136: EE 2B DF    >729           INC   FREMEM     
2139: 4C E4 20    >730           JMP   :FRE2      ;keep going
                  >731  
213C: 38          >732  :FRE4    SEC              
213D: A5 13       >733           LDA   TEMP3      
213F: E5 02       >734           SBC   TEMP2      
2141: 85 08       >735           STA   VARSTR     ;compute new varstr
2143: A5 14       >736           LDA   TEMP3+1    
2145: E5 03       >737           SBC   TEMP2+1    
2147: 85 09       >738           STA   VARSTR+1   
                  >739  
2149: A5 69       >740           LDA   LOMEM      ;point at string space
214B: 85 00       >741           STA   TEMP       
214D: A5 6A       >742           LDA   LOMEM+1    
214F: 85 01       >743           STA   TEMP+1     
                  >744  
2151: A5 6D       >745           LDA   MIDMEM     ;point at fixed strings
2153: 85 02       >746           STA   TEMP2      
2155: A5 6E       >747           LDA   MIDMEM+1   
2157: 85 03       >748           STA   TEMP2+1    
                  >749  
2159: AE 2B DF    >750           LDX   FREMEM     ;number of pages to move
215C: A0 00       >751           LDY   #0         
215E: B1 02       >752  :FRE5    LDA   (TEMP2),Y  
2160: 91 00       >753           STA   (TEMP),Y   
2162: C8          >754           INY              
2163: D0 F9 =215E >755           BNE   :FRE5      
                  >756  
2165: E6 01       >757           INC   TEMP+1     
2167: E6 03       >758           INC   TEMP2+1    
2169: CA          >759           DEX              
216A: D0 F2 =215E >760           BNE   :FRE5      ;do the move
216C: 60          >761           RTS              
                   35            PUT   MATH       
                  >2    ********************************
                  >3    *                              *
                  >4    *       ACOS.OBJ - Math        *
                  >5    *                              *
                  >6    ********************************
                                  3-MAR-23   9:23:10 AM
                  >8    *-------------------------------
                  >9    
216D: AD 29 DF    >10   DO_PLUS  LDA   NUMB+1     ;save old number
2170: 48          >11            PHA              
2171: AD 28 DF    >12            LDA   NUMB       
2174: 48          >13            PHA              
2175: 20 D8 1D    >14            JSR   INPMATH    ;get next part
2178: 18          >15            CLC              
2179: 68          >16            PLA              
217A: 6D 28 DF    >17            ADC   NUMB       ;do add
217D: AA          >18            TAX              
217E: 68          >19            PLA              
217F: 6D 29 DF    >20            ADC   NUMB+1     
2182: 4C 9A 21    >21            JMP   DO_MATH    ;finish up
                  >22   
2185: AD 29 DF    >23   DO_SUB   LDA   NUMB+1     ;save initial value
2188: 48          >24            PHA              
2189: AD 28 DF    >25            LDA   NUMB       
218C: 48          >26            PHA              
218D: 20 D8 1D    >27            JSR   INPMATH    ;get other amount
2190: 38          >28            SEC              
2191: 68          >29            PLA              
2192: ED 28 DF    >30            SBC   NUMB       ;do actual subtraction
2195: AA          >31            TAX              
2196: 68          >32            PLA              
2197: ED 29 DF    >33            SBC   NUMB+1     
                  >34   
219A: 8E 25 DF    >35   DO_MATH  STX   DATA+1     ;save result
219D: 8D 26 DF    >36            STA   DATA+2     
21A0: A0 01       >37            LDY   #1         
21A2: 8C 24 DF    >38            STY   DATA       ;set data type 1
21A5: 60          >39            RTS              
                  >40   
                  >41   *-------------------------------
                  >42   * do multiply
                  >43   *-------------------------------
                  >44   
21A6: 20 C4 21    >45   DO_MULT  JSR   DO_MLDV    ;command mult/divd
21A9: 20 E9 21    >46            JSR   DO_MUL0    ;do multiply
                  >47   
                  >48   *-------------------------------
                  >49   * finish up routine for signed operands
                  >50   *-------------------------------
                  >51   
21AC: AE 3F DF    >52   DO_MLD2  LDX   RESULT     
21AF: AD 40 DF    >53            LDA   RESULT+1   
21B2: 10 05 =21B9 >54            BPL   :DO_MLD3   
                  >55   
21B4: A2 0A       >56            LDX   #num2big   
21B6: 4C E1 12    >57            JMP   BADERR     ;overflow > 32767
                  >58   
21B9: 2C 3E DF    >59   :DO_MLD3 BIT   SIGN       
21BC: 10 DC =219A >60            BPL   DO_MATH    
                  >61   
21BE: 20 A5 22    >62            JSR   NEGXA      
21C1: 4C 9A 21    >63            JMP   DO_MATH    
                  >64   
21C4: 20 FF 1D    >65   DO_MLDV  JSR   GETNUMB    ;get first number
21C7: 8D 3E DF    >66            STA   SIGN       ;save this sign
21CA: 20 A1 22    >67            JSR   DO_ABS1    ;make it positive
21CD: 8E 25 DF    >68            STX   DATA+1     ;save it
21D0: 8D 26 DF    >69            STA   DATA+2     
                  >70   
21D3: 20 0D 1E    >71            JSR   INPNUM0    ;get next number
21D6: 4D 3E DF    >72            EOR   SIGN       ;make into result sign
21D9: 8D 3E DF    >73            STA   SIGN       
21DC: AD 29 DF    >74            LDA   NUMB+1     ;get this sign
21DF: 20 A1 22    >75            JSR   DO_ABS1    ;make this positive too
21E2: 8E 28 DF    >76            STX   NUMB       ;save it
21E5: 8D 29 DF    >77            STA   NUMB+1     
21E8: 60          >78            RTS              
                  >79   
                  >80   *-------------------------------
                  >81   * actual multiply routine
                  >82   *-------------------------------
                  >83   
21E9: A9 00       >84   DO_MUL0  LDA   #0         
21EB: 8D 3F DF    >85            STA   RESULT     
21EE: 8D 40 DF    >86            STA   RESULT+1   
21F1: 8D 41 DF    >87            STA   RESULT+2   
21F4: 8D 27 DF    >88            STA   DATA+3     
21F7: A2 10       >89            LDX   #16        
21F9: 4E 29 DF    >90   :DO_MUL1 LSR   NUMB+1     
21FC: 6E 28 DF    >91            ROR   NUMB       ;put bit 0 into carry
21FF: 90 1C =221D >92            BCC   :DO_MUL2   
                  >93   
2201: 18          >94            CLC              
2202: AD 25 DF    >95            LDA   DATA+1     
2205: 6D 3F DF    >96            ADC   RESULT     
2208: 8D 3F DF    >97            STA   RESULT     ;add in multiplyer
                  >98   
220B: AD 26 DF    >99            LDA   DATA+2     
220E: 6D 40 DF    >100           ADC   RESULT+1   
2211: 8D 40 DF    >101           STA   RESULT+1   ;add in multiplyer
                  >102  
2214: AD 27 DF    >103           LDA   DATA+3     
2217: 6D 41 DF    >104           ADC   RESULT+2   
221A: 8D 41 DF    >105           STA   RESULT+2   
                  >106  
221D: 0E 25 DF    >107  :DO_MUL2 ASL   DATA+1     ;multiply all 16 bits
2220: 2E 26 DF    >108           ROL   DATA+2     
2223: 2E 27 DF    >109           ROL   DATA+3     
2226: CA          >110           DEX              
2227: D0 D0 =21F9 >111           BNE   :DO_MUL1   
2229: 60          >112           RTS              
                  >113  
                  >114  *-------------------------------
                  >115  * divide routine
                  >116  *-------------------------------
                  >117  
222A: 20 42 22    >118  DO_DIVD  JSR   DO_DIV1    ;do divide
222D: 4C AC 21    >119           JMP   DO_MLD2    
                  >120  
2230: 20 42 22    >121  DO_MOD   JSR   DO_DIV1    ;do divide
2233: AD 3C DF    >122           LDA   REMAIN     ;get remainder
2236: 8D 3F DF    >123           STA   RESULT     
2239: AD 3D DF    >124           LDA   REMAIN+1   
223C: 8D 40 DF    >125           STA   RESULT+1   
223F: 4C AC 21    >126           JMP   DO_MLD2    ;finish up
                  >127  
2242: 20 C4 21    >128  DO_DIV1  JSR   DO_MLDV    
2245: AD 28 DF    >129           LDA   NUMB       
2248: 0D 29 DF    >130           ORA   NUMB+1     
224B: F0 43 =2290 >131           BEQ   :DO_DIV5   
                  >132  
224D: A9 00       >133           LDA   #0         
224F: 8D 3C DF    >134           STA   REMAIN     ;clear remainder
2252: 8D 3D DF    >135           STA   REMAIN+1   
2255: 18          >136           CLC              
                  >137  
2256: A2 10       >138           LDX   #16        
2258: 2E 25 DF    >139  :DO_DIV2 ROL   DATA+1     ;shift up the carry bit
225B: 2E 26 DF    >140           ROL   DATA+2     
225E: 2E 3C DF    >141           ROL   REMAIN     
2261: 2E 3D DF    >142           ROL   REMAIN+1   
                  >143  
2264: 38          >144           SEC              
2265: AD 3C DF    >145           LDA   REMAIN     ;check for remainder > divisor
2268: ED 28 DF    >146           SBC   NUMB       
226B: A8          >147           TAY              
226C: AD 3D DF    >148           LDA   REMAIN+1   
226F: ED 29 DF    >149           SBC   NUMB+1     
2272: 90 06 =227A >150           BCC   :DO_DIV3   ;nope, skip subtract
                  >151  
2274: 8C 3C DF    >152           STY   REMAIN     ;allow subtract to take place
2277: 8D 3D DF    >153           STA   REMAIN+1   
                  >154  
227A: CA          >155  :DO_DIV3 DEX              
227B: D0 DB =2258 >156           BNE   :DO_DIV2   
                  >157  
227D: 2E 25 DF    >158           ROL   DATA+1     ;shift in quotent
2280: 2E 26 DF    >159           ROL   DATA+2     
                  >160  
2283: AD 25 DF    >161           LDA   DATA+1     
2286: 8D 3F DF    >162           STA   RESULT     
2289: AD 26 DF    >163           LDA   DATA+2     
228C: 8D 40 DF    >164           STA   RESULT+1   
228F: 60          >165           RTS              
                  >166  
2290: A2 0B       >167  :DO_DIV5 LDX   #divby0    ;division by zero
2292: 4C E1 12    >168           JMP   BADERR     
                  >169  
                  >170  *-------------------------------
                  >171  * absolute value
                  >172  *-------------------------------
                  >173  
2295: 20 A1 1E    >174  DO_ABS   JSR   INPARG     
2298: 20 FF 1D    >175           JSR   GETNUMB    ;get number
229B: 20 A1 22    >176           JSR   DO_ABS1    ;get abs
229E: 4C 9A 21    >177           JMP   DO_MATH    ;finish up
                  >178  
22A1: C9 00       >179  DO_ABS1  CMP   #0         
22A3: 10 0E =22B3 >180           BPL   DO_ABS2    ;if it is already ok
                  >181  
22A5: 48          >182  NEGXA    PHA              
22A6: 8A          >183           TXA              
22A7: 49 FF       >184           EOR   #-1        
22A9: AA          >185           TAX              ;make positive
22AA: 68          >186           PLA              
22AB: 49 FF       >187           EOR   #-1        
                  >188  
22AD: E8          >189           INX              
22AE: D0 03 =22B3 >190           BNE   DO_ABS2    ;and add 1
                  >191  
22B0: 18          >192           CLC              
22B1: 69 01       >193           ADC   #1         
22B3: 60          >194  DO_ABS2  RTS              
                  >195  
                  >196  *-------------------------------
                  >197  * ----- compare routines -------
                  >198  *-------------------------------
                  >199  
22B4: 20 38 23    >200  CP_EQ    JSR   CP_ST      ;compare for equal
22B7: 20 69 23    >201           JSR   CMPEQ      
22BA: 4C 5D 23    >202           JMP   CP_END     
                  >203  
22BD: 20 38 23    >204  CP_NOT   JSR   CP_ST      ;compare if not equal
22C0: 20 69 23    >205           JSR   CMPEQ      ;just inverse compare equal
22C3: 20 B3 23    >206           JSR   INVERT     
22C6: 4C 5D 23    >207           JMP   CP_END     
                  >208  
22C9: 20 38 23    >209  CP_LT    JSR   CP_ST      ;compare if less than
22CC: 20 4C 23    >210           JSR   CP_LTGT    
22CF: 20 7F 23    >211           JSR   CMPLT      
22D2: 4C 5D 23    >212           JMP   CP_END     
                  >213  
22D5: 20 38 23    >214  CP_GT    JSR   CP_ST      ;compare if greater than
22D8: 20 4C 23    >215           JSR   CP_LTGT    
22DB: 20 99 23    >216           JSR   CMPGT      
22DE: 4C 5D 23    >217           JMP   CP_END     
                  >218  
22E1: 20 38 23    >219  CP_LTEQ  JSR   CP_ST      ;compare if less than or equal
22E4: 20 4C 23    >220           JSR   CP_LTGT    
22E7: 20 99 23    >221           JSR   CMPGT      ;just inverse compare greater than
22EA: 20 B3 23    >222           JSR   INVERT     
22ED: 4C 5D 23    >223           JMP   CP_END     
                  >224  
22F0: 20 38 23    >225  CP_GTEQ  JSR   CP_ST      ;compare if greater than or equal
22F3: 20 4C 23    >226           JSR   CP_LTGT    
22F6: 20 7F 23    >227           JSR   CMPLT      ;just inverse compare less than
22F9: 20 B3 23    >228           JSR   INVERT     
22FC: 4C 5D 23    >229           JMP   CP_END     
                  >230  
22FF: 20 38 23    >231  CP_AND   JSR   CP_ST      ;'and' 2 numbers
2302: AD 28 DF    >232           LDA   NUMB       
2305: 2D 25 DF    >233           AND   DATA+1     
2308: AA          >234           TAX              
2309: AD 29 DF    >235           LDA   NUMB+1     
230C: 2D 26 DF    >236           AND   DATA+2     
230F: 4C 5D 23    >237           JMP   CP_END     
                  >238  
2312: 20 38 23    >239  CP_OR    JSR   CP_ST      ;'or' 2 numbers
2315: AD 28 DF    >240           LDA   NUMB       
2318: 0D 25 DF    >241           ORA   DATA+1     
231B: AA          >242           TAX              
231C: AD 29 DF    >243           LDA   NUMB+1     
231F: 0D 26 DF    >244           ORA   DATA+2     
2322: 4C 5D 23    >245           JMP   CP_END     
                  >246  
2325: 20 38 23    >247  CP_EOR   JSR   CP_ST      ;'eor' 2 numbers
2328: AD 28 DF    >248           LDA   NUMB       
232B: 4D 25 DF    >249           EOR   DATA+1     
232E: AA          >250           TAX              
232F: AD 29 DF    >251           LDA   NUMB+1     
2332: 4D 26 DF    >252           EOR   DATA+2     
2335: 4C 5D 23    >253           JMP   CP_END     
                  >254  
2338: AD 28 DF    >255  CP_ST    LDA   NUMB       ;compare start
233B: 48          >256           PHA              
233C: AD 29 DF    >257           LDA   NUMB+1     ;just save stuff
233F: 48          >258           PHA              
2340: 20 D8 1D    >259           JSR   INPMATH    
2343: 68          >260           PLA              
2344: 8D 26 DF    >261           STA   DATA+2     
2347: 68          >262           PLA              
2348: 8D 25 DF    >263           STA   DATA+1     
234B: 60          >264           RTS              
                  >265  
234C: AD 26 DF    >266  CP_LTGT  LDA   DATA+2     
234F: 49 80       >267           EOR   #hibit     ;invert sign bits of numbers
2351: 8D 26 DF    >268           STA   DATA+2     
2354: AD 29 DF    >269           LDA   NUMB+1     
2357: 49 80       >270           EOR   #hibit     
2359: 8D 29 DF    >271           STA   NUMB+1     
235C: 60          >272           RTS              
                  >273  
235D: 8E 25 DF    >274  CP_END   STX   DATA+1     
2360: 8D 26 DF    >275           STA   DATA+2     ;save result
2363: A0 01       >276           LDY   #1         
2365: 8C 24 DF    >277           STY   DATA       
2368: 60          >278           RTS              
                  >279  
                  >280  *-------------------------------
                  >281  * ----- logic operations -------
                  >282  *-------------------------------
                  >283  
2369: A2 00       >284  CMPEQ    LDX   #0         
236B: AD 28 DF    >285           LDA   NUMB       
236E: CD 25 DF    >286           CMP   DATA+1     
2371: D0 09 =237C >287           BNE   :CMPEQ0    
                  >288  
2373: AD 29 DF    >289           LDA   NUMB+1     
2376: CD 26 DF    >290           CMP   DATA+2     
2379: D0 01 =237C >291           BNE   :CMPEQ0    
                  >292  
237B: E8          >293           INX              
                  >294  
237C: A9 00       >295  :CMPEQ0  LDA   #0         
237E: 60          >296           RTS              
                  >297  
237F: A2 00       >298  CMPLT    LDX   #0         
2381: AD 29 DF    >299           LDA   NUMB+1     
2384: CD 26 DF    >300           CMP   DATA+2     
2387: 90 0D =2396 >301           BLT   :CMPLT0    
2389: D0 0A =2395 >302           BNE   :CMPLT1    
                  >303  
238B: AD 28 DF    >304           LDA   NUMB       
238E: CD 25 DF    >305           CMP   DATA+1     
2391: F0 03 =2396 >306           BEQ   :CMPLT0    
2393: 90 01 =2396 >307           BLT   :CMPLT0    
                  >308  
2395: E8          >309  :CMPLT1  INX              
                  >310  
2396: A9 00       >311  :CMPLT0  LDA   #0         
2398: 60          >312           RTS              
                  >313  
2399: A2 00       >314  CMPGT    LDX   #0         
239B: AD 26 DF    >315           LDA   DATA+2     
239E: CD 29 DF    >316           CMP   NUMB+1     
23A1: 90 0D =23B0 >317           BLT   :CMPGT0    
23A3: D0 0A =23AF >318           BNE   :CMPGT1    
                  >319  
23A5: AD 25 DF    >320           LDA   DATA+1     
23A8: CD 28 DF    >321           CMP   NUMB       
23AB: F0 03 =23B0 >322           BEQ   :CMPGT0    
23AD: 90 01 =23B0 >323           BLT   :CMPGT0    
                  >324  
23AF: E8          >325  :CMPGT1  INX              
                  >326  
23B0: A9 00       >327  :CMPGT0  LDA   #0         
23B2: 60          >328           RTS              
                  >329  
23B3: 48          >330  INVERT   PHA              ;change bit 0
23B4: 8A          >331           TXA              
23B5: 49 01       >332           EOR   #1         
23B7: AA          >333           TAX              
23B8: 68          >334           PLA              
23B9: 60          >335           RTS              
                   36            PUT   DISK       
                  >2    ********************************
                  >3    *                              *
                  >4    *       ACOS.OBJ - Disk        *
                  >5    *                              *
                  >6    ********************************
                                  3-MAR-23   9:23:11 AM
                  >8    *-------------------------------
                  >9    * open a text file [actually, any type of file!]
                  >10   *-------------------------------
                  >11   
23BA: A2 A3       >12   DO_OPEN  LDX   #"#"       
23BC: 20 F5 16    >13            JSR   GOBBLE     ;gobble "#"
23BF: 20 AB 1D    >14            JSR   INPNUM     ;get channel to open
23C2: CA          >15            DEX              
23C3: 86 02       >16            STX   TEMP2      ;save buffer number
23C5: E0 02       >17            CPX   #2         
23C7: B0 24 =23ED >18            BGE   :DO_OPN4   ;make sure it's in range [1-2]
                  >19   
23C9: BD 07 DF    >20            LDA   DEVUSE+1,X ;see if channel in use
23CC: 30 1B =23E9 >21            BMI   :DO_OPN3   
                  >22   
23CE: 20 F3 16    >23            JSR   GOBCOM     ;gobble comma
23D1: 20 63 2F    >24            JSR   MOVNAME    ;move file name
23D4: A4 02       >25            LDY   TEMP2      ;get buffer number
23D6: 20 B8 30    >26            JSR   BFOPEN     
                  >27   
23D9: A6 02       >28            LDX   TEMP2      
23DB: A9 00       >29            LDA   #0         ;save refnum or 0 if none
23DD: B0 03 =23E2 >30            BCS   :DO_OPN2   
                  >31   
23DF: AD CD 03    >32            LDA   REFNUM     
23E2: 9D 83 24    >33   :DO_OPN2 STA   REFTAB,X   ;save ref number
23E5: DE 07 DF    >34            DEC   DEVUSE+1,X ;put "in use"
23E8: 60          >35            RTS              
                  >36   
23E9: A2 10       >37   :DO_OPN3 LDX   #badfn     ;bad file name
23EB: D0 02 =23EF >38            BNE   :DO_OPN5   
                  >39   
23ED: A2 0F       >40   :DO_OPN4 LDX   #baddev    ;bad device number
23EF: 4C E1 12    >41   :DO_OPN5 JMP   BADERR     
                  >42   
                  >43   *-------------------------------
                  >44   * try to open in a non-used channel
                  >45   *-------------------------------
                  >46   
23F2: A0 00       >47   IFOPEN   LDY   #0         ;check channel 1
23F4: B9 07 DF    >48            LDA   DEVUSE+1,Y 
23F7: 10 06 =23FF >49            BPL   :IFOPEN2   ;it's open
                  >50   
23F9: C8          >51            INY              
23FA: B9 07 DF    >52            LDA   DEVUSE+1,Y ;try channel 2
23FD: 30 06 =2405 >53            BMI   :IFOPEN3   ;hmm, no open channel
                  >54   
23FF: 20 B8 30    >55   :IFOPEN2 JSR   BFOPEN     ;open file
2402: B0 01 =2405 >56            BCS   :IFOPEN3   ;opps, file didn't open
2404: 60          >57            RTS              ;clc = all is well
                  >58   
2405: 38          >59   :IFOPEN3 SEC              ;opps, couldn't open
2406: 60          >60            RTS              
                  >61   
                  >62   *-------------------------------
                  >63   * append to a file
                  >64   *-------------------------------
                  >65   
2407: 20 85 24    >66   DO_APP   JSR   GETDEV     ;get device
240A: 20 DD 24    >67            JSR   CHKDSK     ;make sure device is a file
240D: B9 83 24    >68            LDA   REFTAB,Y   
2410: 8D CD 03    >69            STA   REFNUM     ;get refnum
2413: 4C CF 31    >70            JMP   APPEND     ;append to file
                  >71   
                  >72   *-------------------------------
                  >73   * close a file
                  >74   *-------------------------------
                  >75   
2416: 20 85 24    >76   DO_CLOS  JSR   GETDEV     ;get device
2419: E0 00       >77            CPX   #0         
241B: F0 15 =2432 >78            BEQ   DO_CL3     ;if there wasn't one (or dev0) close all
                  >79   
241D: 20 DD 24    >80            JSR   CHKDSK     ;make sure device is a file
2420: 98          >81            TYA              
2421: AA          >82            TAX              ;x = y
2422: A9 00       >83            LDA   #0         
2424: 9D 07 DF    >84            STA   DEVUSE+1,X ;"un use" it
2427: BD 83 24    >85            LDA   REFTAB,X   ;get refnum
242A: F0 2E =245A >86            BEQ   DO_CL6     ;opps, not really open
                  >87   
242C: 8D CD 03    >88            STA   REFNUM     
242F: 4C D8 30    >89            JMP   CLOSE      ;close the correct file(s)
                  >90   
                  >91   *-------------------------------
                  >92   * close open files
                  >93   *-------------------------------
                  >94   
2432: AD 07 DF    >95   DO_CL3   LDA   DEVUSE+1   ;check channel 1
2435: 10 0B =2442 >96            BPL   :DO_CL4    
                  >97   
2437: AD 83 24    >98            LDA   REFTAB     ;close channel 1
243A: F0 06 =2442 >99            BEQ   :DO_CL4    ;opps, not really open
                  >100  
243C: 8D CD 03    >101           STA   REFNUM     
243F: 20 D8 30    >102           JSR   CLOSE      
                  >103  
2442: AD 08 DF    >104  :DO_CL4  LDA   DEVUSE+2   ;check channel 2
2445: 10 0B =2452 >105           BPL   :DO_CL5    
                  >106  
2447: AD 84 24    >107           LDA   REFTAB+1   ;close channel 2
244A: F0 06 =2452 >108           BEQ   :DO_CL5    ;opps, not really open
                  >109  
244C: 8D CD 03    >110           STA   REFNUM     
244F: 20 D8 30    >111           JSR   CLOSE      
                  >112  
2452: A9 00       >113  :DO_CL5  LDA   #0         
2454: 8D 07 DF    >114           STA   DEVUSE+1   ;close both channels
2457: 8D 08 DF    >115           STA   DEVUSE+2   
245A: 60          >116  DO_CL6   RTS              
                  >117  
                  >118  *-------------------------------
                  >119  * get input from the file
                  >120  *-------------------------------
                  >121  
245B: AD 83 24    >122  DISKIN1  LDA   REFTAB     ;use channel 1
245E: 8D CD 03    >123           STA   REFNUM     
2461: 4C 1F 31    >124           JMP   RDBYTE     
                  >125  
2464: AD 84 24    >126  DISKIN2  LDA   REFTAB+1   ;use channel 2
2467: 8D CD 03    >127           STA   REFNUM     
246A: 4C 1F 31    >128           JMP   RDBYTE     
                  >129  
                  >130  *-------------------------------
                  >131  * output to a file
                  >132  *-------------------------------
                  >133  
246D: 48          >134  DSKOUT1  PHA              
246E: AD 83 24    >135           LDA   REFTAB     ;use channel 1
2471: 8D CD 03    >136           STA   REFNUM     
2474: 68          >137           PLA              
2475: 4C 6A 31    >138           JMP   WRBYTE     
                  >139  
2478: 48          >140  DSKOUT2  PHA              
2479: AD 84 24    >141           LDA   REFTAB+1   
247C: 8D CD 03    >142           STA   REFNUM     ;use channel 2
247F: 68          >143           PLA              
2480: 4C 6A 31    >144           JMP   WRBYTE     
                  >145  
2483: 00 00       >146  REFTAB   DS    2          ;reference numbers
                  >147  
                  >148  *-------------------------------
                  >149  * get the device number
                  >150  *-------------------------------
                  >151  
2485: 20 E4 16    >152  GETDEV   JSR   CHKBYT     
2488: A2 00       >153           LDX   #0         
248A: A0 00       >154           LDY   #0         
248C: C9 A3       >155           CMP   #"#"       
248E: D0 31 =24C1 >156           BNE   :GETDEV1   ;device indicator?, nope
                  >157  
2490: 20 CC 16    >158           JSR   GETBYT     ;gobble '#'
2493: A9 00       >159           LDA   #0         
2495: 85 1F       >160           STA   DEVCLR     ;reset device byte
2497: 20 E4 16    >161           JSR   CHKBYT     
249A: C9 2C       >162           CMP   #msg       
249C: F0 24 =24C2 >163           BEQ   :GETMSG    ;check for message
                  >164  
249E: 20 AB 1D    >165           JSR   INPNUM     
24A1: C9 00       >166           CMP   #0         
24A3: D0 33 =24D8 >167           BNE   GETDEV2    ;if > 255
                  >168  
24A5: 2C 63 DF    >169           BIT   MSGINIT    ;is channel 6 setup?
24A8: 30 04 =24AE >170           BMI   :GETMSG2   ;yep
                  >171  
24AA: E0 06       >172           CPX   #6         
24AC: F0 2A =24D8 >173           BEQ   GETDEV2    ;trying to use channel 6?, yes, stop them
                  >174  
24AE: 20 E4 16    >175  :GETMSG2 JSR   CHKBYT     
24B1: C9 AC       >176           CMP   #","       
24B3: D0 03 =24B8 >177           BNE   :GETDEV0   
                  >178  
24B5: 20 CC 16    >179           JSR   GETBYT     ;gobble comma
24B8: BD 06 DF    >180  :GETDEV0 LDA   DEVUSE,X   ;is channel in use
24BB: 10 1B =24D8 >181           BPL   GETDEV2    ;nope
                  >182  
24BD: 8A          >183           TXA              
24BE: A8          >184           TAY              ;y = x
24BF: 0A          >185           ASL              ;x = x * 2
24C0: AA          >186           TAX              
24C1: 60          >187  :GETDEV1 RTS              
                  >188  
24C2: 20 CC 16    >189  :GETMSG  JSR   GETBYT     ;gobble
24C5: 20 AB 1D    >190           JSR   INPNUM     ;get msg number
24C8: 8E 5F DF    >191           STX   MSGNUM     ;save
24CB: 8D 60 DF    >192           STA   MSGNUM+1   
24CE: A9 00       >193           LDA   #0         
24D0: 8D 63 DF    >194           STA   MSGINIT    ;init message
24D3: A2 06       >195           LDX   #6         ;return channel
24D5: 4C AE 24    >196           JMP   :GETMSG2   ;finish up
                  >197  
24D8: A2 0F       >198  GETDEV2  LDX   #baddev    ;bad device #
24DA: 4C E1 12    >199           JMP   BADERR     
                  >200  
24DD: 88          >201  CHKDSK   DEY              ;make sure device is a file
24DE: C0 02       >202           CPY   #2         
24E0: B0 F6 =24D8 >203           BGE   GETDEV2    ;if it's not a file...
                  >204  
24E2: 60          >205           RTS              
                  >206  
                  >207  *-------------------------------
                  >208  * get the size of the open file
                  >209  *-------------------------------
                  >210  
24E3: 20 8F 1E    >211  DO_SIZE  JSR   INPNARG    ;get volume number
24E6: E0 03       >212           CPX   #3         
24E8: B0 EE =24D8 >213           BGE   GETDEV2    ;bad device
                  >214  
24EA: BD 82 24    >215           LDA   REFTAB-1,X ;get refnum
24ED: 8D CD 03    >216           STA   REFNUM     
24F0: 20 C5 31    >217           JSR   GETSIZ     ;get the file size
24F3: 4C 9A 21    >218           JMP   DO_MATH    
                  >219  
                  >220  *-------------------------------
                  >221  * check for end of file
                  >222  *-------------------------------
                  >223  
24F6: 20 8F 1E    >224  DO_EOF   JSR   INPNARG    ;get channel number
24F9: E0 03       >225           CPX   #3         
24FB: B0 DB =24D8 >226           BGE   GETDEV2    ;bad device
                  >227  
24FD: BD 82 24    >228           LDA   REFTAB-1,X ;move refnum
2500: 8D CD 03    >229           STA   REFNUM     
2503: 20 AB 31    >230           JSR   CHKEOF     ;check for eof
2506: 8A          >231           TXA              
2507: 4C FC 39    >232           JMP   SVDATA     ;return results
                  >233  
                  >234  *-------------------------------
                  >235  * set/get the mark for a file
                  >236  *-------------------------------
                  >237  
250A: 20 8F 1E    >238  DO_MARK  JSR   INPNARG    
250D: E0 0A       >239           CPX   #10        
250F: F0 31 =2542 >240           BEQ   :DO_MRK5   ;ram drive?
                  >241  
2511: CA          >242           DEX              
2512: E0 02       >243           CPX   #2         
2514: B0 27 =253D >244           BGE   :DO_MRK3   ;make sure it's a valid channel
                  >245  
2516: BD 07 DF    >246           LDA   DEVUSE+1,X ;not current in use
2519: 10 22 =253D >247           BPL   :DO_MRK3   
                  >248  
251B: BD 83 24    >249           LDA   REFTAB,X   
251E: A8          >250           TAY              ;get refnum
                  >251  
251F: 24 6B       >252           BIT   IMMDEF     ;see if mark was exec'ed
2521: 10 0D =2530 >253           BPL   :DO_MRK2   
                  >254  
2523: 20 EF 16    >255           JSR   GOBEQU     ;possible syntax error
2526: 84 07       >256           STY   SAVE_Y     ;set the mark
2528: 20 AB 1D    >257           JSR   INPNUM     
252B: A4 07       >258           LDY   SAVE_Y     
252D: 4C D5 31    >259           JMP   SETMARK    
                  >260  
2530: 20 F9 31    >261  :DO_MRK2 JSR   GETMARK    ;get the mark
2533: 90 05 =253A >262           BCC   :DO_MRK4   ;all is well
                  >263  
2535: A9 01       >264           LDA   #1         ;error
2537: 4C FC 39    >265           JMP   SVDATA     
                  >266  
253A: 4C 9A 21    >267  :DO_MRK4 JMP   DO_MATH    ;return location
                  >268  
253D: A2 0F       >269  :DO_MRK3 LDX   #baddev    ;bad device #
253F: 4C E1 12    >270           JMP   BADERR     
                  >271  
2542: 24 6B       >272  :DO_MRK5 BIT   IMMDEF     ;did they exec command?
2544: 10 09 =254F >273           BPL   :DO_MRK6   ;nope
                  >274  
2546: 20 EF 16    >275           JSR   GOBEQU     
2549: 20 AB 1D    >276           JSR   INPNUM     ;get pointer
254C: 86 75       >277           STX   RAMPTR     ;save
254E: 60          >278           RTS              
                  >279  
254F: A5 75       >280  :DO_MRK6 LDA   RAMPTR     ;return pointer
2551: 4C FC 39    >281           JMP   SVDATA     
                  >282  
                  >283  *-------------------------------
                  >284  * link to another segment
                  >285  *-------------------------------
                  >286  
2554: 20 C2 20    >287  DO_LINK  JSR   DO_FRE     ;compact variables
2557: 20 32 24    >288           JSR   DO_CL3     ;close all open files
255A: 20 63 2F    >289           JSR   MOVNAME    ;move filename
255D: A9 00       >290           LDA   #0         
255F: 8D CF 25    >291           STA   LNKLBL     
2562: 20 E4 16    >292           JSR   CHKBYT     
2565: C9 AC       >293           CMP   #","       
2567: D0 20 =2589 >294           BNE   :LINK4     ;check for link label, nope
                  >295  
2569: 20 F3 16    >296           JSR   GOBCOM     ;gobble comma
256C: 20 07 1F    >297           JSR   INPSTR     ;get link label
                  >298  
256F: A0 00       >299           LDY   #0         
2571: B1 0D       >300  :LINK2   LDA   (STRLOC),Y ;copy label name
2573: 20 6E 17    >301           JSR   CONV       
2576: C8          >302           INY              
2577: C4 0F       >303           CPY   STRLEN     
2579: D0 02 =257D >304           BNE   :LINK3     ;is this the last char?
                  >305  
257B: 09 80       >306           ORA   #hibit     
257D: 99 CE 25    >307  :LINK3   STA   LNKLBL-1,Y ;save char
2580: C0 08       >308           CPY   #8         
2582: D0 ED =2571 >309           BNE   :LINK2     
                  >310  
2584: 09 80       >311           ORA   #hibit     ;mark last char
2586: 99 CE 25    >312           STA   LNKLBL-1,Y 
                  >313  
2589: 20 6A 26    >314  :LINK4   JSR   COMPRES    ;compress variables
258C: 20 50 32    >315           JSR   LD_MOD     ;load in module
258F: 20 27 27    >316           JSR   UNCOMP     ;un-compress variables
                  >317  
2592: A9 00       >318           LDA   #<CODEND   ;were finally done!
2594: 85 04       >319           STA   PRGPTR     
2596: A9 51       >320           LDA   #>CODEND   
2598: 85 05       >321           STA   PRGPTR+1   
259A: AD CF 25    >322           LDA   LNKLBL     ;link to a label?
259D: F0 21 =25C0 >323           BEQ   :LINK9     ;nope, just return
                  >324  
259F: A2 80       >325           LDX   #128       ;start table pointer
25A1: A0 00       >326  :LINK5   LDY   #0         ;start string pointer
25A3: BD 00 02    >327  :LINK6   LDA   LNBUF,X    ;get first char
25A6: F0 22 =25CA >328           BEQ   :LINK8     ;opps, end of table
                  >329  
25A8: E8          >330           INX              
25A9: D9 CF 25    >331           CMP   LNKLBL,Y   
25AC: D0 13 =25C1 >332           BNE   :LINK7     ;check it, no match
25AE: C8          >333           INY              
25AF: 0A          >334           ASL              ;are we done?
25B0: 90 F1 =25A3 >335           BCC   :LINK6     ;nope, keep checking
                  >336  
25B2: 8A          >337           TXA              
25B3: 29 F0       >338           AND   #$F0       ;round down X
25B5: AA          >339           TAX              
                  >340  
25B6: BD 08 02    >341           LDA   LNBUF+8,X  
25B9: 85 04       >342           STA   PRGPTR     ;get address and save
25BB: BD 09 02    >343           LDA   LNBUF+9,X  
25BE: 85 05       >344           STA   PRGPTR+1   
25C0: 60          >345  :LINK9   RTS              ;return
                  >346  
25C1: 8A          >347  :LINK7   TXA              ;round down X
25C2: 29 F0       >348           AND   #$F0       
25C4: 18          >349           CLC              
25C5: 69 10       >350           ADC   #$10       ;go to next label
25C7: AA          >351           TAX              
25C8: 90 D7 =25A1 >352           BCC   :LINK5     ;keep going if more data
                  >353  
25CA: A2 13       >354  :LINK8   LDX   #nolink    ;link label not found
25CC: 4C E1 12    >355           JMP   BADERR     
                  >356  
25CF: 00 00 00 00 >357  LNKLBL   DS    9          ;location of link label
                  >358  
                  >359  *-------------------------------
                  >360  * store current variables to a disk file
                  >361  *-------------------------------
                  >362  
25D8: 20 32 24    >363  DO_STOR  JSR   DO_CL3     ;close any open files
25DB: 20 63 2F    >364           JSR   MOVNAME    ;move filename
25DE: A0 2D       >365           LDY   #a2data    
25E0: A9 80       >366           LDA   #>packfile 
25E2: A2 02       >367           LDX   #<packfile 
25E4: 20 88 30    >368           JSR   CREATE     ;create file
25E7: 20 B6 30    >369           JSR   OPEN       ;open file
                  >370  
25EA: 20 6A 26    >371           JSR   COMPRES    ;compress memory
                  >372  
25ED: AD 24 DF    >373           LDA   DATA       ;point to old lomem location
25F0: 20 6A 31    >374           JSR   WRBYTE     
25F3: AD 25 DF    >375           LDA   DATA+1     
25F6: 20 6A 31    >376           JSR   WRBYTE     
                  >377  
25F9: AD 2B DF    >378           LDA   FREMEM     ;save # of string pages
25FC: 20 6A 31    >379           JSR   WRBYTE     
                  >380  
25FF: A5 6D       >381           LDA   MIDMEM     ;point to address of strings
2601: 20 6A 31    >382           JSR   WRBYTE     
2604: A5 6E       >383           LDA   MIDMEM+1   
2606: 20 6A 31    >384           JSR   WRBYTE     
                  >385  
2609: 38          >386           SEC              
260A: A5 74       >387           LDA   HIMEM+1    
260C: E5 6E       >388           SBC   MIDMEM+1   
260E: 18          >389           CLC              
260F: 69 01       >390           ADC   #1         ;write # pages of data
2611: 20 6A 31    >391           JSR   WRBYTE     
                  >392  
2614: 0A          >393           ASL              
2615: A8          >394           TAY              
2616: A6 6D       >395           LDX   MIDMEM     ;write data out to disk
2618: A5 6E       >396           LDA   MIDMEM+1   
261A: 20 38 31    >397           JSR   WRBLK      
                  >398  
261D: 20 D8 30    >399           JSR   CLOSE      ;close file
2620: 20 27 27    >400           JSR   UNCOMP     ;fix memory
2623: 60          >401           RTS              
                  >402  
                  >403  *-------------------------------
                  >404  * recall a set of variables from disk to memory
                  >405  *-------------------------------
                  >406  
2624: 20 32 24    >407  DO_RCAL  JSR   DO_CL3     ;close all open files
                  >408  
2627: 20 63 2F    >409           JSR   MOVNAME    ;get filename
262A: 20 71 38    >410           JSR   CLEAR      
262D: 20 B6 30    >411           JSR   OPEN       
2630: 90 05 =2637 >412           BCC   :RCALL2    ;all is fine
2632: A2 10       >413           LDX   #badfn     
2634: 4C E1 12    >414           JMP   BADERR     ;illegal filename
                  >415  
2637: 20 1F 31    >416  :RCALL2  JSR   RDBYTE     ;restore old lomem position
263A: 8D 24 DF    >417           STA   DATA       
263D: 20 1F 31    >418           JSR   RDBYTE     
2640: 8D 25 DF    >419           STA   DATA+1     
                  >420  
2643: 20 1F 31    >421           JSR   RDBYTE     ;restore # pages of strings
2646: 8D 2B DF    >422           STA   FREMEM     
                  >423  
2649: 20 1F 31    >424           JSR   RDBYTE     
264C: 85 6D       >425           STA   MIDMEM     
264E: AA          >426           TAX              ;get address of data
264F: 20 1F 31    >427           JSR   RDBYTE     
2652: 85 6E       >428           STA   MIDMEM+1   
2654: 48          >429           PHA              
                  >430  
2655: 20 1F 31    >431           JSR   RDBYTE     ;get length of data
2658: 0A          >432           ASL              
2659: A8          >433           TAY              
265A: 68          >434           PLA              
265B: 20 42 31    >435           JSR   RDBLK      ;read in data
                  >436  
265E: 20 D8 30    >437           JSR   CLOSE      ;close file
                  >438  
2661: A9 01       >439           LDA   #1         ;make sure it uncompresses
2663: 8D 3B DF    >440           STA   CPASS      
                  >441  
2666: 20 27 27    >442           JSR   UNCOMP     ;un-compress
2669: 60          >443           RTS              
                  >444  
                  >445  *-------------------------------
                  >446  * compress variables at top of memory
                  >447  * at exit: data points to data
                  >448  *-------------------------------
                  >449  
266A: 20 C2 20    >450  COMPRES  JSR   DO_FRE     ;clear up memory
266D: A5 73       >451           LDA   HIMEM      ;point to var-pointers
266F: 85 00       >452           STA   TEMP       
2671: A5 74       >453           LDA   HIMEM+1    
2673: 85 01       >454           STA   TEMP+1     
2675: A9 00       >455           LDA   #0         ;flag for pass through
2677: 8D 3B DF    >456           STA   CPASS      
                  >457  
267A: 38          >458  :COMP2   SEC              ;walk through pointers
267B: A5 00       >459           LDA   TEMP       
267D: E9 06       >460           SBC   #6         
267F: 85 00       >461           STA   TEMP       
2681: A5 01       >462           LDA   TEMP+1     
2683: E9 00       >463           SBC   #0         
2685: 85 01       >464           STA   TEMP+1     
                  >465  
2687: A0 00       >466           LDY   #0         
2689: B1 00       >467           LDA   (TEMP),Y   
268B: F0 52 =26DF >468           BEQ   :COMP5     ;were done copying
268D: 08          >469           PHP              
268E: A9 FF       >470           LDA   #-1        
2690: 8D 3B DF    >471           STA   CPASS      
2693: 28          >472           PLP              
2694: 10 E4 =267A >473           BPL   :COMP2     ;only do strings
                  >474  
2696: A0 02       >475           LDY   #2         
2698: B1 00       >476           LDA   (TEMP),Y   
269A: 85 83       >477           STA   VPTR       ;point to string
269C: C8          >478           INY              
269D: B1 00       >479           LDA   (TEMP),Y   
269F: 85 84       >480           STA   VPTR+1     
26A1: C8          >481           INY              
26A2: B1 00       >482           LDA   (TEMP),Y   
26A4: AA          >483           TAX              
26A5: F0 D3 =267A >484           BEQ   :COMP2     ;if 0 long...
                  >485  
26A7: A5 84       >486           LDA   VPTR+1     ;find out if string is in tokanized
26A9: C5 6A       >487           CMP   LOMEM+1    ;program segment
26AB: F0 06 =26B3 >488           BEQ   :COMP3     ;if so, move it to ram
26AD: B0 CB =267A >489           BGE   :COMP2     ;ok, it's in memory
                  >490  
26AF: C9 51       >491           CMP   #>CODEND   ;make sure it's really in program
26B1: 90 C7 =267A >492           BLT   :COMP2     ;good thing we checked
                  >493  
26B3: A5 83       >494  :COMP3   LDA   VPTR       
26B5: C5 69       >495           CMP   LOMEM      
26B7: B0 C1 =267A >496           BGE   :COMP2     ;it's ok
                  >497  
26B9: A0 00       >498           LDY   #0         
26BB: B1 83       >499  :COMP4   LDA   (VPTR),Y   
26BD: 91 08       >500           STA   (VARSTR),Y ;copy string along with other strings
26BF: C8          >501           INY              
26C0: CA          >502           DEX              
26C1: D0 F8 =26BB >503           BNE   :COMP4     
                  >504  
26C3: 98          >505           TYA              ;x = y
26C4: AA          >506           TAX              
26C5: A0 02       >507           LDY   #2         
26C7: A5 08       >508           LDA   VARSTR     
26C9: 91 83       >509           STA   (VPTR),Y   ;point to new string
26CB: C8          >510           INY              
26CC: A5 09       >511           LDA   VARSTR+1   
26CE: 91 83       >512           STA   (VPTR),Y   
                  >513  
26D0: 18          >514           CLC              
26D1: 8A          >515           TXA              
26D2: 65 08       >516           ADC   VARSTR     ;move up pointers
26D4: 85 08       >517           STA   VARSTR     
26D6: A9 00       >518           LDA   #0         
26D8: 65 09       >519           ADC   VARSTR+1   
26DA: 85 09       >520           STA   VARSTR+1   
26DC: 4C 7A 26    >521           JMP   :COMP2     
                  >522  
26DF: AD 3B DF    >523  :COMP5   LDA   CPASS      ;anything done?
26E2: F0 42 =2726 >524           BEQ   COMP8      ;no, just exit
                  >525  
26E4: A5 00       >526           LDA   TEMP       ;save pointer to end of var pointers
26E6: 85 13       >527           STA   TEMP3      
26E8: A5 01       >528           LDA   TEMP+1     
26EA: 85 14       >529           STA   TEMP3+1    
                  >530  
26EC: A5 69       >531           LDA   LOMEM      
26EE: C5 08       >532           CMP   VARSTR     
26F0: B0 02 =26F4 >533           BGE   :COMP6     ;make pointers point to a boundry
                  >534  
26F2: E6 09       >535           INC   VARSTR+1   
26F4: 85 08       >536  :COMP6   STA   VARSTR     
26F6: C6 01       >537           DEC   TEMP+1     
26F8: C6 09       >538           DEC   VARSTR+1   
                  >539  
26FA: A0 00       >540           LDY   #0         
26FC: 8C 2B DF    >541           STY   FREMEM     
                  >542  
26FF: B1 08       >543  :COMP7   LDA   (VARSTR),Y 
2701: 91 00       >544           STA   (TEMP),Y   ;copy a page
2703: C8          >545           INY              
2704: D0 F9 =26FF >546           BNE   :COMP7     
                  >547  
2706: A5 09       >548           LDA   VARSTR+1   
2708: EE 2B DF    >549           INC   FREMEM     
270B: C6 01       >550           DEC   TEMP+1     
270D: C6 09       >551           DEC   VARSTR+1   ;go until we are done
270F: C5 6A       >552           CMP   LOMEM+1    
2711: D0 EC =26FF >553           BNE   :COMP7     
                  >554  
2713: A6 00       >555           LDX   TEMP       
2715: 86 6D       >556           STX   MIDMEM     ;save location of strings
2717: A6 01       >557           LDX   TEMP+1     
2719: E8          >558           INX              
271A: 86 6E       >559           STX   MIDMEM+1   
                  >560  
271C: A5 69       >561           LDA   LOMEM      ;point to variables/tables
271E: 8D 24 DF    >562           STA   DATA       
2721: A5 6A       >563           LDA   LOMEM+1    
2723: 8D 25 DF    >564           STA   DATA+1     
2726: 60          >565  COMP8    RTS              
                  >566  
                  >567  *-------------------------------
                  >568  * un-compress memory into variables
                  >569  *-------------------------------
                  >570  
2727: AD 3B DF    >571  UNCOMP   LDA   CPASS      ;anything compressed?
272A: F0 FA =2726 >572           BEQ   COMP8      ;no, do nothing
                  >573  
272C: 38          >574           SEC              
272D: A5 69       >575           LDA   LOMEM      
272F: ED 24 DF    >576           SBC   DATA       
2732: 8D 24 DF    >577           STA   DATA       ;compute offset
                  >578  
2735: A5 6A       >579           LDA   LOMEM+1    
2737: ED 25 DF    >580           SBC   DATA+1     
273A: 8D 25 DF    >581           STA   DATA+1     ;compute offset
                  >582  
273D: A5 69       >583           LDA   LOMEM      ;point at strings
273F: 85 00       >584           STA   TEMP       
2741: A5 6A       >585           LDA   LOMEM+1    
2743: 85 01       >586           STA   TEMP+1     
                  >587  
2745: AE 2B DF    >588           LDX   FREMEM     
2748: A0 00       >589           LDY   #0         
274A: B1 6D       >590  :UNCOMP2 LDA   (MIDMEM),Y 
274C: 91 00       >591           STA   (TEMP),Y   ;copy a page
274E: C8          >592           INY              
274F: D0 F9 =274A >593           BNE   :UNCOMP2   
                  >594  
2751: E6 6E       >595           INC   MIDMEM+1   
2753: E6 01       >596           INC   TEMP+1     ;count the page
2755: CA          >597           DEX              
2756: D0 F2 =274A >598           BNE   :UNCOMP2   
                  >599  
2758: A5 00       >600           LDA   TEMP       ;set up varstr [approx...]
275A: 85 08       >601           STA   VARSTR     
275C: A5 01       >602           LDA   TEMP+1     
275E: 85 09       >603           STA   VARSTR+1   
                  >604  
2760: A5 73       >605           LDA   HIMEM      
2762: 85 00       >606           STA   TEMP       
2764: A5 74       >607           LDA   HIMEM+1    
2766: 85 01       >608           STA   TEMP+1     
                  >609  
2768: 38          >610  :UNCOMP3 SEC              
2769: A5 00       >611           LDA   TEMP       
276B: E9 06       >612           SBC   #6         
276D: 85 00       >613           STA   TEMP       ;count down through strings
276F: A5 01       >614           LDA   TEMP+1     
2771: E9 00       >615           SBC   #0         
2773: 85 01       >616           STA   TEMP+1     
                  >617  
2775: A0 00       >618           LDY   #0         
2777: B1 00       >619           LDA   (TEMP),Y   
2779: F0 23 =279E >620           BEQ   :UNCOMP4   ;were done
277B: 10 EB =2768 >621           BPL   :UNCOMP3   ;don't fool with numbers
                  >622  
277D: A0 04       >623           LDY   #4         ;check length of string
277F: B1 00       >624           LDA   (TEMP),Y   ;is it an empty string?
2781: F0 E5 =2768 >625           BEQ   :UNCOMP3   ;yep
                  >626  
2783: 88          >627           DEY              
2784: B1 00       >628           LDA   (TEMP),Y   ;get address of string
2786: C9 51       >629           CMP   #>CODEND   
2788: 90 DE =2768 >630           BLT   :UNCOMP3   ;don't touch it
                  >631  
278A: 88          >632           DEY              
278B: 18          >633           CLC              
278C: AD 24 DF    >634           LDA   DATA       
278F: 71 00       >635           ADC   (TEMP),Y   
2791: 91 00       >636           STA   (TEMP),Y   ;fix pointers
2793: C8          >637           INY              
2794: AD 25 DF    >638           LDA   DATA+1     
2797: 71 00       >639           ADC   (TEMP),Y   
2799: 91 00       >640           STA   (TEMP),Y   
279B: 4C 68 27    >641           JMP   :UNCOMP3   
                  >642  
279E: 38          >643  :UNCOMP4 SEC              
279F: A5 01       >644           LDA   TEMP+1     
27A1: E5 6A       >645           SBC   LOMEM+1    ;fix midmem pointer
27A3: 4A          >646           LSR   A          
27A4: 18          >647           CLC              
27A5: 65 6A       >648           ADC   LOMEM+1    
27A7: 85 6E       >649           STA   MIDMEM+1   
                  >650  
27A9: A9 00       >651           LDA   #0         
27AB: 85 6D       >652           STA   MIDMEM     
27AD: 60          >653  SHWRTS   RTS              
                  >654  
                  >655  *-------------------------------
                  >656  * copy a file from device to device
                  >657  *-------------------------------
                  >658  
27AE: A9 00       >659  DO_SHOW  LDA   #0         
27B0: 85 77       >660           STA   SHW_CNT    ;reset line count
27B2: 20 E4 16    >661           JSR   CHKBYT     ;check for # of lines
27B5: C9 A8       >662           CMP   #"("       
27B7: D0 05 =27BE >663           BNE   :SHOW0A    
                  >664  
27B9: 20 8F 1E    >665           JSR   INPNARG    ;get argument
27BC: 86 77       >666           STX   SHW_CNT    ;save count
                  >667  
27BE: 20 85 24    >668  :SHOW0A  JSR   GETDEV     ;get input source
27C1: 8C E3 28    >669           STY   SHWIN      
                  >670  
27C4: BD C9 DC    >671           LDA   INPVEC,X   ;save vector
27C7: 85 56       >672           STA   VECTOR2    
27C9: BD CA DC    >673           LDA   INPVEC+1,X 
27CC: 85 57       >674           STA   VECTOR2+1  
                  >675  
27CE: B9 82 24    >676           LDA   REFTAB-1,Y 
27D1: 8D CD 03    >677           STA   REFNUM     ;save possible refnum
27D4: 98          >678           TYA              
27D5: D0 03 =27DA >679           BNE   :SHOW0     ;if using device, skip
                  >680  
27D7: 20 63 2F    >681           JSR   MOVNAME    ;get filename
                  >682  
27DA: 20 E4 16    >683  :SHOW0   JSR   CHKBYT     
27DD: C9 AC       >684           CMP   #","       
27DF: D0 03 =27E4 >685           BNE   :SHOW1     
                  >686  
27E1: 20 F3 16    >687           JSR   GOBCOM     ;gobble
27E4: 20 85 24    >688  :SHOW1   JSR   GETDEV     
27E7: 8C E4 28    >689           STY   SHWOUT     
                  >690  
27EA: BD DF DC    >691           LDA   OUTVEC,X   ;save output vectors
27ED: 85 15       >692           STA   VECTOR     
27EF: BD E0 DC    >693           LDA   OUTVEC+1,X 
27F2: 85 16       >694           STA   VECTOR+1   
                  >695  
27F4: AD E3 28    >696           LDA   SHWIN      ;get input device
27F7: C9 03       >697           CMP   #3         
27F9: B0 12 =280D >698           BGE   :SHOW3     
27FB: C9 00       >699           CMP   #0         
27FD: D0 05 =2804 >700           BNE   :SHOW2     ;is file open?, yep
                  >701  
27FF: 20 B6 30    >702           JSR   OPEN       ;open the file
2802: B0 A9 =27AD >703           BCS   SHWRTS     ;we are done (that was quick!)
                  >704  
2804: 20 F2 30    >705  :SHOW2   JSR   RDLNSET    ;setup for rdline
2807: AD CD 03    >706           LDA   REFNUM     
280A: 8D E5 28    >707           STA   SHWREF     ;save refnum
                  >708  
                  >709  * input line of data from a disk file
                  >710  
280D: 2C E6 28    >711  :SHOW3   BIT   XTERNAL    ;use external?
2810: 30 07 =2819 >712           BMI   :SHOW3X    ;yep
                  >713  
2812: AD E3 28    >714           LDA   SHWIN      
2815: C9 03       >715           CMP   #3         
2817: B0 0E =2827 >716           BGE   :SHOW3A    ;char device?, yep
                  >717  
2819: AD E5 28    >718  :SHOW3X  LDA   SHWREF     
281C: 8D CD 03    >719           STA   REFNUM     ;make sure refnum is correct
                  >720  
281F: 20 02 31    >721           JSR   RDLINE     ;get char
2822: 90 4A =286E >722           BCC   :SHOW4     
2824: 4C A1 28    >723           JMP   :SHOW5     ;opps, end of data
                  >724  
                  >725  * input a line of data from a character device
                  >726  
2827: A2 00       >727  :SHOW3A  LDX   #0         ;start pointer
2829: 8A          >728  :SHOW3B  TXA              
282A: 48          >729           PHA              
282B: 20 22 3B    >730           JSR   DO_INP     ;get data
282E: C9 04       >731           CMP   #eot       
2830: D0 02 =2834 >732           BNE   :SHOW3C    ;end of section?, nope
                  >733  
2832: A9 00       >734           LDA   #0         ;mark it
                  >735  
2834: 9D 00 02    >736  :SHOW3C  STA   LNBUF,X    ;save
2837: A8          >737           TAY              
2838: 68          >738           PLA              
2839: AA          >739           TAX              
283A: E8          >740           INX              
                  >741  
283B: C0 00       >742           CPY   #0         
283D: F0 2F =286E >743           BEQ   :SHOW4     ;are we done?, yep
283F: C0 0D       >744           CPY   #cr        
2841: D0 E6 =2829 >745           BNE   :SHOW3B    ;end of line?, nope
                  >746  
                  >747  * check for and handle ".x" external
                  >748  
2843: AD E4 28    >749           LDA   SHWOUT     ;is it to the crt?
2846: C9 06       >750           CMP   #6         
2848: B0 24 =286E >751           BGE   :SHOW4     ;nope
                  >752  
284A: AD 00 02    >753           LDA   LNBUF      ;is it a dot?
284D: 29 7F       >754           AND   #clrhi     
284F: C9 2E       >755           CMP   #'.'       
2851: D0 1B =286E >756           BNE   :SHOW4     ;nope
                  >757  
2853: AD 01 02    >758           LDA   LNBUF+1    ;check for "X"
2856: 20 6E 17    >759           JSR   CONV       
2859: C9 58       >760           CMP   #'X'       
285B: D0 11 =286E >761           BNE   :SHOW4     ;nope
                  >762  
285D: AD 02 02    >763           LDA   LNBUF+2    ;is it a space?
2860: 29 7F       >764           AND   #clrhi     
2862: C9 20       >765           CMP   #' '       
2864: D0 08 =286E >766           BNE   :SHOW4     ;nope
                  >767  
2866: 20 CB 28    >768           JSR   EXTERN     ;set up external file
2869: 2C E6 28    >769           BIT   XTERNAL    
286C: 30 96 =2804 >770           BMI   :SHOW2     ;ok, file is open
                  >771  
                  >772  * output a line of data to a device
                  >773  
286E: A2 00       >774  :SHOW4   LDX   #0         ;start pointer
2870: 86 76       >775  :SHOW4A  STX   SHOW_X     
2872: BD 00 02    >776           LDA   LNBUF,X    ;get data
2875: F0 2A =28A1 >777           BEQ   :SHOW5     ;we are done with file
                  >778  
2877: 29 7F       >779           AND   #clrhi     
2879: C9 0A       >780           CMP   #lf        
287B: F0 05 =2882 >781           BEQ   :SHOW4B    ;strip all lf's
287D: 48          >782           PHA              
287E: 20 B5 37    >783           JSR   DO_OUT     ;output it
2881: 68          >784           PLA              
                  >785  
2882: A6 76       >786  :SHOW4B  LDX   SHOW_X     ;get back pointer
2884: E8          >787           INX              
2885: C9 0D       >788           CMP   #cr        
2887: D0 E7 =2870 >789           BNE   :SHOW4A    ;done with line?, nope
                  >790  
                  >791  * handle end of line of output
                  >792  
2889: A5 77       >793           LDA   SHW_CNT    ;is there a line limit?
288B: F0 04 =2891 >794           BEQ   :SHOW4C    ;nope
                  >795  
288D: C6 77       >796           DEC   SHW_CNT    
288F: F0 10 =28A1 >797           BEQ   :SHOW5     ;count down lines, opps, that is all
                  >798  
2891: AD E3 28    >799  :SHOW4C  LDA   SHWIN      ;is this a read mail?
2894: C9 07       >800           CMP   #7         
2896: F0 24 =28BC >801           BEQ   :JSHOW3    ;yep
                  >802  
2898: AD E4 28    >803           LDA   SHWOUT     ;is output to the crt?
289B: D0 1F =28BC >804           BNE   :JSHOW3    ;nope
                  >805  
289D: 24 34       >806           BIT   INTOUT     ;stop output?
289F: 10 1B =28BC >807           BPL   :JSHOW3    ;nope
                  >808  
                  >809  * handle end of output and return
                  >810  
28A1: 2C E6 28    >811  :SHOW5   BIT   XTERNAL    ;external on?
28A4: 30 05 =28AB >812           BMI   :SHOW5B    ;yep, close it
                  >813  
28A6: AD E3 28    >814           LDA   SHWIN      ;is this from a disk file?
28A9: D0 14 =28BF >815           BNE   :SHOW6     ;nope
                  >816  
28AB: AD E5 28    >817  :SHOW5B  LDA   SHWREF     
28AE: 8D CD 03    >818           STA   REFNUM     ;get correct refnum
28B1: 20 D8 30    >819           JSR   CLOSE      ;close file
28B4: 2C E6 28    >820           BIT   XTERNAL    
28B7: 10 06 =28BF >821           BPL   :SHOW6     
                  >822  
28B9: EE E6 28    >823           INC   XTERNAL    ;turn off external
28BC: 4C 0D 28    >824  :JSHOW3  JMP   :SHOW3     ;and continue
                  >825  
28BF: AD E4 28    >826  :SHOW6   LDA   SHWOUT     ;check destination
28C2: C9 04       >827           CMP   #4         ;is it console, disk 1 or 2?
28C4: 90 1C =28E2 >828           BLT   EXTERN2    ;yep, don't send null, just return
                  >829  
28C6: A9 00       >830           LDA   #0         ;were finished
28C8: 4C B5 37    >831           JMP   DO_OUT     
                  >832  
28CB: A9 03       >833  EXTERN   LDA   #<LNBUF+3  ;point to filename
28CD: 85 0D       >834           STA   STRLOC     
28CF: A9 02       >835           LDA   #>LNBUF+3  
28D1: 85 0E       >836           STA   STRLOC+1   
28D3: A9 13       >837           LDA   #19        
28D5: 85 0F       >838           STA   STRLEN     ;save max string length
28D7: 20 66 2F    >839           JSR   MOVNM0     ;move the filename
                  >840  
28DA: 20 F2 23    >841           JSR   IFOPEN     ;open file
28DD: B0 03 =28E2 >842           BCS   EXTERN2    ;opps, file didn't open
                  >843  
28DF: CE E6 28    >844           DEC   XTERNAL    ;flag that external read is on
28E2: 60          >845  EXTERN2  RTS              
                  >846  
28E3: 00          >847  SHWIN    DB    0          
28E4: 00          >848  SHWOUT   DB    0          
28E5: 00          >849  SHWREF   DB    0          
28E6: 00          >850  XTERNAL  DB    0          
                  >851  
                  >852  *-------------------------------
                  >853  * position into a file
                  >854  *-------------------------------
                  >855  
28E7: 20 85 24    >856  DO_POS   JSR   GETDEV     ;get device
28EA: 20 DD 24    >857           JSR   CHKDSK     ;make sure it's a file
                  >858  
28ED: B9 83 24    >859           LDA   REFTAB,Y   
28F0: 8D CD 03    >860           STA   REFNUM     ;save the reference number
                  >861  
28F3: 20 AB 1D    >862           JSR   INPNUM     ;get record length
28F6: 8E 1E DF    >863           STX   FLPOS      ;save rec length
28F9: 8D 1F DF    >864           STA   FLPOS+1    
                  >865  
28FC: 20 F3 16    >866           JSR   GOBCOM     ;gobble comma
28FF: 20 AB 1D    >867           JSR   INPNUM     ;get record number
2902: 8E 20 DF    >868           STX   FLPOS+2    ;save rec number
2905: 8D 21 DF    >869           STA   FLPOS+3    
                  >870  
2908: A9 00       >871           LDA   #0         
290A: 8D 22 DF    >872           STA   FLPOS+4    ;default offset to 0
290D: 20 E4 16    >873           JSR   CHKBYT     
2910: C9 AC       >874           CMP   #","       
2912: D0 09 =291D >875           BNE   :DO_POS2   ;check for last arg...
                  >876  
2914: 20 F3 16    >877           JSR   GOBCOM     ;gobble comma
2917: 20 AB 1D    >878           JSR   INPNUM     
291A: 8E 22 DF    >879           STX   FLPOS+4    ;save byte offset
                  >880  
291D: AE 1E DF    >881  :DO_POS2 LDX   FLPOS      ;set up for multiply
2920: AD 1F DF    >882           LDA   FLPOS+1    
2923: 20 06 1E    >883           JSR   SAVNUMB    
                  >884  
2926: AD 20 DF    >885           LDA   FLPOS+2    
2929: 8D 25 DF    >886           STA   DATA+1     
292C: AD 21 DF    >887           LDA   FLPOS+3    
292F: 8D 26 DF    >888           STA   DATA+2     
                  >889  
2932: 20 E9 21    >890           JSR   DO_MUL0    
                  >891  
2935: 18          >892           CLC              
2936: AD 22 DF    >893           LDA   FLPOS+4    
2939: 6D 3F DF    >894           ADC   RESULT     
293C: AA          >895           TAX              ;save low (X)
293D: A9 00       >896           LDA   #0         ;compute med (A)
293F: 6D 40 DF    >897           ADC   RESULT+1   
2942: AC 41 DF    >898           LDY   RESULT+2   ;get high (Y)
2945: 4C D7 31    >899           JMP   SETPOS     
                  >900  
                  >901  *-------------------------------
                  >902  * read data from device into memory
                  >903  *-------------------------------
                  >904  
2948: 20 85 24    >905  DO_READ  JSR   GETDEV     
294B: BD C9 DC    >906           LDA   INPVEC,X   ;point to vector
294E: 85 56       >907           STA   VECTOR2    
2950: BD CA DC    >908           LDA   INPVEC+1,X 
2953: 85 57       >909           STA   VECTOR2+1  
                  >910  
2955: 20 AB 1D    >911           JSR   INPNUM     ;point to data
2958: 86 02       >912           STX   TEMP2      
295A: 85 03       >913           STA   TEMP2+1    
                  >914  
295C: 20 F3 16    >915           JSR   GOBCOM     ;gobble comma
295F: 20 AB 1D    >916           JSR   INPNUM     ;get length of read
                  >917  
2962: A0 00       >918           LDY   #0         
2964: 20 22 3B    >919  :DO_RD2  JSR   DO_INP     ;read data into memory
2967: 91 02       >920           STA   (TEMP2),Y  
2969: C8          >921           INY              
296A: CA          >922           DEX              
296B: D0 F7 =2964 >923           BNE   :DO_RD2    
296D: 60          >924           RTS              
                  >925  
                  >926  *-------------------------------
                  >927  * write data to a device
                  >928  *-------------------------------
                  >929  
296E: 20 85 24    >930  DO_WRIT  JSR   GETDEV     
2971: BD DF DC    >931           LDA   OUTVEC,X   ;set up vectors
2974: 85 15       >932           STA   VECTOR     
2976: BD E0 DC    >933           LDA   OUTVEC+1,X 
2979: 85 16       >934           STA   VECTOR+1   
                  >935  
297B: 20 AB 1D    >936           JSR   INPNUM     ;point to data
297E: 86 02       >937           STX   TEMP2      
2980: 85 03       >938           STA   TEMP2+1    
                  >939  
2982: 20 F3 16    >940           JSR   GOBCOM     ;gobble comma
2985: 20 AB 1D    >941           JSR   INPNUM     ;get length
                  >942  
2988: A0 00       >943           LDY   #0         
298A: B1 02       >944  :DO_WR2  LDA   (TEMP2),Y  ;write data
298C: 20 B5 37    >945           JSR   DO_OUT     
298F: C8          >946           INY              
2990: CA          >947           DEX              
2991: D0 F7 =298A >948           BNE   :DO_WR2    
2993: 60          >949           RTS              
                  >950  
                  >951  *-------------------------------
                  >952  * kill a file (or message)
                  >953  *-------------------------------
                  >954  
2994: 20 E4 16    >955  DO_KILL  JSR   CHKBYT     
2997: C9 A3       >956           CMP   #"#"       
2999: F0 06 =29A1 >957           BEQ   :KILL2     ;kill message?, yep
                  >958  
299B: 20 63 2F    >959           JSR   MOVNAME    ;get filename
299E: 4C 10 32    >960           JMP   DELFILE    ;delete file
                  >961  
29A1: 20 85 24    >962  :KILL2   JSR   GETDEV     ;get msg number
29A4: AE 5F DF    >963           LDX   MSGNUM     
29A7: AD 60 DF    >964           LDA   MSGNUM+1   
29AA: 20 D4 2A    >965           JSR   MSG        
                  >966  
29AD: A0 02       >967           LDY   #2         ;get first block into A & X
29AF: B1 00       >968           LDA   (TEMP),Y   
29B1: 48          >969           PHA              
29B2: C8          >970           INY              
29B3: B1 00       >971           LDA   (TEMP),Y   
29B5: 48          >972           PHA              
                  >973  
29B6: A9 00       >974           LDA   #0         
29B8: 91 00       >975           STA   (TEMP),Y   ;zero pointers
29BA: 88          >976           DEY              
29BB: 91 00       >977           STA   (TEMP),Y   
29BD: 88          >978           DEY              
29BE: 91 00       >979           STA   (TEMP),Y   
29C0: 88          >980           DEY              
29C1: 91 00       >981           STA   (TEMP),Y   
29C3: 20 F4 2D    >982           JSR   WRTDIR     ;write dir back to disk
                  >983  
29C6: 68          >984           PLA              ;get high
29C7: A8          >985           TAY              
29C8: 68          >986           PLA              ;get low
29C9: AA          >987           TAX              
29CA: 98          >988           TYA              
                  >989  
29CB: 8E 5F DF    >990  :KILL3   STX   MSGNUM     ;save block number
29CE: 8D 60 DF    >991           STA   MSGNUM+1   
29D1: 0D 5F DF    >992           ORA   MSGNUM     ;done?
29D4: F0 21 =29F7 >993           BEQ   :KILL4     ;yep
                  >994  
29D6: AD 60 DF    >995           LDA   MSGNUM+1   
29D9: 20 65 2D    >996           JSR   DEALLOC    ;de-alloc block
                  >997  
29DC: AE 5F DF    >998           LDX   MSGNUM     ;get block number
29DF: AD 60 DF    >999           LDA   MSGNUM+1   
29E2: 20 D7 2D    >1000          JSR   SETBLK     ;position to block
                  >1001 
29E5: A2 00       >1002          LDX   #<LNBUF    ;read in block
29E7: A9 02       >1003          LDA   #>LNBUF    
29E9: A0 01       >1004          LDY   #1         
29EB: 20 42 31    >1005          JSR   RDBLK      
                  >1006 
29EE: AE 7E 02    >1007          LDX   LNBUF+126  ;get next block number
29F1: AD 7F 02    >1008          LDA   LNBUF+127  
29F4: 4C CB 29    >1009          JMP   :KILL3     ;and repeat
                  >1010 
29F7: 20 C6 2D    >1011 :KILL4   JSR   WRTBIT     ;update bitmap
29FA: 4C 48 2A    >1012          JMP   FINISH     ;write out dir info
                  >1013 
                  >1014 *-------------------------------
                  >1015 * ready a message file
                  >1016 *-------------------------------
                  >1017 
29FD: 20 E4 16    >1018 DO_RDY   JSR   CHKBYT     ;do they want to ready a message?
2A00: C9 A3       >1019          CMP   #"#"       
2A02: D0 03 =2A07 >1020          BNE   :DO_RDY0   ;nope
                  >1021 
2A04: 4C 85 24    >1022          JMP   GETDEV     ;fix message
                  >1023 
2A07: AD 42 DF    >1024 :DO_RDY0 LDA   MSGREF     ;get back old refnum
2A0A: 8D CD 03    >1025          STA   REFNUM     
2A0D: F0 03 =2A12 >1026          BEQ   :DO_RDY1   ;file is closed
                  >1027 
2A0F: 20 D8 30    >1028          JSR   CLOSE      ;close old msgfile
                  >1029 
2A12: 20 63 2F    >1030 :DO_RDY1 JSR   MOVNAME    ;get msg-file name
2A15: AD 72 30    >1031          LDA   FLNAME     
2A18: F0 28 =2A42 >1032          BEQ   :DO_RDY3   ;they are done with it
                  >1033 
2A1A: A0 02       >1034          LDY   #2         ;use msgfile buffer
2A1C: 20 B8 30    >1035          JSR   BFOPEN     ;open file
2A1F: B0 22 =2A43 >1036          BCS   :DO_RDY4   ;hmmm, thats bad!
                  >1037 
2A21: AD CD 03    >1038          LDA   REFNUM     
2A24: 8D 42 DF    >1039          STA   MSGREF     ;save refnum
                  >1040 
2A27: A0 00       >1041          LDY   #0         
2A29: 20 1F 31    >1042 :DO_RDY2 JSR   RDBYTE     ;read in info
2A2C: 99 43 DF    >1043          STA   MSGINFO,Y  
2A2F: C8          >1044          INY              
2A30: C0 08       >1045          CPY   #8         
2A32: D0 F5 =2A29 >1046          BNE   :DO_RDY2   
                  >1047 
2A34: A9 FF       >1048          LDA   #-1        
2A36: 8D 5C DF    >1049          STA   DIRSEG     ;no dir or bit seg loaded
2A39: 8D 5E DF    >1050          STA   BITSEG     
2A3C: 8D 0C DF    >1051          STA   DEVUSE+6   
2A3F: 8D 0D DF    >1052          STA   DEVUSE+7   
2A42: 60          >1053 :DO_RDY3 RTS              
                  >1054 
2A43: A2 14       >1055 :DO_RDY4 LDX   #nomsg     ;message file not found
2A45: 4C E1 12    >1056          JMP   BADERR     
                  >1057 
2A48: AD 42 DF    >1058 FINISH   LDA   MSGREF     ;get refnum
2A4B: 8D CD 03    >1059          STA   REFNUM     
2A4E: A2 00       >1060          LDX   #0         
2A50: 8A          >1061          TXA              
2A51: 20 D5 31    >1062          JSR   SETMARK    
                  >1063 
2A54: A0 00       >1064          LDY   #0         
2A56: B9 43 DF    >1065 :FINISH2 LDA   MSGINFO,Y  ;write the info
2A59: 20 6A 31    >1066          JSR   WRBYTE     
2A5C: C8          >1067          INY              
2A5D: C0 08       >1068          CPY   #8         
2A5F: D0 F5 =2A56 >1069          BNE   :FINISH2   
2A61: 60          >1070          RTS              
                  >1071 
                  >1072 *-------------------------------
                  >1073 * get new message info (or number of messages)
                  >1074 *-------------------------------
                  >1075 
2A62: 20 8F 1E    >1076 DO_MSG   JSR   INPNARG    ;what message do they want to know about?
                  >1077 
2A65: 24 6B       >1078          BIT   IMMDEF     ;is this an assignment [msg(x)=] ?
2A67: 30 32 =2A9B >1079          BMI   :DO_MSG4   ;yep
                  >1080 
2A69: EC 47 DF    >1081          CPX   MSGINFO+4  
2A6C: D0 0E =2A7C >1082          BNE   :DO_MSG2   ;is it the last message?, nope
2A6E: CD 48 DF    >1083          CMP   MSGINFO+5  
2A71: D0 09 =2A7C >1084          BNE   :DO_MSG2   ;nope
                  >1085 
2A73: AE 49 DF    >1086          LDX   MSGINFO+6  ;we don't need to load the dir to find out
2A76: AD 4A DF    >1087          LDA   MSGINFO+7  
2A79: 4C 9A 21    >1088          JMP   DO_MATH    
                  >1089 
2A7C: 0D 28 DF    >1090 :DO_MSG2 ORA   NUMB       ;do they want the number of files?
2A7F: D0 09 =2A8A >1091          BNE   :DO_MSG3   ;nope
                  >1092 
2A81: AE 47 DF    >1093          LDX   MSGINFO+4  ;get number of files
2A84: AD 48 DF    >1094          LDA   MSGINFO+5  
2A87: 4C 9A 21    >1095          JMP   DO_MATH    
                  >1096 
2A8A: 20 FF 1D    >1097 :DO_MSG3 JSR   GETNUMB    ;get message number
2A8D: 20 D4 2A    >1098          JSR   MSG        ;get info
                  >1099 
2A90: A0 00       >1100          LDY   #0         
2A92: B1 00       >1101          LDA   (TEMP),Y   ;get new message # into a & x
2A94: AA          >1102          TAX              
2A95: C8          >1103          INY              
2A96: B1 00       >1104          LDA   (TEMP),Y   
2A98: 4C 9A 21    >1105          JMP   DO_MATH    ;finish up
                  >1106 
2A9B: 48          >1107 :DO_MSG4 PHA              ;save msg number
2A9C: 8A          >1108          TXA              
2A9D: 48          >1109          PHA              
                  >1110 
2A9E: 20 EF 16    >1111          JSR   GOBEQU     ;gobble
2AA1: 20 AB 1D    >1112          JSR   INPNUM     ;get number
                  >1113 
2AA4: 68          >1114          PLA              ;get back msg number
2AA5: AA          >1115          TAX              
2AA6: 68          >1116          PLA              
                  >1117 
2AA7: EC 47 DF    >1118          CPX   MSGINFO+4  
2AAA: D0 17 =2AC3 >1119          BNE   :DO_MSG5   ;is this last message?, nope
                  >1120 
2AAC: CD 48 DF    >1121          CMP   MSGINFO+5  
2AAF: D0 12 =2AC3 >1122          BNE   :DO_MSG5   ;check high, nope
                  >1123 
2AB1: 48          >1124          PHA              ;save a and x
2AB2: 8A          >1125          TXA              
2AB3: 48          >1126          PHA              
                  >1127 
2AB4: 20 FF 1D    >1128          JSR   GETNUMB    ;update highest new message
2AB7: 8E 49 DF    >1129          STX   MSGINFO+6  
2ABA: 8D 4A DF    >1130          STA   MSGINFO+7  
2ABD: 20 48 2A    >1131          JSR   FINISH     ;write info to disk
                  >1132 
2AC0: 68          >1133          PLA              ;restore a and x
2AC1: AA          >1134          TAX              
2AC2: 68          >1135          PLA              
                  >1136 
2AC3: 20 D4 2A    >1137 :DO_MSG5 JSR   MSG        ;position to info
                  >1138 
2AC6: 20 FF 1D    >1139          JSR   GETNUMB    ;get the new number
2AC9: A0 01       >1140          LDY   #1         
2ACB: 91 00       >1141          STA   (TEMP),Y   ;save new message number
2ACD: 88          >1142          DEY              
2ACE: 8A          >1143          TXA              
2ACF: 91 00       >1144          STA   (TEMP),Y   
2AD1: 4C F4 2D    >1145          JMP   WRTDIR     ;write dir back to disk
                  >1146 
                  >1147 *-------------------------------
                  >1148 * position and load directory for needed segment
                  >1149 * and setup pointers for needed entry
                  >1150 *-------------------------------
                  >1151 
2AD4: CA          >1152 MSG      DEX              ;msg = msg - 1
2AD5: E0 FF       >1153          CPX   #-1        
2AD7: D0 03 =2ADC >1154          BNE   :MSG1      
                  >1155 
2AD9: 38          >1156          SEC              
2ADA: E9 01       >1157          SBC   #1         
                  >1158 
2ADC: 86 00       >1159 :MSG1    STX   TEMP       ;save msg number
2ADE: 86 02       >1160          STX   TEMP2      
                  >1161 
2AE0: 06 02       >1162          ASL   TEMP2      ;compute dir section number
2AE2: 2A          >1163          ROL              
2AE3: 0A          >1164          ASL              ;a = a * 4
2AE4: 0A          >1165          ASL              ;make A into actual block number
2AE5: CD 5C DF    >1166          CMP   DIRSEG     
2AE8: F0 16 =2B00 >1167          BEQ   :MSG2      
                  >1168 
2AEA: 8D 5C DF    >1169          STA   DIRSEG     ;save loaded dir seg number
2AED: 18          >1170          CLC              
2AEE: 6D 43 DF    >1171          ADC   MSGINFO    ;add in dir offset
                  >1172 
2AF1: AA          >1173          TAX              
2AF2: A9 00       >1174          LDA   #0         ;we have starting block
2AF4: 20 82 31    >1175          JSR   POSMSG     ;position for read
                  >1176 
2AF7: A2 00       >1177          LDX   #<DIRBUF   ;point to buffer
2AF9: A9 B9       >1178          LDA   #>DIRBUF   
2AFB: A0 04       >1179          LDY   #4         ;read 4 blocks
2AFD: 20 42 31    >1180          JSR   RDBLK      
                  >1181 
2B00: A5 00       >1182 :MSG2    LDA   TEMP       ;get msg number
2B02: 0A          >1183          ASL              
2B03: 0A          >1184          ASL              ;a = a * 4
2B04: 85 00       >1185          STA   TEMP       
2B06: A9 00       >1186          LDA   #0         ;put last bit into a
2B08: 2A          >1187          ROL              
2B09: 18          >1188          CLC              
2B0A: 69 B9       >1189          ADC   #>DIRBUF   ;add in location of buffer
2B0C: 85 01       >1190          STA   TEMP+1     
2B0E: 60          >1191          RTS              ;all is set up
                  >1192 
                  >1193 *-------------------------------
                  >1194 * read a mail file
                  >1195 *-------------------------------
                  >1196 
2B0F: 24 1F       >1197 RDMAIL   BIT   DEVCLR     ;is this start?
2B11: 30 11 =2B24 >1198          BMI   :RDMAIL2   ;nope
                  >1199 
2B13: 86 62       >1200          STX   BUF_X      ;save x
2B15: A2 04       >1201          LDX   #4         
2B17: BD 4B DF    >1202 :RDMAIL1 LDA   MSGPTR,X   
2B1A: 9D 57 DF    >1203          STA   RWDPTR,X   ;copy all 5 bytes
2B1D: CA          >1204          DEX              
2B1E: 10 F7 =2B17 >1205          BPL   :RDMAIL1   ;loop
                  >1206 
2B20: A6 62       >1207          LDX   BUF_X      
2B22: C6 1F       >1208          DEC   DEVCLR     ;clear change
2B24: 4C A1 2B    >1209 :RDMAIL2 JMP   RDMSG      
                  >1210 
                  >1211 *-------------------------------
                  >1212 * rewind file to previous spot
                  >1213 *-------------------------------
                  >1214 
2B27: AE 5A DF    >1215 DO_RWD   LDX   RWDBLK     ;get old block number
2B2A: AD 5B DF    >1216          LDA   RWDBLK+1   
                  >1217 
2B2D: EC 4E DF    >1218          CPX   RMXBLK     
2B30: D0 05 =2B37 >1219          BNE   :DO_RWD1   ;check low, nope
                  >1220 
2B32: CD 4F DF    >1221          CMP   RMXBLK+1   
2B35: F0 12 =2B49 >1222          BEQ   :DO_RWD2   ;check high, yep, it's the same
                  >1223 
2B37: 8E 4E DF    >1224 :DO_RWD1 STX   RMXBLK     ;update
2B3A: 8D 4F DF    >1225          STA   RMXBLK+1   
                  >1226 
2B3D: 20 D7 2D    >1227          JSR   SETBLK     ;point to block
2B40: A2 00       >1228          LDX   #<BLKBUF   ;read block back in
2B42: A9 B8       >1229          LDA   #>BLKBUF   
2B44: A0 01       >1230          LDY   #1         
2B46: 20 42 31    >1231          JSR   RDBLK      
                  >1232 
2B49: AD 57 DF    >1233 :DO_RWD2 LDA   RWDPTR     
2B4C: 8D 4B DF    >1234          STA   MSGPTR     ;move pointers
2B4F: AD 58 DF    >1235          LDA   RWDBYT8    
2B52: 8D 4C DF    >1236          STA   BYTE8      
2B55: AD 59 DF    >1237          LDA   RWDCHR8    
2B58: 8D 4D DF    >1238          STA   CHAR8      
2B5B: 60          >1239          RTS              
                  >1240 
                  >1241 * setup message for read
                  >1242 
2B5C: A9 FF       >1243 SETMSG   LDA   #-1        
2B5E: 8D 63 DF    >1244          STA   MSGINIT    ;init message base
2B61: AE 5F DF    >1245          LDX   MSGNUM     ;get message number
2B64: AD 60 DF    >1246          LDA   MSGNUM+1   
2B67: 20 D4 2A    >1247          JSR   MSG        ;locate message
                  >1248 
2B6A: A0 02       >1249          LDY   #2         ;get starting block number
2B6C: B1 00       >1250          LDA   (TEMP),Y   
2B6E: AA          >1251          TAX              
2B6F: C8          >1252          INY              
2B70: 11 00       >1253          ORA   (TEMP),Y   ;check for no data...
2B72: D0 03 =2B77 >1254          BNE   SETMSGX    
2B74: 4C EE 2B    >1255          JMP   SETMSG2    
                  >1256 
2B77: B1 00       >1257 SETMSGX  LDA   (TEMP),Y   
2B79: 8E 4E DF    >1258 SETMSG1  STX   RMXBLK     ;save current block number
2B7C: 8D 4F DF    >1259          STA   RMXBLK+1   
2B7F: 20 D7 2D    >1260          JSR   SETBLK     ;position and translate
                  >1261 
2B82: A9 00       >1262          LDA   #0         
2B84: 8D 50 DF    >1263          STA   RDEND      ;reset end pointer
2B87: 8D 00 B8    >1264          STA   BLKBUF     
2B8A: A2 00       >1265          LDX   #<BLKBUF   ;and read data
2B8C: A9 B8       >1266          LDA   #>BLKBUF   
2B8E: A0 01       >1267          LDY   #1         
2B90: 20 42 31    >1268          JSR   RDBLK      
                  >1269 
2B93: A0 00       >1270          LDY   #0         
2B95: 8C 4B DF    >1271          STY   MSGPTR     ;reset pointer
2B98: A9 06       >1272          LDA   #6         
2B9A: 8D 4C DF    >1273          STA   BYTE8      ;reset hidden byte counter
2B9D: A6 58       >1274          LDX   MSG_X      ;get back x and y
2B9F: A4 59       >1275          LDY   MSG_Y      
                  >1276 
                  >1277 * ... fall through and read a byte ...
                  >1278 
                  >1279 *-------------------------------
                  >1280 * read a byte of message
                  >1281 *-------------------------------
                  >1282 
2BA1: 86 58       >1283 RDMSG    STX   MSG_X      ;save both x and y
2BA3: 84 59       >1284          STY   MSG_Y      
                  >1285 
2BA5: 2C 63 DF    >1286          BIT   MSGINIT    ;is read in progress?
2BA8: 10 B2 =2B5C >1287          BPL   SETMSG     ;nope, start it
                  >1288 
2BAA: 2C 50 DF    >1289          BIT   RDEND      ;at end of data?
2BAD: 30 3F =2BEE >1290          BMI   SETMSG2    ;yep
                  >1291 
2BAF: 2C 4C DF    >1292          BIT   BYTE8      ;check for hidden byte
2BB2: 30 1A =2BCE >1293          BMI   RDMSG2     ;do it
                  >1294 
2BB4: AC 4B DF    >1295          LDY   MSGPTR     ;get index
2BB7: C0 7E       >1296          CPY   #126       
2BB9: F0 21 =2BDC >1297          BEQ   RDMSG3     ;need more data?, yep
                  >1298 
2BBB: B9 00 B8    >1299          LDA   BLKBUF,Y   ;get byte
2BBE: 0A          >1300          ASL              ;put extra bit into carry
2BBF: F0 2A =2BEB >1301          BEQ   RDMSG4     ;opps, end of data
2BC1: 6E 4D DF    >1302          ROR   CHAR8      ;put carry into hidden byte
2BC4: 4A          >1303          LSR              ;fix byte
2BC5: EE 4B DF    >1304          INC   MSGPTR     ;inc pointer
2BC8: CE 4C DF    >1305          DEC   BYTE8      ;count down for hidden byte
2BCB: 4C F0 2B    >1306          JMP   SETMSG3    
                  >1307 
2BCE: AD 4D DF    >1308 RDMSG2   LDA   CHAR8      ;get hidden byte
2BD1: 4A          >1309          LSR              ;fix
2BD2: F0 17 =2BEB >1310          BEQ   RDMSG4     
                  >1311 
2BD4: A2 06       >1312          LDX   #6         
2BD6: 8E 4C DF    >1313          STX   BYTE8      ;reset hidden byte counter
2BD9: 4C F0 2B    >1314          JMP   SETMSG3    
                  >1315 
2BDC: AD 7E B8    >1316 RDMSG3   LDA   BLKBUF+126 
2BDF: AA          >1317          TAX              
2BE0: 0D 7F B8    >1318          ORA   BLKBUF+127 ;is next block 0?
2BE3: F0 06 =2BEB >1319          BEQ   RDMSG4     ;yep
                  >1320 
2BE5: AD 7F B8    >1321          LDA   BLKBUF+127 
2BE8: 4C 79 2B    >1322          JMP   SETMSG1    ;read next block
                  >1323 
2BEB: CE 50 DF    >1324 RDMSG4   DEC   RDEND      ;at end of data
                  >1325 
2BEE: A9 00       >1326 SETMSG2  LDA   #0         ;opps, no data
2BF0: A6 58       >1327 SETMSG3  LDX   MSG_X      ;get back data
2BF2: A4 59       >1328          LDY   MSG_Y      
2BF4: 60          >1329          RTS              
                  >1330 
                  >1331 *-------------------------------
                  >1332 * setup message for write
                  >1333 *-------------------------------
                  >1334 
2BF5: AE 5F DF    >1335 WRTMSG   LDX   MSGNUM     ;get msg number
2BF8: AD 60 DF    >1336          LDA   MSGNUM+1   
                  >1337 
2BFB: CD 48 DF    >1338          CMP   MSGINFO+5  
2BFE: F0 04 =2C04 >1339          BEQ   WRTMSG0    
2C00: 90 0D =2C0F >1340          BLT   WRTMSG1    
2C02: B0 05 =2C09 >1341          BGE   WRTMSG5    ;is the meessage file this big?
                  >1342 
2C04: EC 47 DF    >1343 WRTMSG0  CPX   MSGINFO+4  
2C07: 90 06 =2C0F >1344          BLT   WRTMSG1    
                  >1345 
2C09: 8E 47 DF    >1346 WRTMSG5  STX   MSGINFO+4  ;update message count
2C0C: 8D 48 DF    >1347          STA   MSGINFO+5  
                  >1348 
2C0F: 20 D4 2A    >1349 WRTMSG1  JSR   MSG        ;locate message
2C12: A0 02       >1350          LDY   #2         
2C14: B1 00       >1351          LDA   (TEMP),Y   
2C16: C8          >1352          INY              
2C17: 11 00       >1353          ORA   (TEMP),Y   
2C19: D0 25 =2C40 >1354          BNE   WRTMSG2    
                  >1355 
2C1B: 20 0A 2D    >1356          JSR   ALLOC      ;allocate new block
                  >1357 
2C1E: 8E 54 DF    >1358          STX   WRKBLK     ;update block number
2C21: 8D 55 DF    >1359          STA   WRKBLK+1   
                  >1360 
2C24: A0 03       >1361          LDY   #3         
2C26: 91 00       >1362          STA   (TEMP),Y   
2C28: 88          >1363          DEY              
2C29: 8A          >1364          TXA              
2C2A: 91 00       >1365          STA   (TEMP),Y   
2C2C: 20 F4 2D    >1366          JSR   WRTDIR     ;write dir back to disk
                  >1367 
2C2F: A6 58       >1368          LDX   MSG_X      
2C31: CE 63 DF    >1369          DEC   MSGINIT    ;init msg
2C34: A9 06       >1370          LDA   #6         
2C36: 8D 52 DF    >1371          STA   BYTE82     ;init byte counter
2C39: A9 00       >1372          LDA   #0         
2C3B: 8D 51 DF    >1373          STA   MSGPTR2    ;init message pointer
2C3E: F0 23 =2C63 >1374          BEQ   WRTMSG4    
                  >1375 
2C40: AD 5E DF    >1376 WRTMSG2  LDA   BITSEG     ;bitmap loaded?
2C43: C9 FF       >1377          CMP   #-1        
2C45: D0 0B =2C52 >1378          BNE   WRTMSG2A   ;yes
                  >1379 
2C47: A0 02       >1380          LDY   #2         ;read in bitmap
2C49: B1 00       >1381          LDA   (TEMP),Y   
2C4B: AA          >1382          TAX              
2C4C: C8          >1383          INY              
2C4D: B1 00       >1384          LDA   (TEMP),Y   
2C4F: 20 8B 2D    >1385          JSR   GETBITS    
                  >1386 
2C52: 20 16 2E    >1387 WRTMSG2A JSR   SWPBLK     ;swap pointers
2C55: A6 58       >1388          LDX   MSG_X      ;restore x and y
2C57: A4 59       >1389          LDY   MSG_Y      
                  >1390 
2C59: 20 A1 2B    >1391 WRTMSG3  JSR   RDMSG      ;do append to current data
2C5C: C9 00       >1392          CMP   #0         
2C5E: D0 F9 =2C59 >1393          BNE   WRTMSG3    
                  >1394 
2C60: 20 16 2E    >1395          JSR   SWPBLK     ;swap back
2C63: A4 59       >1396 WRTMSG4  LDY   MSG_Y      
2C65: A9 00       >1397          LDA   #0         
2C67: 8D 56 DF    >1398          STA   WRTEND     ;let them write data
                  >1399 
2C6A: A6 58       >1400 WRTMSG6  LDX   MSG_X      ;get back parms
2C6C: A4 59       >1401          LDY   MSG_Y      
2C6E: 68          >1402          PLA              
                  >1403 
                  >1404 * ... fall througn and write byte ...
                  >1405 
                  >1406 *-------------------------------
                  >1407 * write a byte to a message
                  >1408 *-------------------------------
                  >1409 
2C6F: 48          >1410 WRMSG    PHA              
2C70: 86 58       >1411          STX   MSG_X      ;save x and y
2C72: 84 59       >1412          STY   MSG_Y      
                  >1413 
2C74: 2C 63 DF    >1414          BIT   MSGINIT    ;have we started?
2C77: 30 03 =2C7C >1415          BMI   WRMSG0A    
2C79: 4C F5 2B    >1416          JMP   WRTMSG     ;nope
                  >1417 
2C7C: 2C 56 DF    >1418 WRMSG0A  BIT   WRTEND     ;has end been written?
2C7F: 30 67 =2CE8 >1419          BMI   WRMSG1B    ;yep, take no more
                  >1420 
2C81: 2C 52 DF    >1421          BIT   BYTE82     ;check for hidden byte
2C84: 30 64 =2CEA >1422          BMI   WRMSG2     ;add it
                  >1423 
2C86: AC 51 DF    >1424          LDY   MSGPTR2    ;get index
2C89: C0 7E       >1425          CPY   #126       
2C8B: F0 18 =2CA5 >1426          BEQ   WRMSG1     ;allocate new block?, yep
                  >1427 
2C8D: 99 80 B8    >1428          STA   BLKBUF2,Y  ;save data and continue
2C90: EE 51 DF    >1429          INC   MSGPTR2    
2C93: CE 52 DF    >1430          DEC   BYTE82     ;count down hidden byte
2C96: C9 00       >1431          CMP   #0         
2C98: D0 6A =2D04 >1432          BNE   WRMSG4     
                  >1433 
2C9A: A2 00       >1434 WRMSG0   LDX   #0         
2C9C: 8E FE B8    >1435          STX   BLKBUF2+126 ;no link
2C9F: 8E FF B8    >1436          STX   BLKBUF2+127 
2CA2: 4C AE 2C    >1437          JMP   WRMSG1A    ;skip around link setup
                  >1438 
2CA5: 20 0A 2D    >1439 WRMSG1   JSR   ALLOC      ;allocate new block
2CA8: 8E FE B8    >1440          STX   BLKBUF2+126 
2CAB: 8D FF B8    >1441          STA   BLKBUF2+127 
                  >1442 
2CAE: AE 54 DF    >1443 WRMSG1A  LDX   WRKBLK     ;translate and position block
2CB1: AD 55 DF    >1444          LDA   WRKBLK+1   
2CB4: 20 D7 2D    >1445          JSR   SETBLK     
                  >1446 
2CB7: A2 80       >1447          LDX   #<BLKBUF2  ;write the block
2CB9: A9 B8       >1448          LDA   #>BLKBUF2  
2CBB: A0 01       >1449          LDY   #1         
2CBD: 20 38 31    >1450          JSR   WRBLK      
                  >1451 
2CC0: A9 00       >1452          LDA   #0         
2CC2: 8D 51 DF    >1453          STA   MSGPTR2    ;reset pointer
2CC5: A9 06       >1454          LDA   #6         
2CC7: 8D 52 DF    >1455          STA   BYTE82     ;reset hidden counter
                  >1456 
2CCA: AD FE B8    >1457          LDA   BLKBUF2+126 ;save new block number
2CCD: 8D 54 DF    >1458          STA   WRKBLK     
2CD0: AD FF B8    >1459          LDA   BLKBUF2+127 
2CD3: 8D 55 DF    >1460          STA   WRKBLK+1   
2CD6: 0D 54 DF    >1461          ORA   WRKBLK     ;is there another block?
2CD9: D0 8F =2C6A >1462          BNE   WRTMSG6    ;yep
                  >1463 
2CDB: 20 C6 2D    >1464          JSR   WRTBIT     ;write out bitmap
2CDE: 20 48 2A    >1465          JSR   FINISH     ;write out info
2CE1: CE 56 DF    >1466          DEC   WRTEND     ;end has been written
2CE4: A6 58       >1467          LDX   MSG_X      
2CE6: A4 59       >1468          LDY   MSG_Y      
2CE8: 68          >1469 WRMSG1B  PLA              
2CE9: 60          >1470          RTS              
                  >1471 
2CEA: AE 51 DF    >1472 WRMSG2   LDX   MSGPTR2    
2CED: A0 07       >1473          LDY   #7         
2CEF: 0A          >1474          ASL              
2CF0: CA          >1475 WRMSG3   DEX              
2CF1: 3E 80 B8    >1476          ROL   BLKBUF2,X  ;add in bit 7
2CF4: 0A          >1477          ASL              
2CF5: 7E 80 B8    >1478          ROR   BLKBUF2,X  
2CF8: 88          >1479          DEY              
2CF9: D0 F5 =2CF0 >1480          BNE   WRMSG3     
                  >1481 
2CFB: A2 06       >1482          LDX   #6         
2CFD: 8E 52 DF    >1483          STX   BYTE82     
2D00: 68          >1484          PLA              ;get back byte
2D01: 48          >1485          PHA              
2D02: F0 96 =2C9A >1486          BEQ   WRMSG0     
                  >1487 
2D04: A6 58       >1488 WRMSG4   LDX   MSG_X      ;restore x and y
2D06: A4 59       >1489          LDY   MSG_Y      
2D08: 68          >1490          PLA              
2D09: 60          >1491          RTS              
                  >1492 
                  >1493 *-------------------------------
                  >1494 * allocate a block for data
                  >1495 *-------------------------------
                  >1496 
2D0A: AD 5E DF    >1497 ALLOC    LDA   BITSEG     ;fresh start?
2D0D: C9 FF       >1498          CMP   #$FF       
2D0F: F0 17 =2D28 >1499          BEQ   :ALLOC4    ;yep
                  >1500 
2D11: A0 00       >1501          LDY   #0         ;start count
2D13: A2 00       >1502 :ALLOC2  LDX   #0         
2D15: B9 80 B7    >1503 :ALLOC3  LDA   BITBUF,Y   ;search for free block
2D18: 3D 6F 3E    >1504          AND   BITVAL,X   
2D1B: F0 14 =2D31 >1505          BEQ   :ALLOC5    ;found one
                  >1506 
2D1D: E8          >1507          INX              ;done with byte?
2D1E: E0 08       >1508          CPX   #8         
2D20: D0 F3 =2D15 >1509          BNE   :ALLOC3    ;nope
2D22: C8          >1510          INY              
2D23: 10 EE =2D13 >1511          BPL   :ALLOC2    ;done with buffer?, nope
                  >1512 
2D25: 20 C6 2D    >1513          JSR   WRTBIT     ;write bit map back to disk
                  >1514 
2D28: EE 5E DF    >1515 :ALLOC4  INC   BITSEG     ;is there more space?
2D2B: 20 B5 2D    >1516          JSR   RDBIT      ;read in bit map segment
2D2E: 4C 0A 2D    >1517          JMP   ALLOC      ;start (keep) looking
                  >1518 
2D31: B9 80 B7    >1519 :ALLOC5  LDA   BITBUF,Y   
2D34: 1D 6F 3E    >1520          ORA   BITVAL,X   ;mark byte
2D37: 99 80 B7    >1521          STA   BITBUF,Y   
                  >1522 
2D3A: 84 02       >1523          STY   TEMP2      ;shift Y into 16 bits
2D3C: A9 00       >1524          LDA   #0         ;bit16 = y * 8
2D3E: 06 02       >1525          ASL   TEMP2      
2D40: 2A          >1526          ROL              
2D41: 06 02       >1527          ASL   TEMP2      
2D43: 2A          >1528          ROL              
2D44: 06 02       >1529          ASL   TEMP2      
2D46: 2A          >1530          ROL              
2D47: 85 03       >1531          STA   TEMP2+1    
                  >1532 
2D49: 8A          >1533          TXA              ;add in x
2D4A: 38          >1534          SEC              ;special (+1)
2D4B: 65 02       >1535          ADC   TEMP2      ;bit16 = bit16 + x + 1
2D4D: AA          >1536          TAX              
2D4E: A9 00       >1537          LDA   #0         
2D50: 65 03       >1538          ADC   TEMP2+1    
2D52: 85 03       >1539          STA   TEMP2+1    
                  >1540 
2D54: AD 5E DF    >1541          LDA   BITSEG     ;add in segment
2D57: 0A          >1542          ASL              
2D58: 0A          >1543          ASL              ;a = a * 4
2D59: 18          >1544          CLC              
2D5A: 65 03       >1545          ADC   TEMP2+1    ;bit16 = bit16 + a
                  >1546 
2D5C: EE 45 DF    >1547          INC   MSGINFO+2  
2D5F: D0 03 =2D64 >1548          BNE   :ALLOC6    ;add 1 to used blocks
2D61: EE 46 DF    >1549          INC   MSGINFO+3  
2D64: 60          >1550 :ALLOC6  RTS              
                  >1551 
                  >1552 *-------------------------------
                  >1553 * de-alloc
                  >1554 *-------------------------------
                  >1555 
2D65: 20 8B 2D    >1556 DEALLOC  JSR   GETBITS    
                  >1557 
2D68: A5 00       >1558          LDA   TEMP       ;shift down temp 3 bits into A
2D6A: 46 01       >1559          LSR   TEMP+1     
2D6C: 6A          >1560          ROR              
2D6D: 46 01       >1561          LSR   TEMP+1     
2D6F: 6A          >1562          ROR              
2D70: 4A          >1563          LSR              
2D71: A8          >1564          TAY              
                  >1565 
2D72: A6 02       >1566          LDX   TEMP2      ;get bit offset
2D74: BD 6F 3E    >1567          LDA   BITVAL,X   
2D77: 49 FF       >1568          EOR   #$FF       
2D79: 39 80 B7    >1569          AND   BITBUF,Y   ;clear bit
2D7C: 99 80 B7    >1570          STA   BITBUF,Y   ;and save
                  >1571 
2D7F: AD 45 DF    >1572          LDA   MSGINFO+2  ;used blocks = used blocks -1
2D82: D0 03 =2D87 >1573          BNE   :DEALL3    
2D84: CE 46 DF    >1574          DEC   MSGINFO+3  
2D87: CE 45 DF    >1575 :DEALL3  DEC   MSGINFO+2  
2D8A: 60          >1576          RTS              
                  >1577 
                  >1578 * read in bitmap, save old one (if any)
                  >1579 
2D8B: 38          >1580 GETBITS  SEC              
2D8C: 48          >1581          PHA              
2D8D: 8A          >1582          TXA              
2D8E: E9 01       >1583          SBC   #1         
2D90: 85 00       >1584          STA   TEMP       
2D92: 29 07       >1585          AND   #%00000111 
2D94: 85 02       >1586          STA   TEMP2      ;save offset (in bits)
2D96: 68          >1587          PLA              
2D97: E9 00       >1588          SBC   #0         
2D99: 85 01       >1589          STA   TEMP+1     ;temp = (AX)-1
                  >1590 
2D9B: 4A          >1591          LSR              
2D9C: 4A          >1592          LSR              ;a = a / 4
                  >1593 
2D9D: CD 5E DF    >1594          CMP   BITSEG     
2DA0: F0 12 =2DB4 >1595          BEQ   :DEALL2    ;are we in position?, yep
                  >1596 
2DA2: 48          >1597          PHA              
2DA3: AD 5E DF    >1598          LDA   BITSEG     ;first access to bitmap?
2DA6: C9 FF       >1599          CMP   #$FF       
2DA8: F0 03 =2DAD >1600          BEQ   :DEALL1    ;yep, done write
                  >1601 
2DAA: 20 C6 2D    >1602          JSR   WRTBIT     ;hmmm, write out current bitmap
2DAD: 68          >1603 :DEALL1  PLA              
2DAE: 8D 5E DF    >1604          STA   BITSEG     ;update segment
2DB1: 20 B5 2D    >1605          JSR   RDBIT      ;read bit map
2DB4: 60          >1606 :DEALL2  RTS              
                  >1607 
                  >1608 * read bit map from disk
                  >1609 
2DB5: AE 5E DF    >1610 RDBIT    LDX   BITSEG     
2DB8: A9 00       >1611          LDA   #0         
2DBA: 20 82 31    >1612          JSR   POSMSG     ;position to block
                  >1613 
2DBD: A2 80       >1614          LDX   #<BITBUF   ;read in block
2DBF: A9 B7       >1615          LDA   #>BITBUF   
2DC1: A0 01       >1616          LDY   #1         
2DC3: 4C 42 31    >1617          JMP   RDBLK      
                  >1618 
                  >1619 * write bit map back to disk
                  >1620 
2DC6: AE 5E DF    >1621 WRTBIT   LDX   BITSEG     ;position to block
2DC9: A9 00       >1622          LDA   #0         
2DCB: 20 82 31    >1623          JSR   POSMSG     
                  >1624 
2DCE: A2 80       >1625          LDX   #<BITBUF   ;write current block out
2DD0: A9 B7       >1626          LDA   #>BITBUF   
2DD2: A0 01       >1627          LDY   #1         
2DD4: 4C 38 31    >1628          JMP   WRBLK      
                  >1629 
                  >1630 *-------------------------------
                  >1631 * position to false block number
                  >1632 *-------------------------------
                  >1633 
2DD7: 8E 61 DF    >1634 SETBLK   STX   POSBLK     ;save block number
2DDA: 8D 62 DF    >1635          STA   POSBLK+1   
2DDD: 18          >1636          CLC              
2DDE: AD 43 DF    >1637          LDA   MSGINFO    ;a = msginfo + msginfo(1)
2DE1: 6D 44 DF    >1638          ADC   MSGINFO+1  
2DE4: 38          >1639          SEC              ;a = a - 1
2DE5: E9 01       >1640          SBC   #1         
2DE7: 18          >1641          CLC              
2DE8: 6D 61 DF    >1642          ADC   POSBLK     ;blk = blk + a
2DEB: AA          >1643          TAX              
2DEC: AD 62 DF    >1644          LDA   POSBLK+1   
2DEF: 69 00       >1645          ADC   #0         
2DF1: 4C 82 31    >1646          JMP   POSMSG     
                  >1647 
                  >1648 *-------------------------------
                  >1649 * write the current directory segment back to disk
                  >1650 *-------------------------------
                  >1651 
2DF4: 18          >1652 WRTDIR   CLC              
2DF5: AD 5C DF    >1653          LDA   DIRSEG     ;position to dir segment
2DF8: 6D 43 DF    >1654          ADC   MSGINFO    
2DFB: AA          >1655          TAX              
2DFC: A9 00       >1656          LDA   #0         
2DFE: 20 82 31    >1657          JSR   POSMSG     
                  >1658 
2E01: 38          >1659          SEC              
2E02: AD 44 DF    >1660          LDA   MSGINFO+1  ;get # of dir blocks
2E05: ED 5C DF    >1661          SBC   DIRSEG     ;subtract current pointer
2E08: C9 04       >1662          CMP   #4         
2E0A: 90 02 =2E0E >1663          BLT   :WRTDIR1   ;there are less than 4 blocks left
2E0C: A9 04       >1664          LDA   #4         ;there are more - only write 4
                  >1665 
2E0E: A8          >1666 :WRTDIR1 TAY              ;# of blocks to write
2E0F: A2 00       >1667          LDX   #<DIRBUF   ;write it
2E11: A9 B9       >1668          LDA   #>DIRBUF   
2E13: 4C 38 31    >1669          JMP   WRBLK      
                  >1670 
                  >1671 *-------------------------------
                  >1672 * switch block buffers
                  >1673 *-------------------------------
                  >1674 
2E16: A0 7F       >1675 SWPBLK   LDY   #127       
2E18: B9 00 B8    >1676 :SWPBLK2 LDA   BLKBUF,Y   ;get buf 1 char
2E1B: 48          >1677          PHA              ;save
2E1C: B9 80 B8    >1678          LDA   BLKBUF2,Y  
2E1F: 99 00 B8    >1679          STA   BLKBUF,Y   ;get buf 2 char, put in buf 1
2E22: 68          >1680          PLA              
2E23: 99 80 B8    >1681          STA   BLKBUF2,Y  ;restore buf 1 char, put in buf 2
2E26: 88          >1682          DEY              
2E27: 10 EF =2E18 >1683          BPL   :SWPBLK2   ;loop
                  >1684 
2E29: A0 05       >1685          LDY   #5         
2E2B: B9 4B DF    >1686 :SWPBLK3 LDA   MSGPTR,Y   ;swap pointers
2E2E: 48          >1687          PHA              
2E2F: B9 51 DF    >1688          LDA   MSGPTR2,Y  
2E32: 99 4B DF    >1689          STA   MSGPTR,Y   
2E35: 68          >1690          PLA              
2E36: 99 51 DF    >1691          STA   MSGPTR2,Y  
2E39: 88          >1692          DEY              
2E3A: 10 EF =2E2B >1693          BPL   :SWPBLK3   
2E3C: 60          >1694          RTS              
                  >1695 
                  >1696 *-------------------------------
                  >1697 * create a file
                  >1698 *-------------------------------
                  >1699 
2E3D: 20 63 2F    >1700 DO_MAKE  JSR   MOVNAME    ;get filename
2E40: A0 04       >1701          LDY   #4         ;TEXT
2E42: A9 00       >1702          LDA   #<notype   ;clear auxtype
2E44: A2 00       >1703          LDX   #>notype   
2E46: 4C 88 30    >1704          JMP   CREATE     ;create it
                  >1705 
                  >1706 *-------------------------------
                  >1707 * crunch a message file
                  >1708 *-------------------------------
                  >1709 
2E49: A2 FF       >1710 DO_CNCH  LDX   #$FF       
2E4B: 8E 5C DF    >1711          STX   DIRSEG     
2E4E: 8E 5D DF    >1712          STX   DIRSEG+1   ;load in first dir block
2E51: E8          >1713          INX              
2E52: 8E 47 DF    >1714          STX   MSGINFO+4  ;reset number of msg's
2E55: 8E 48 DF    >1715          STX   MSGINFO+5  
2E58: A2 80       >1716          LDX   #128       
2E5A: A0 80       >1717          LDY   #128       
                  >1718 
2E5C: E0 80       >1719 :CRUNCH2 CPX   #128       
2E5E: F0 16 =2E76 >1720          BEQ   :CRUNCH3   ;at end of block?
                  >1721 
2E60: AD 5C DF    >1722          LDA   DIRSEG     ;more data?
2E63: CD 44 DF    >1723          CMP   MSGINFO+1  
2E66: F0 36 =2E9E >1724          BEQ   :CRUNCH7   ;yep
                  >1725 
2E68: BD 02 B9    >1726          LDA   DIRBUF+2,X ;is there any entry?
2E6B: 1D 03 B9    >1727          ORA   DIRBUF+3,X 
2E6E: D0 3C =2EAC >1728          BNE   :CRUNCH4   ;yep
                  >1729 
2E70: E8          >1730          INX              ;x = x + 4
2E71: E8          >1731          INX              
2E72: E8          >1732          INX              
2E73: E8          >1733          INX              
2E74: 10 E6 =2E5C >1734          BPL   :CRUNCH2   ;keep going until 128 done
                  >1735 
2E76: EE 5C DF    >1736 :CRUNCH3 INC   DIRSEG     
2E79: A2 00       >1737          LDX   #0         
2E7B: AD 5C DF    >1738          LDA   DIRSEG     ;are we done?
2E7E: CD 44 DF    >1739          CMP   MSGINFO+1  
2E81: F0 D9 =2E5C >1740          BEQ   :CRUNCH2   ;yep
                  >1741 
2E83: 84 07       >1742          STY   SAVE_Y     ;save Y
2E85: 18          >1743          CLC              
2E86: 6D 43 DF    >1744          ADC   MSGINFO    ;add in bitmap offset
2E89: AA          >1745          TAX              
2E8A: A9 00       >1746          LDA   #0         
2E8C: 20 82 31    >1747          JSR   POSMSG     ;position
                  >1748 
2E8F: A2 00       >1749          LDX   #<DIRBUF   ;read next dir block
2E91: A9 B9       >1750          LDA   #>DIRBUF   
2E93: A0 01       >1751          LDY   #1         
2E95: 20 42 31    >1752          JSR   RDBLK      
                  >1753 
2E98: A4 07       >1754          LDY   SAVE_Y     ;restore Y
2E9A: A2 00       >1755          LDX   #0         
2E9C: F0 BE =2E5C >1756          BEQ   :CRUNCH2   ;keep going
                  >1757 
2E9E: A2 00       >1758 :CRUNCH7 LDX   #0         
2EA0: 8E 00 B9    >1759          STX   DIRBUF     ;use 0 offset
2EA3: 8E 01 B9    >1760          STX   DIRBUF+1   
2EA6: 8E 02 B9    >1761          STX   DIRBUF+2   ;zero pointers
2EA9: 8E 03 B9    >1762          STX   DIRBUF+3   
                  >1763 
2EAC: C0 80       >1764 :CRUNCH4 CPY   #128       
2EAE: F0 39 =2EE9 >1765          BEQ   :CRUNCH6   ;at end of block?, yep
                  >1766 
2EB0: AD 5C DF    >1767 :CRUNCH5 LDA   DIRSEG     ;are we at end?
2EB3: CD 44 DF    >1768          CMP   MSGINFO+1  
2EB6: F0 31 =2EE9 >1769          BEQ   :CRUNCH6   ;yep
                  >1770 
2EB8: EE 47 DF    >1771          INC   MSGINFO+4  
2EBB: D0 03 =2EC0 >1772          BNE   :CRUNCH5A  ;add one to message count
2EBD: EE 48 DF    >1773          INC   MSGINFO+5  
                  >1774 
2EC0: BD 00 B9    >1775 :CRUNCH5A LDA  DIRBUF,X   
2EC3: 8D 49 DF    >1776          STA   MSGINFO+6  ;copy byte
2EC6: 99 80 B9    >1777          STA   DIRBUF+128,Y ;and save in new message field
2EC9: E8          >1778          INX              
2ECA: C8          >1779          INY              
                  >1780 
2ECB: BD 00 B9    >1781          LDA   DIRBUF,X   
2ECE: 8D 4A DF    >1782          STA   MSGINFO+7  ;copy other byte
2ED1: 99 80 B9    >1783          STA   DIRBUF+128,Y ;and save in new message field
2ED4: E8          >1784          INX              
2ED5: C8          >1785          INY              
                  >1786 
2ED6: BD 00 B9    >1787          LDA   DIRBUF,X   
2ED9: 99 80 B9    >1788          STA   DIRBUF+128,Y ;copy byte
2EDC: E8          >1789          INX              
2EDD: C8          >1790          INY              
2EDE: BD 00 B9    >1791          LDA   DIRBUF,X   
2EE1: 99 80 B9    >1792          STA   DIRBUF+128,Y ;copy byte
2EE4: E8          >1793          INX              
2EE5: C8          >1794          INY              
                  >1795 
2EE6: 4C 5C 2E    >1796          JMP   :CRUNCH2   
                  >1797 
2EE9: AD 5D DF    >1798 :CRUNCH6 LDA   DIRSEG+1   ;do we want to write this?
2EEC: C9 FF       >1799          CMP   #$FF       
2EEE: F0 19 =2F09 >1800          BEQ   :CRUNCH8   ;nope
                  >1801 
2EF0: 86 06       >1802          STX   SAVE_X     ;save x
2EF2: 18          >1803          CLC              
2EF3: 6D 43 DF    >1804          ADC   MSGINFO    ;add in bitmap
2EF6: AA          >1805          TAX              
2EF7: A9 00       >1806          LDA   #0         
2EF9: 20 82 31    >1807          JSR   POSMSG     ;position
                  >1808 
2EFC: A2 80       >1809          LDX   #<DIRBUF+128 ;write out dir segment
2EFE: A9 B9       >1810          LDA   #>DIRBUF+128 
2F00: A0 01       >1811          LDY   #1         
2F02: 20 38 31    >1812          JSR   WRBLK      
                  >1813 
2F05: A6 06       >1814          LDX   SAVE_X     ;restore x
2F07: A0 80       >1815          LDY   #128       
2F09: A9 00       >1816 :CRUNCH8 LDA   #0         
2F0B: 99 7F B9    >1817 :CRUNCH9 STA   DIRBUF+127,Y ;fill buffer with 0's
2F0E: 88          >1818          DEY              
2F0F: D0 FA =2F0B >1819          BNE   :CRUNCH9   
                  >1820 
2F11: EE 5D DF    >1821          INC   DIRSEG+1   ;use next segment
2F14: A8          >1822          TAY              
2F15: AD 5D DF    >1823          LDA   DIRSEG+1   
2F18: CD 44 DF    >1824          CMP   MSGINFO+1  
2F1B: D0 93 =2EB0 >1825          BNE   :CRUNCH5   ;are we at end?, nope
                  >1826 
2F1D: 20 48 2A    >1827          JSR   FINISH     ;write out 8 byte header
2F20: A9 FF       >1828          LDA   #$FF       
2F22: 8D 5C DF    >1829          STA   DIRSEG     ;reset dir segment
2F25: 60          >1830          RTS              
                  >1831 
                  >1832 *-------------------------------
                  >1833 * update a file back to disk
                  >1834 *-------------------------------
                  >1835 
2F26: AD 42 DF    >1836 DO_UP    LDA   MSGREF     ;use msg refnum
2F29: 8D CD 03    >1837          STA   REFNUM     
2F2C: 4C E5 30    >1838          JMP   FLUSH      ;flush file back to disk
                  >1839 
                  >1840 *-------------------------------
                  >1841 * use an external command
                  >1842 *-------------------------------
                  >1843 
2F2F: AD 42 DF    >1844 DO_USE   LDA   MSGREF     ;get back old refnum
2F32: 8D CD 03    >1845          STA   REFNUM     
2F35: F0 08 =2F3F >1846          BEQ   :DO_USE1   ;file is closed
                  >1847 
2F37: 20 D8 30    >1848          JSR   CLOSE      ;close old msgfile
                  >1849 
2F3A: A9 00       >1850          LDA   #0         
2F3C: 8D 42 DF    >1851          STA   MSGREF     
                  >1852 
2F3F: A0 00       >1853 :DO_USE1 LDY   #0         
2F41: 20 FA 1C    >1854          JSR   SETIVEC    ;set to default input/output
2F44: 20 08 1D    >1855          JSR   SETOVEC    
                  >1856 
2F47: 20 63 2F    >1857          JSR   MOVNAME    ;setup filename
2F4A: 20 B6 30    >1858          JSR   OPEN       ;open file
2F4D: B0 0F =2F5E >1859          BCS   :DO_USE2   
                  >1860 
2F4F: A2 00       >1861          LDX   #<ENDMOD   
2F51: A9 9E       >1862          LDA   #>ENDMOD   
2F53: A0 20       >1863          LDY   #32        ;read 32 - 128 byte pages (4k)
2F55: 20 42 31    >1864          JSR   RDBLK      
                  >1865 
2F58: 20 D8 30    >1866          JSR   CLOSE      ;finish up
2F5B: 4C 00 9E    >1867          JMP   ENDMOD     ;exec external routine
                  >1868 
2F5E: A2 17       >1869 :DO_USE2 LDX   #badxtrn   ;unable to load external
2F60: 4C E1 12    >1870          JMP   BADERR     
                   37            PUT   DRIVE      
                  >2    ********************************
                  >3    *                              *
                  >4    *   ACOS.OBJ - ProDOS Drive    *
                  >5    *                              *
                  >6    ********************************
                                  3-MAR-23   9:23:16 AM
                  >8    *-------------------------------
                  >9    * move the name into the filename field
                  >10   *-------------------------------
                  >11   
2F63: 20 F7 1E    >12   MOVNAME  JSR   INSTR2     ;get name (dont use memory)
2F66: A5 0F       >13   MOVNM0   LDA   STRLEN     
2F68: F0 4D =2FB7 >14            BEQ   :MOVNAM4   
                  >15   
2F6A: A0 00       >16            LDY   #0         
2F6C: 8C 6E 30    >17            STY   DRVCHD     ;init change drive string
2F6F: 8C 70 30    >18            STY   DRVOFF0    
2F72: 8C 71 30    >19            STY   DRVOFF1    
                  >20   
2F75: B1 0D       >21            LDA   (STRLOC),Y ;get first byte
2F77: 20 6E 17    >22            JSR   CONV       
2F7A: 8D 6F 30    >23            STA   DRVNUM     ;save it as a drive spec
2F7D: C9 4D       >24            CMP   #'L'+1     
2F7F: B0 2A =2FAB >25            BGE   :MOVNAM2   not
                  >26   
2F81: 20 51 17    >27            JSR   TST_ALF    
2F84: B0 25 =2FAB >28            BCS   :MOVNAM2   ;opps, not legal
                  >29   
2F86: C8          >30            INY              
2F87: B1 0D       >31            LDA   (STRLOC),Y ;are we done?
2F89: C9 3A       >32            CMP   #':'       
2F8B: F0 23 =2FB0 >33            BEQ   :MOVNAM3   ;yep, get filename
                  >34   
2F8D: 20 60 17    >35            JSR   TST_NUM    ;is it a legal sub-drive?
2F90: B0 19 =2FAB >36            BCS   :MOVNAM2   ;nope
                  >37   
2F92: 8D 70 30    >38            STA   DRVOFF0    ;save sub-drive byte 1
2F95: C8          >39            INY              
2F96: B1 0D       >40            LDA   (STRLOC),Y ;are we done?
2F98: C9 3A       >41            CMP   #':'       
2F9A: F0 14 =2FB0 >42            BEQ   :MOVNAM3   ;yep, get filename
                  >43   
2F9C: 20 60 17    >44            JSR   TST_NUM    ;is it a legal sub-drive?
2F9F: B0 0A =2FAB >45            BCS   :MOVNAM2   ;nope
                  >46   
2FA1: 8D 71 30    >47            STA   DRVOFF1    ;save sub-drive byte 2
2FA4: C8          >48            INY              
2FA5: B1 0D       >49            LDA   (STRLOC),Y ;is there a terminator?
2FA7: C9 3A       >50            CMP   #':'       
2FA9: F0 05 =2FB0 >51            BEQ   :MOVNAM3   ;yep, get filename
                  >52   
2FAB: A0 FF       >53   :MOVNAM2 LDY   #$FF       ;no drive parm, just get name
2FAD: 8C 6E 30    >54            STY   DRVCHD     ;init change drive flag
                  >55   
2FB0: C8          >56   :MOVNAM3 INY              
2FB1: A2 00       >57            LDX   #0         
2FB3: C4 0F       >58            CPY   STRLEN     
2FB5: F0 16 =2FCD >59            BEQ   :MOVNAM5   ;is there any data?, hmmm
                  >60   
2FB7: B1 0D       >61   :MOVNAM4 LDA   (STRLOC),Y ;copy filename
2FB9: 20 6E 17    >62            JSR   CONV       ;convert to upper
2FBC: C9 2E       >63            CMP   #'.'       
2FBE: 90 0D =2FCD >64            BLT   :MOVNAM5   ;we are done [anything less, illegal]
                  >65   
2FC0: 9D 73 30    >66            STA   FLNAME+1,X ;save name
2FC3: E8          >67            INX              
2FC4: C8          >68            INY              
2FC5: C4 0F       >69            CPY   STRLEN     
2FC7: F0 04 =2FCD >70            BEQ   :MOVNAM5   ;done yet?
                  >71   
2FC9: E0 0F       >72            CPX   #15        
2FCB: D0 EA =2FB7 >73            BNE   :MOVNAM4   ;have we done 15 chars (the max), nope
                  >74   
2FCD: 8E 72 30    >75   :MOVNAM5 STX   FLNAME     ;save length
2FD0: AD 6E 30    >76            LDA   DRVCHD     ;change drive first?
2FD3: 10 1F =2FF4 >77            BPL   SETDRV     ;yep
2FD5: 60          >78            RTS              
                  >79   
                  >80   *-------------------------------
                  >81   * log to drive A, offset X
                  >82   *-------------------------------
                  >83   
2FD6: A0 00       >84   LOGSPEC  LDY   #0         ;reset offsets
2FD8: 8C 70 30    >85            STY   DRVOFF0    
2FDB: 8C 71 30    >86            STY   DRVOFF1    
                  >87   
2FDE: 8D 6F 30    >88            STA   DRVNUM     ;save drive number [A-L]
2FE1: 8A          >89            TXA              
2FE2: F0 10 =2FF4 >90            BEQ   SETDRV     ;no offset
                  >91   
2FE4: 20 23 1A    >92            JSR   BINDEC8    ;translate to two-byte number
2FE7: 8E 70 30    >93            STX   DRVOFF0    ;save offset
2FEA: C9 30       >94            CMP   #'0'       
2FEC: F0 06 =2FF4 >95            BEQ   SETDRV     ;1 byte offset?, yep
2FEE: 8D 70 30    >96            STA   DRVOFF0    
2FF1: 8E 71 30    >97            STX   DRVOFF1    ;save offset
                  >98   
2FF4: A9 15       >99   SETDRV   LDA   #<DEVNAM   ;point to pathnames
2FF6: 85 00       >100           STA   TEMP       
2FF8: A9 08       >101           LDA   #>DEVNAM   
2FFA: 85 01       >102           STA   TEMP+1     
                  >103  
2FFC: AD 6F 30    >104           LDA   DRVNUM     ;turn drive num into offset
2FFF: 29 0F       >105           AND   #$F        
3001: 8D 00 02    >106           STA   LNBUF      
                  >107  
3004: CE 00 02    >108  :SETDRV0 DEC   LNBUF      
3007: F0 12 =301B >109           BEQ   :SETDRV1   ;count down drives
                  >110  
3009: A0 00       >111           LDY   #0         
300B: B1 00       >112           LDA   (TEMP),Y   ;get length of pathname
                  >113  
300D: 38          >114           SEC              
300E: 65 00       >115           ADC   TEMP       
3010: 85 00       >116           STA   TEMP       ;point to next entry
3012: A9 00       >117           LDA   #0         
3014: 65 01       >118           ADC   TEMP+1     
3016: 85 01       >119           STA   TEMP+1     
3018: 4C 04 30    >120           JMP   :SETDRV0   ;set drive number
                  >121  
301B: A0 00       >122  :SETDRV1 LDY   #0         
301D: B1 00       >123           LDA   (TEMP),Y   ;get length of string
301F: F0 48 =3069 >124           BEQ   :MOVNAM7   ;pathname not in use
                  >125  
3021: A8          >126           TAY              
3022: AA          >127           TAX              ;save length
                  >128  
3023: B1 00       >129  :SETDRV2 LDA   (TEMP),Y   
3025: 99 00 02    >130           STA   LNBUF,Y    ;move pathname to lnbuf
3028: 88          >131           DEY              
3029: 10 F8 =3023 >132           BPL   :SETDRV2   
                  >133  
302B: AD 70 30    >134           LDA   DRVOFF0    ;was there an offset?
302E: F0 0D =303D >135           BEQ   :SETDRV4   nope
                  >136  
3030: E8          >137           INX   increase   length
3031: 9D 00 02    >138           STA   LNBUF,X    save
                  >139  
3034: AD 71 30    >140           LDA   DRVOFF1    was
3037: F0 04 =303D >141           BEQ   :SETDRV4   ;nope
                  >142  
3039: E8          >143           INX              ;increase length
303A: 9D 00 02    >144           STA   LNBUF,X    ;save offset
                  >145  
303D: E8          >146  :SETDRV4 INX              
303E: A9 2F       >147           LDA   #'/'       
3040: 9D 00 02    >148           STA   LNBUF,X    ;add '/' to end of string
3043: 8E 00 02    >149           STX   LNBUF      ;update length
                  >150  
3046: 20 00 BF    >151           JSR   MLI        ;get current prefix
3049: C7          >152           DB    $C7        
304A: 82 30       >153           DA    GETPFX     
                  >154  
304C: AE 00 02    >155           LDX   LNBUF      ;are the length's the same?
304F: CD 40 02    >156           CMP   LNBUF+64   
3052: D0 0C =3060 >157           BNE   :SETDRV6   ;nope, change to new prefix
                  >158  
3054: BD 00 02    >159  :SETDRV5 LDA   LNBUF,X    ;is data the same?
3057: DD 40 02    >160           CMP   LNBUF+64,X 
305A: D0 04 =3060 >161           BNE   :SETDRV6   ;nope, change to new prefix
                  >162  
305C: CA          >163           DEX              
305D: 10 F5 =3054 >164           BPL   :SETDRV5   
305F: 60          >165           RTS              ;they are the same, just return
                  >166  
3060: 20 00 BF    >167  :SETDRV6 JSR   MLI        ;set to the new prefix
3063: C6          >168           DB    $C6        
3064: 85 30       >169           DA    SETPFX     
3066: D0 01 =3069 >170           BNE   :MOVNAM7   ;opps, error
3068: 60          >171           RTS              
                  >172  
3069: A2 16       >173  :MOVNAM7 LDX   #baddrive  ;bad drive specifier
306B: 4C E1 12    >174           JMP   BADERR     
                  >175  
306E: 00          >176  DRVCHD   DB    0          
306F: 00          >177  DRVNUM   DB    0          
3070: 00          >178  DRVOFF0  DB    0          
3071: 00          >179  DRVOFF1  DB    0          
                  >180  
3072: 00 00 00 00 >181  FLNAME   DS    16         
                  >182  
3082: 01          >183  GETPFX   DB    1          
3083: 40 02       >184           DA    LNBUF+64   
                  >185  
3085: 01          >186  SETPFX   DB    1          
3086: 00 02       >187           DA    LNBUF      
                  >188  
                  >189  
                   38            PUT   DISKIO     
                  >2    ********************************
                  >3    *                              *
                  >4    *  ACOS.OBJ - ProDOS disk I/O  *
                  >5    *                              *
                  >6    ********************************
                                  3-MAR-23   9:23:16 AM
                  >8    *-------------------------------
                  >9    
3088: 8C 48 32    >10   CREATE   STY   P_CREAT+4  ;save filetype
308B: 8D 4A 32    >11            STA   P_CREAT+6  
308E: 8E 49 32    >12            STX   P_CREAT+5  
3091: 20 00 BF    >13            JSR   MLI        
3094: 82          >14            DB    $82        
3095: 00 00       >15            DA    0          
3097: AD 90 BF    >16            LDA   MLIDATE    
309A: 8D 4C 32    >17            STA   P_CREAT+8  
309D: AD 91 BF    >18            LDA   MLIDATE+1  
30A0: 8D 4D 32    >19            STA   P_CREAT+9  
30A3: AD 92 BF    >20            LDA   MLITIME    
30A6: 8D 4E 32    >21            STA   P_CREAT+10 
30A9: AD 93 BF    >22            LDA   MLITIME+1  
30AC: 8D 4F 32    >23            STA   P_CREAT+11 
30AF: 20 00 BF    >24            JSR   MLI        
30B2: C0          >25            DB    $C0        
30B3: 44 32       >26            DA    P_CREAT    
30B5: 60          >27            RTS              
                  >28   
30B6: A0 00       >29   OPEN     LDY   #0         
30B8: B9 D5 30    >30   BFOPEN   LDA   BUFADR,Y   ;point at buffer
30BB: 8D 1B 32    >31            STA   P_OPEN+4   
                  >32   
30BE: 20 00 BF    >33            JSR   MLI        
30C1: C8          >34            DB    $C8        
30C2: 17 32       >35            DA    P_OPEN     
30C4: D0 08 =30CE >36            BNE   :OPEN2     
                  >37   
30C6: AD 1C 32    >38            LDA   P_OPEN+5   ;save refnum
30C9: 8D CD 03    >39            STA   REFNUM     
30CC: 18          >40            CLC              
30CD: 60          >41            RTS              
                  >42   
30CE: A9 FF       >43   :OPEN2   LDA   #-1        ;make sure refnum is illegal
30D0: 8D CD 03    >44            STA   REFNUM     
30D3: 38          >45            SEC              
30D4: 60          >46            RTS              
                  >47   
30D5: B2 AE BB    >48   BUFADR   DB    >FBUF1,>FBUF2,>MSGBUF 
                  >49   
30D8: AD CD 03    >50   CLOSE    LDA   REFNUM     
30DB: 8D 1E 32    >51            STA   P_CLOSE+1  
30DE: 20 00 BF    >52            JSR   MLI        
30E1: CC          >53            DB    $CC        
30E2: 1D 32       >54            DA    P_CLOSE    
30E4: 60          >55            RTS              
                  >56   
30E5: AD CD 03    >57   FLUSH    LDA   REFNUM     
30E8: 8D 1E 32    >58            STA   P_CLOSE+1  
30EB: 20 00 BF    >59            JSR   MLI        
30EE: CD          >60            DB    $CD        
30EF: 1D 32       >61            DA    P_CLOSE    
30F1: 60          >62            RTS              
                  >63   
                  >64   *-------------------------------
                  >65   * setup for single line read
                  >66   *-------------------------------
                  >67   
30F2: AD CD 03    >68   RDLNSET  LDA   REFNUM     
30F5: 8D 2E 32    >69            STA   P_NEW1+1   ;save refnum
30F8: 8D 32 32    >70            STA   P_RDLN+1   
30FB: 20 00 BF    >71            JSR   MLI        
30FE: C9          >72            DB    $C9        
30FF: 2D 32       >73            DA    P_NEW1     ;enable newline
3101: 60          >74            RTS              
                  >75   
                  >76   *-------------------------------
                  >77   * read a line from a file
                  >78   *-------------------------------
                  >79   
3102: 20 00 BF    >80   RDLINE   JSR   MLI        
3105: CA          >81            DB    $CA        
3106: 31 32       >82            DA    P_RDLN     
3108: D0 0E =3118 >83            BNE   :RDLINE2   ;read error
                  >84   
310A: AE 37 32    >85            LDX   P_RDLN+6   ;is there a cr at end of line?
310D: BD FF 01    >86            LDA   LNBUF-1,X  
3110: 29 7F       >87            AND   #clrhi     
3112: C9 0D       >88            CMP   #cr        
3114: D0 02 =3118 >89            BNE   :RDLINE2   ;no more stuff
3116: 18          >90            CLC              
3117: 60          >91            RTS              
                  >92   
3118: A9 00       >93   :RDLINE2 LDA   #0         
311A: 8D 00 02    >94            STA   LNBUF      ;no data in line
311D: 38          >95            SEC              ;eof
311E: 60          >96            RTS              
                  >97   
                  >98   *-------------------------------
                  >99   * read a single byte
                  >100  *-------------------------------
                  >101  
311F: AD CD 03    >102  RDBYTE   LDA   REFNUM     ;save refnum
3122: F0 10 =3134 >103           BEQ   :RDBYTE2   
                  >104  
3124: 8D 20 32    >105           STA   P_RBYT+1   
3127: 20 00 BF    >106           JSR   MLI        
312A: CA          >107           DB    $CA        
312B: 1F 32       >108           DA    P_RBYT     ;read 1 byte
312D: D0 05 =3134 >109           BNE   :RDBYTE2   
                  >110  
312F: AD 27 32    >111           LDA   P_BYTE     ;get byte
3132: 18          >112           CLC              ;were done
3133: 60          >113           RTS              
                  >114  
3134: A9 00       >115  :RDBYTE2 LDA   #0         ;fake data
3136: 38          >116           SEC              
3137: 60          >117           RTS              
                  >118  
                  >119  *-------------------------------
                  >120  * write a block for the msg routines
                  >121  *-------------------------------
                  >122  
3138: 48          >123  WRBLK    PHA              
3139: A9 CB       >124           LDA   #$CB       
313B: 8D 66 31    >125           STA   RWTYPE     
313E: 68          >126           PLA              
313F: 4C 49 31    >127           JMP   RWBLK      ;use write call
                  >128  
                  >129  *-------------------------------
                  >130  * read a block for the msg routines
                  >131  *-------------------------------
                  >132  
3142: 48          >133  RDBLK    PHA              
3143: A9 CA       >134           LDA   #$CA       
3145: 8D 66 31    >135           STA   RWTYPE     ;use read call
3148: 68          >136           PLA              
                  >137  
3149: 8E 3B 32    >138  RWBLK    STX   P_RDBLK+2  ;save read address
314C: 8D 3C 32    >139           STA   P_RDBLK+3  
                  >140  
314F: A9 00       >141           LDA   #0         
3151: 8D 3D 32    >142           STA   P_RDBLK+4  ;save number of blocks to read
3154: 8C 3E 32    >143           STY   P_RDBLK+5  
                  >144  
3157: 4E 3E 32    >145           LSR   P_RDBLK+5  ;divide by 2
315A: 6E 3D 32    >146           ROR   P_RDBLK+4  
                  >147  
315D: AD CD 03    >148           LDA   REFNUM     
3160: 8D 3A 32    >149           STA   P_RDBLK+1  ;get refnum
                  >150  
3163: 20 00 BF    >151           JSR   MLI        ;call mli
3166: CA          >152  RWTYPE   DB    $CA        ;*** modified ***
3167: 39 32       >153           DA    P_RDBLK    
3169: 60          >154           RTS              
                  >155  
                  >156  *-------------------------------
                  >157  * write a byte of data
                  >158  *-------------------------------
                  >159  
316A: 8D 27 32    >160  WRBYTE   STA   P_BYTE     ;save data
316D: 48          >161           PHA              
316E: AD CD 03    >162           LDA   REFNUM     
3171: F0 0C =317F >163           BEQ   :WRBYTE2   ;if no refnum
                  >164  
3173: 8D 20 32    >165           STA   P_RBYT+1   
3176: 20 00 BF    >166           JSR   MLI        
3179: CB          >167           DB    $CB        
317A: 1F 32       >168           DA    P_RBYT     ;write byte
317C: 18          >169           CLC              
317D: F0 01 =3180 >170           BEQ   :WRBYTE3   ;all is well
                  >171  
317F: 38          >172  :WRBYTE2 SEC              ;opps, problem
3180: 68          >173  :WRBYTE3 PLA              ;get back data
3181: 60          >174           RTS              
                  >175  
                  >176  *-------------------------------
                  >177  * position file
                  >178  *-------------------------------
                  >179  
3182: AC 42 DF    >180  POSMSG   LDY   MSGREF     
3185: 8C CD 03    >181           STY   REFNUM     ;save refnum
                  >182  
3188: 4A          >183           LSR              ;setup Y,A,X w/exact byte
3189: A8          >184           TAY              
318A: 8A          >185           TXA              
318B: 6A          >186           ROR              
318C: 48          >187           PHA              
318D: A9 10       >188           LDA   #$10       
318F: 6A          >189           ROR              
3190: AA          >190           TAX              
3191: 68          >191           PLA              
3192: 4C D7 31    >192           JMP   SETPOS     
                  >193  
                  >194  *-------------------------------
                  >195  * find the end of file
                  >196  *-------------------------------
                  >197  
3195: AD CD 03    >198  GETEOF   LDA   REFNUM     
3198: 8D 29 32    >199           STA   P_MARK+1   ;save refnum
319B: 20 00 BF    >200           JSR   MLI        
319E: D1          >201           DB    $D1        
319F: 28 32       >202           DA    P_MARK     ;get eof
31A1: AE 2A 32    >203           LDX   P_MARK+2   ;get length
31A4: AD 2B 32    >204           LDA   P_MARK+3   
31A7: AC 2C 32    >205           LDY   P_MARK+4   
31AA: 60          >206           RTS              
                  >207  
                  >208  *-------------------------------
                  >209  * check for end of file
                  >210  *-------------------------------
                  >211  
31AB: 20 F9 31    >212  CHKEOF   JSR   GETMARK    ;get the current place
31AE: 48          >213           PHA              
31AF: 8A          >214           TXA              
31B0: 48          >215           PHA              
31B1: 20 95 31    >216           JSR   GETEOF     ;get the end of file
31B4: 68          >217           PLA              
31B5: A8          >218           TAY              
                  >219  
31B6: 68          >220           PLA              
31B7: A2 00       >221           LDX   #0         
31B9: CC 2A 32    >222           CPY   P_MARK+2   
31BC: D0 06 =31C4 >223           BNE   :CHKEOF2   ;are they the same?, nope
31BE: CD 2B 32    >224           CMP   P_MARK+3   
31C1: D0 01 =31C4 >225           BNE   :CHKEOF2   ;nope
31C3: E8          >226           INX              ;yep, mark it
31C4: 60          >227  :CHKEOF2 RTS              
                  >228  
                  >229  *-------------------------------
                  >230  * check end of file
                  >231  *-------------------------------
                  >232  
31C5: 20 95 31    >233  GETSIZ   JSR   GETEOF     ;get the end of file
31C8: AE 2B 32    >234           LDX   P_MARK+3   ;get # of sectors
31CB: AD 2C 32    >235           LDA   P_MARK+4   
31CE: 60          >236           RTS              
                  >237  
                  >238  *-------------------------------
                  >239  * append data to file
                  >240  *-------------------------------
                  >241  
31CF: 20 95 31    >242  APPEND   JSR   GETEOF     ;get end of file
31D2: 4C D7 31    >243           JMP   SETPOS     ;append
                  >244  
                  >245  *-------------------------------
                  >246  * set a mark into a file
                  >247  *-------------------------------
                  >248  
31D5: A0 00       >249  SETMARK  LDY   #0         ;do actual position set within file
31D7: 8E 2A 32    >250  SETPOS   STX   P_MARK+2   ;point to new location
31DA: 8D 2B 32    >251           STA   P_MARK+3   
31DD: 8C 2C 32    >252           STY   P_MARK+4   
                  >253  
31E0: AD CD 03    >254           LDA   REFNUM     
31E3: 8D 29 32    >255           STA   P_MARK+1   ;save refnum
                  >256  
31E6: 20 00 BF    >257  SETPOS2  JSR   MLI        
31E9: CE          >258           DB    $CE        
31EA: 28 32       >259           DA    P_MARK     ;set mark
31EC: C9 4D       >260           CMP   #$4D       
31EE: D0 08 =31F8 >261           BNE   :SETPOS3   ;check for out-of-range
                  >262  
31F0: 20 00 BF    >263           JSR   MLI        
31F3: D0          >264           DB    $D0        
31F4: 28 32       >265           DA    P_MARK     ;set eof
31F6: F0 EE =31E6 >266           BEQ   SETPOS2    ;position again
                  >267  
31F8: 60          >268  :SETPOS3 RTS              
                  >269  
                  >270  *-------------------------------
                  >271  * get current file marker
                  >272  *-------------------------------
                  >273  
31F9: AD CD 03    >274  GETMARK  LDA   REFNUM     
31FC: 8D 29 32    >275           STA   P_MARK+1   ;save refnum
31FF: 20 00 BF    >276           JSR   MLI        
3202: CF          >277           DB    $CF        
3203: 28 32       >278           DA    P_MARK     ;get mark
3205: 38          >279           SEC              
3206: D0 07 =320F >280           BNE   :GETMRK2   ;opps, error
                  >281  
3208: 18          >282           CLC              
3209: AE 2A 32    >283           LDX   P_MARK+2   ;all is well
320C: AD 2B 32    >284           LDA   P_MARK+3   
320F: 60          >285  :GETMRK2 RTS              
                  >286  
                  >287  *-------------------------------
                  >288  * delete file
                  >289  *-------------------------------
                  >290  
3210: 20 00 BF    >291  DELFILE  JSR   MLI        
3213: C1          >292           DB    $C1        
3214: 41 32       >293           DA    P_DEL      ;delete file
3216: 60          >294           RTS              
                  >295  
                  >296  *-------------------------------
                  >297  * ------ parms ------
                  >298  *-------------------------------
                  >299  
3217: 03          >300  P_OPEN   DB    3          
3218: 72 30       >301           DA    FLNAME     
321A: 00 B2       >302           DA    FBUF1      
321C: 00          >303           DB    0          
                  >304  
321D: 01          >305  P_CLOSE  DB    1          
321E: 00          >306           DB    0          
                  >307  
321F: 04          >308  P_RBYT   DB    4          
3220: 00          >309           DB    0          
3221: 27 32       >310           DA    P_BYTE     
3223: 01 00       >311           DA    1          
3225: 00 00       >312           DA    0          
                  >313  
3227: 00          >314  P_BYTE   DB    0          
                  >315  
3228: 02          >316  P_MARK   DB    2          
3229: 00          >317           DB    0          
322A: 00 00 00    >318           DS    3          
                  >319  
322D: 03          >320  P_NEW1   DB    3          
322E: 00          >321           DB    0          
322F: 7F          >322           DB    clrhi      
3230: 0D          >323           DB    cr         
                  >324  
3231: 04          >325  P_RDLN   DB    4          
3232: 00          >326           DB    0          
3233: 00 02       >327           DA    LNBUF      
3235: FF 00       >328           DA    255        
3237: 00 00       >329           DA    0          
                  >330  
3239: 04          >331  P_RDBLK  DB    4          
323A: 00          >332           DB    0          
323B: 00 00       >333           DA    0          
323D: 80 00       >334           DA    128        
323F: 00 00       >335           DA    0          
                  >336  
3241: 01          >337  P_DEL    DB    1          
3242: 72 30       >338           DA    FLNAME     
                  >339  
3244: 07          >340  P_CREAT  DB    7          
3245: 72 30       >341           DA    FLNAME     
3247: E3          >342           HEX   E3         
3248: 00          >343           DB    0          
3249: 00 00       >344           DA    0          
324B: 01          >345           DB    1          
324C: 00 00       >346           DA    0          
324E: 00 00       >347           DA    0          
                  >348  
                  >349  
                   39            PUT   LOAD       
                  >2    ********************************
                  >3    *                              *
                  >4    *     ACOS.OBJ - Load          *
                  >5    *                              *
                  >6    ********************************
                                  3-MAR-23   9:23:17 AM
                  >8    *-------------------------------
                  >9    * -- read module into memory --
                  >10   *-------------------------------
                  >11   
3250: A9 00       >12   LD_MOD   LDA   #0         ;reset no carrier and on error vectors
3252: 8D 2C DF    >13            STA   NOCDFLG    
3255: 8D 2F DF    >14            STA   ONERRFLG   
                  >15   
3258: AE 72 30    >16            LDX   FLNAME     
325B: E0 0E       >17            CPX   #14        
325D: B0 58 =32B7 >18            BGE   LD_MOD1    ;too long!
                  >19   
325F: E8          >20            INX              
3260: A9 2E       >21            LDA   #'.'       
3262: 9D 72 30    >22            STA   FLNAME,X   ;tack on '.C' extension
3265: E8          >23            INX              
3266: A9 43       >24            LDA   #'C'       
3268: 9D 72 30    >25            STA   FLNAME,X   
326B: 8E 72 30    >26            STX   FLNAME     
                  >27   
326E: 20 B6 30    >28            JSR   OPEN       ;is there a compiled module?
3271: B0 49 =32BC >29            BCS   LD_MOD2    ;nope
                  >30   
3273: AD 42 DF    >31            LDA   MSGREF     ;save msg refnum
3276: 48          >32            PHA              
3277: AD CD 03    >33            LDA   REFNUM     
327A: 8D 42 DF    >34            STA   MSGREF     
                  >35   
327D: A9 00       >36            LDA   #0         
327F: 8D 8C 02    >37            STA   LNBUF+140  
3282: 8D 8D 02    >38            STA   LNBUF+141  
                  >39   
3285: A2 80       >40            LDX   #<LNBUF+128 ;read label info
3287: A9 02       >41            LDA   #>LNBUF+128 
3289: A0 01       >42            LDY   #1         
328B: 20 42 31    >43            JSR   RDBLK      
                  >44   
328E: AD 8E 02    >45            LDA   LNBUF+142  ;set up variable space
3291: 85 69       >46            STA   LOMEM      
3293: AD 8F 02    >47            LDA   LNBUF+143  
3296: 85 6A       >48            STA   LOMEM+1    
                  >49   
3298: A2 00       >50            LDX   #<CODEND   ;read in rest of module
329A: A9 51       >51            LDA   #>CODEND   
329C: A0 80       >52            LDY   #128       
329E: 20 42 31    >53            JSR   RDBLK      
                  >54   
32A1: 20 D8 30    >55            JSR   CLOSE      
32A4: 68          >56            PLA              
32A5: 8D 42 DF    >57            STA   MSGREF     ;restore msg refnum
                  >58   
32A8: AD 8C 02    >59            LDA   LNBUF+140  ;is first i/d byte ok?
32AB: C9 47       >60            CMP   #'G'       
32AD: D0 0D =32BC >61            BNE   LD_MOD2    ;nope, compile
                  >62   
32AF: AD 8D 02    >63            LDA   LNBUF+141  ;is second i/d byte ok?
32B2: C9 53       >64            CMP   #'S'       
32B4: D0 06 =32BC >65            BNE   LD_MOD2    ;nope, compile
                  >66   
32B6: 60          >67            RTS              ;and we are done!
                  >68   
32B7: A2 10       >69   LD_MOD1  LDX   #badfn     ;illegal filename (>14 chars)
32B9: 4C E1 12    >70            JMP   BADERR     
                  >71   
32BC: AE 72 30    >72   LD_MOD2  LDX   FLNAME     ;change name back to source
32BF: A9 53       >73            LDA   #'S'       
32C1: 9D 72 30    >74            STA   FLNAME,X   ;'.S' for source
32C4: 20 B6 30    >75            JSR   OPEN       ;open source file
32C7: B0 EE =32B7 >76            BCS   LD_MOD1    ;opps, problem
                  >77   
32C9: 20 F2 30    >78            JSR   RDLNSET    ;setup for rdline
32CC: A9 51       >79            LDA   #>CODEND   ;point to module space
32CE: 85 01       >80            STA   TEMP+1     
32D0: A9 00       >81            LDA   #<CODEND   
32D2: 85 00       >82            STA   TEMP       
32D4: A9 00       >83            LDA   #0         
32D6: 8D 37 DF    >84            STA   LBLNUM     
32D9: 8D 36 DF    >85            STA   SYMNUM     ;zero sym/lbl counters
32DC: A2 01       >86            LDX   #compile1  
32DE: 20 BF 19    >87            JSR   PRCMPMSG   
32E1: 4C F7 32    >88            JMP   :STATE0    
                  >89   
                  >90   *-------------------------------
                  >91   * ----- pass 1 ------
                  >92   *-------------------------------
                  >93   
32E4: 4C 2A 34    >94   :JSTATE4 JMP   STATE4     
                  >95   
32E7: AD 38 DF    >96   :STATE0A LDA   LNCNT      ;was it just a blank cr?
32EA: C9 02       >97            CMP   #2         
32EC: 90 09 =32F7 >98            BLT   :STATE0    ;yep
                  >99   
32EE: A9 09       >100           LDA   #chain2    ;insert a chain command
32F0: A0 00       >101           LDY   #0         
32F2: 91 00       >102           STA   (TEMP),Y   
32F4: 20 06 17    >103           JSR   INCTMP     
                  >104  
32F7: A9 00       >105  :STATE0  LDA   #0         
32F9: 8D 38 DF    >106           STA   LNCNT      ;reset line pointer
32FC: 20 02 31    >107           JSR   RDLINE     ;get line of input
32FF: B0 E3 =32E4 >108           BCS   :JSTATE4   ;eof?
                  >109  
3301: AD 00 02    >110           LDA   LNBUF      ;gobble up comments
3304: C9 3B       >111           CMP   #';'       
3306: F0 EF =32F7 >112           BEQ   :STATE0    
                  >113  
3308: 20 51 17    >114           JSR   TST_ALF    ;check for label
330B: B0 1D =332A >115           BCS   :STATE1    
                  >116  
330D: 20 C5 35    >117           JSR   ADD_SYM    ;add to symbol table
3310: 90 E5 =32F7 >118           BCC   :STATE0    
                  >119  
3312: A2 04       >120           LDX   #symfull   ;give error
3314: 20 73 19    >121           JSR   SHERR      
3317: 4C F7 32    >122           JMP   :STATE0    
                  >123  
331A: 85 02       >124  :JSTATE3 STA   TEMP2      ;save delimiter char for text/block mode
331C: A9 A2       >125           LDA   #"""       
331E: 4C ED 33    >126           JMP   :STATE3A   
                  >127  
3321: 20 22 36    >128  :STATE2A JSR   ADD_LBL    ;add label to table
3324: 4C 2A 33    >129           JMP   :STATE1    
                  >130  
3327: EE 38 DF    >131  :STATE1A INC   LNCNT      ;advance pointer
332A: AC 38 DF    >132  :STATE1  LDY   LNCNT      
332D: B9 00 02    >133           LDA   LNBUF,Y    
3330: C9 0D       >134           CMP   #cr        
3332: F0 B3 =32E7 >135           BEQ   :STATE0A   ;if end of line
                  >136  
3334: C9 21       >137           CMP   #'!'       
3336: 90 EF =3327 >138           BLT   :STATE1A   ;go until a legal character of some sort
                  >139  
3338: C9 22       >140           CMP   #'"'       
333A: F0 DE =331A >141           BEQ   :JSTATE3   ;check for text mode
                  >142  
333C: C9 27       >143           CMP   #'''       
333E: F0 DA =331A >144           BEQ   :JSTATE3   ;check for block text mode
                  >145  
3340: 20 B6 36    >146           JSR   TOKEN      ;get token type
3343: C9 DB       >147           CMP   #"Z"+1     
3345: B0 08 =334F >148           BGE   :STATE1S   
                  >149  
3347: C9 C1       >150           CMP   #"A"       
3349: B0 29 =3374 >151           BGE   :STATE1D   ;check for variable
                  >152  
334B: A0 00       >153           LDY   #0         
334D: 84 2F       >154           STY   LSTTOK     
                  >155  
334F: C9 07       >156  :STATE1S CMP   #public    
3351: F0 CE =3321 >157           BEQ   :STATE2A   ;is it public?, yep
                  >158  
3353: A0 00       >159           LDY   #0         ;save into memory
3355: 91 00       >160           STA   (TEMP),Y   
3357: 20 06 17    >161           JSR   INCTMP     
                  >162  
335A: C9 04       >163           CMP   #goto      
335C: F0 6D =33CB >164           BEQ   :STATE2    
335E: C9 06       >165           CMP   #push      
3360: F0 69 =33CB >166           BEQ   :STATE2    
                  >167  
3362: C9 05       >168           CMP   #gosub     
3364: D0 06 =336C >169           BNE   :STATE1Z   ;check to see if label follows
                  >170  
3366: A4 2F       >171           LDY   LSTTOK     
3368: C0 0A       >172           CPY   #clear     
336A: D0 5F =33CB >173           BNE   :STATE2    
                  >174  
336C: 85 2F       >175  :STATE1Z STA   LSTTOK     
336E: 4C 2A 33    >176           JMP   :STATE1    
                  >177  
3371: 4C E7 32    >178  :STATE1C JMP   :STATE0A   ;restart with state 0
                  >179  
                  >180  *-------------------------------
                  >181  * ----- handle variables -----
                  >182  *-------------------------------
                  >183  
3374: 85 02       >184  :STATE1D STA   TEMP2      ;save first char of name
3376: AE 38 DF    >185           LDX   LNCNT      
3379: BD 00 02    >186           LDA   LNBUF,X    ;see if there is another
337C: 20 51 17    >187           JSR   TST_ALF    
337F: 90 0A =338B >188           BCC   :STATE1E   
                  >189  
3381: 20 60 17    >190           JSR   TST_NUM    
3384: 90 05 =338B >191           BCC   :STATE1E   
                  >192  
3386: CE 38 DF    >193           DEC   LNCNT      ;nope, only 1 digit
3389: A9 20       >194           LDA   #' '       
338B: 85 03       >195  :STATE1E STA   TEMP2+1    ;save second char of name
                  >196  
338D: AE 38 DF    >197           LDX   LNCNT      
3390: E8          >198  :STATE1F INX              
3391: BD 00 02    >199           LDA   LNBUF,X    ;gobble rest of name
3394: 20 51 17    >200           JSR   TST_ALF    
3397: 90 F7 =3390 >201           BCC   :STATE1F   
                  >202  
3399: 20 60 17    >203           JSR   TST_NUM    
339C: 90 F2 =3390 >204           BCC   :STATE1F   
                  >205  
339E: 8E 38 DF    >206           STX   LNCNT      
33A1: A2 01       >207           LDX   #number    
33A3: C9 24       >208           CMP   #'$'       
33A5: D0 05 =33AC >209           BNE   :STATE1G   ;find out whether it is a number
                  >210  
33A7: EE 38 DF    >211           INC   LNCNT      ;or a string
33AA: A2 02       >212           LDX   #string    
                  >213  
33AC: A0 00       >214  :STATE1G LDY   #0         ;save variable type
33AE: 8A          >215           TXA              
33AF: 91 00       >216           STA   (TEMP),Y   
33B1: 20 06 17    >217           JSR   INCTMP     
                  >218  
33B4: A5 02       >219           LDA   TEMP2      
33B6: 20 6E 17    >220           JSR   CONV       
33B9: 91 00       >221           STA   (TEMP),Y   ;save first char
33BB: 20 06 17    >222           JSR   INCTMP     
                  >223  
33BE: A5 03       >224           LDA   TEMP2+1    
33C0: 20 6E 17    >225           JSR   CONV       
33C3: 91 00       >226           STA   (TEMP),Y   ;save second char
33C5: 20 06 17    >227           JSR   INCTMP     
33C8: 4C 2A 33    >228           JMP   :STATE1    
                  >229  
33CB: A0 00       >230  :STATE2  LDY   #0         
33CD: A9 00       >231           LDA   #LABEL     
33CF: 91 00       >232           STA   (TEMP),Y   
33D1: 20 06 17    >233           JSR   INCTMP     
                  >234  
33D4: 20 22 36    >235           JSR   ADD_LBL    ;add label to table 2
33D7: B0 98 =3371 >236           BCS   :STATE1C   
                  >237  
33D9: A0 00       >238           LDY   #0         
33DB: 91 00       >239           STA   (TEMP),Y   
33DD: 20 06 17    >240           JSR   INCTMP     
33E0: 4C 2A 33    >241           JMP   :STATE1    
                  >242  
                  >243  *-------------------------------
                  >244  * do text/block mode processing
                  >245  *-------------------------------
                  >246  
33E3: AC 38 DF    >247  :STATE3  LDY   LNCNT      
33E6: B9 00 02    >248           LDA   LNBUF,Y    ;get byte
33E9: C5 02       >249           CMP   TEMP2      
33EB: F0 2E =341B >250           BEQ   :STATE3C   ;check for delimiter, were done
                  >251  
33ED: C9 0D       >252  :STATE3A CMP   #cr        
33EF: D0 08 =33F9 >253           BNE   :STATE3B   ;end of line?, nope
                  >254  
33F1: A5 02       >255           LDA   TEMP2      ;in text or block?
33F3: C9 22       >256           CMP   #'"'       
33F5: F0 27 =341E >257           BEQ   :STATE3D   ;text, do finish up
                  >258  
33F7: A9 0D       >259           LDA   #cr        ;stick in cr if in block
33F9: A0 00       >260  :STATE3B LDY   #0         ;save byte
33FB: 91 00       >261           STA   (TEMP),Y   
33FD: 48          >262           PHA              
33FE: 20 06 17    >263           JSR   INCTMP     
3401: EE 38 DF    >264           INC   LNCNT      
3404: 68          >265           PLA              
3405: C9 0D       >266           CMP   #cr        
3407: D0 DA =33E3 >267           BNE   :STATE3    ;check byte
                  >268  
3409: A9 00       >269           LDA   #0         
340B: 8D 38 DF    >270           STA   LNCNT      ;reset line counter
340E: 20 02 31    >271           JSR   RDLINE     ;read new line
                  >272  
3411: 90 D0 =33E3 >273           BCC   :STATE3    ;keep checking
                  >274  
3413: A2 18       >275           LDX   #noquote   ;Unclosed quote at EOF
3415: 20 91 19    >276           JSR   ERROR      ;print in text warning
3418: 4C 2A 34    >277           JMP   STATE4     ;were done
                  >278  
341B: EE 38 DF    >279  :STATE3C INC   LNCNT      
341E: A9 A2       >280  :STATE3D LDA   #"""       
3420: A0 00       >281           LDY   #0         ;save last quote
3422: 91 00       >282           STA   (TEMP),Y   
3424: 20 06 17    >283           JSR   INCTMP     
3427: 4C 2A 33    >284           JMP   :STATE1    
                  >285  
                  >286  *-------------------------------
                  >287  * ----- pass 2 -----
                  >288  *-------------------------------
                  >289  
342A: A2 02       >290  STATE4   LDX   #compile2  
342C: 20 BF 19    >291           JSR   PRCMPMSG   
                  >292  
342F: A0 00       >293           LDY   #0         
3431: A9 03       >294           LDA   #end       
3433: 91 00       >295           STA   (TEMP),Y   
3435: 20 06 17    >296           JSR   INCTMP     
                  >297  
3438: A9 7F       >298           LDA   #QUIT      save end pointer
343A: 91 00       >299           STA   (TEMP),Y   
343C: 20 D8 30    >300           JSR   CLOSE      
                  >301  
343F: A9 00       >302           LDA   #0         ;mark end of tables
3441: AE 36 DF    >303           LDX   SYMNUM     
3444: 9D 00 A6    >304           STA   SYMTAB,X   
3447: AE 37 DF    >305           LDX   LBLNUM     
344A: 9D 00 9E    >306           STA   LBLTAB,X   
                  >307  
344D: 20 06 17    >308           JSR   INCTMP     
                  >309  
3450: A5 00       >310           LDA   TEMP       ;setup pointers to variable space
3452: 85 69       >311           STA   LOMEM      
3454: 8D 8E 02    >312           STA   LNBUF+142  ;save for compiled segments
3457: A5 01       >313           LDA   TEMP+1     
3459: 8D 8F 02    >314           STA   LNBUF+143  
345C: 85 6A       >315           STA   LOMEM+1    
                  >316  
345E: A2 80       >317           LDX   #128       ;start counters
3460: A0 00       >318           LDY   #0         
3462: A9 9E       >319  :STATE4A LDA   #>LBLTAB   
3464: 8D 69 34    >320           STA   :STATE4B+2 ;changes code
3467: B9 00 9E    >321  :STATE4B LDA   LBLTAB,Y   ;*** self-modified
346A: EE 69 34    >322           INC   :STATE4B+2 ;changes code
346D: 9D 00 02    >323           STA   LNBUF,X    ;save data
3470: E8          >324           INX              
3471: 8A          >325           TXA              
3472: 29 08       >326           AND   #%00001000 ;have we done 8 yet?
3474: F0 F1 =3467 >327           BEQ   :STATE4B   ;nope
                  >328  
3476: C8          >329           INY              ;ready for next
3477: 18          >330           CLC              
3478: 8A          >331           TXA              
3479: 69 08       >332           ADC   #8         ;add it up.
347B: AA          >333           TAX              
347C: 90 E4 =3462 >334           BCC   :STATE4A   ;keep going
                  >335  
347E: A2 FF       >336           LDX   #-1        ;start at beginning of table
3480: E8          >337  :STATE5  INX              
3481: BD 00 9E    >338           LDA   LBLTAB,X   
3484: D0 03 =3489 >339           BNE   :STATE5D   
3486: 4C 2A 35    >340           JMP   :STATE6    ;are we done?
                  >341  
3489: A0 FF       >342  :STATE5D LDY   #-1        
348B: C8          >343  :STATE5F INY              
348C: B9 00 A6    >344           LDA   SYMTAB,Y   
348F: D0 35 =34C6 >345           BNE   :STATE5C   ;keep checking
                  >346  
3491: 8A          >347           TXA              
3492: 48          >348           PHA              
3493: A2 03       >349           LDX   #lblnf     ;label not found
3495: 20 91 19    >350           JSR   ERROR      
3498: 68          >351           PLA              
3499: AA          >352           TAX              
349A: A9 9E       >353           LDA   #>LBLTAB   
349C: 8D A6 34    >354           STA   :STATE5E+2 ;start at first char
349F: A9 DB       >355           LDA   #"["       
34A1: 20 7B 17    >356           JSR   COUT       
                  >357  
34A4: BD 00 9E    >358  :STATE5E LDA   LBLTAB,X   
34A7: 08          >359           PHP              
34A8: 20 7B 17    >360           JSR   COUT       ;print char
34AB: EE A6 34    >361           INC   :STATE5E+2 ;get ready for next
34AE: 28          >362           PLP              
34AF: 10 F3 =34A4 >363           BPL   :STATE5E   ;loop until finished
                  >364  
34B1: A9 DD       >365           LDA   #"]"       
34B3: 20 7B 17    >366           JSR   COUT       
34B6: A9 DB       >367           LDA   #<NOLBLDEF 
34B8: 9D 00 9E    >368           STA   LBLTAB,X   ;put bad branch error routine
34BB: A9 12       >369           LDA   #>NOLBLDEF 
34BD: 9D 00 9F    >370           STA   LBLTAB+L1,X ;address into table
34C0: 4C 80 34    >371           JMP   :STATE5    
                  >372  
34C3: 4C 8B 34    >373  :STATE5A JMP   :STATE5F   ;extension from branches
                  >374  
34C6: BD 00 9E    >375  :STATE5C LDA   LBLTAB,X   ;check each byte
34C9: D9 00 A6    >376           CMP   SYMTAB,Y   
34CC: D0 F5 =34C3 >377           BNE   :STATE5A   ;opps, no match
34CE: 0A          >378           ASL              
34CF: B0 4A =351B >379           BCS   :STATE5B   ;high bit means were done
                  >380  
34D1: BD 00 9F    >381           LDA   LBLTAB+L1,X 
34D4: D9 00 A7    >382           CMP   SYMTAB+L1,Y 
34D7: D0 EA =34C3 >383           BNE   :STATE5A   
34D9: 0A          >384           ASL              
34DA: B0 3F =351B >385           BCS   :STATE5B   
                  >386  
34DC: BD 00 A0    >387           LDA   LBLTAB+L2,X 
34DF: D9 00 A8    >388           CMP   SYMTAB+L2,Y 
34E2: D0 DF =34C3 >389           BNE   :STATE5A   
34E4: 0A          >390           ASL              
34E5: B0 34 =351B >391           BCS   :STATE5B   
                  >392  
34E7: BD 00 A1    >393           LDA   LBLTAB+L3,X 
34EA: D9 00 A9    >394           CMP   SYMTAB+L3,Y 
34ED: D0 D4 =34C3 >395           BNE   :STATE5A   
34EF: 0A          >396           ASL              
34F0: B0 29 =351B >397           BCS   :STATE5B   
                  >398  
34F2: BD 00 A2    >399           LDA   LBLTAB+L4,X 
34F5: D9 00 AA    >400           CMP   SYMTAB+L4,Y 
34F8: D0 C9 =34C3 >401           BNE   :STATE5A   
34FA: 0A          >402           ASL              
34FB: B0 1E =351B >403           BCS   :STATE5B   
                  >404  
34FD: BD 00 A3    >405           LDA   LBLTAB+L5,X 
3500: D9 00 AB    >406           CMP   SYMTAB+L5,Y 
3503: D0 BE =34C3 >407           BNE   :STATE5A   
3505: 0A          >408           ASL              
3506: B0 13 =351B >409           BCS   :STATE5B   
                  >410  
3508: BD 00 A4    >411           LDA   LBLTAB+L6,X 
350B: D9 00 AC    >412           CMP   SYMTAB+L6,Y 
350E: D0 B3 =34C3 >413           BNE   :STATE5A   
3510: 0A          >414           ASL              
3511: B0 08 =351B >415           BCS   :STATE5B   
                  >416  
3513: BD 00 A5    >417           LDA   LBLTAB+L7,X 
3516: D9 00 AD    >418           CMP   SYMTAB+L7,Y 
3519: D0 A8 =34C3 >419           BNE   :STATE5A   
                  >420  
351B: B9 00 AE    >421  :STATE5B LDA   SYMTAB+L8,Y 
351E: 9D 00 9E    >422           STA   LBLTAB,X   ;copy label address
3521: B9 00 AF    >423           LDA   SYMTAB+L9,Y 
3524: 9D 00 9F    >424           STA   LBLTAB+L1,X 
3527: 4C 80 34    >425           JMP   :STATE5    
                  >426  
                  >427  *-------------------------------
                  >428  * ----- pass 3 -----
                  >429  *-------------------------------
                  >430  
352A: A2 80       >431  :STATE6  LDX   #128       ;start counters
352C: A0 00       >432           LDY   #0         
352E: B9 00 9E    >433  :STATE6D LDA   LBLTAB,Y   
3531: 9D 08 02    >434           STA   LNBUF+8,X  ;move first address
3534: B9 00 9F    >435           LDA   LBLTAB+L1,Y 
3537: 9D 09 02    >436           STA   LNBUF+9,X  
353A: C8          >437           INY              ;inc address #
353B: 18          >438           CLC              
353C: 8A          >439           TXA              
353D: 69 10       >440           ADC   #16        ;move dest pointer
353F: AA          >441           TAX              
3540: 90 EC =352E >442           BCC   :STATE6D   ;more data, keep going
                  >443  
3542: A9 00       >444           LDA   #<CODEND   ;point at module
3544: 85 00       >445           STA   TEMP       
3546: A9 51       >446           LDA   #>CODEND   
3548: 85 01       >447           STA   TEMP+1     
                  >448  
354A: A0 00       >449  :STATE6A LDY   #0         
354C: B1 00       >450           LDA   (TEMP),Y   
354E: C9 7F       >451           CMP   #QUIT      
3550: F0 21 =3573 >452           BEQ   :STATE6C   
                  >453  
3552: C9 00       >454           CMP   #LABEL     
3554: D0 15 =356B >455           BNE   :STATE6B   
                  >456  
3556: C8          >457           INY              
3557: B1 00       >458           LDA   (TEMP),Y   ;get label address
3559: AA          >459           TAX              ;and insert into code
355A: BD 00 9F    >460           LDA   LBLTAB+L1,X 
355D: 91 00       >461           STA   (TEMP),Y   
355F: 88          >462           DEY              
3560: BD 00 9E    >463           LDA   LBLTAB,X   
3563: 91 00       >464           STA   (TEMP),Y   
                  >465  
3565: E6 00       >466           INC   TEMP       
3567: D0 02 =356B >467           BNE   :STATE6B   ;inc pointers
3569: E6 01       >468           INC   TEMP+1     
                  >469  
356B: E6 00       >470  :STATE6B INC   TEMP       
356D: D0 DB =354A >471           BNE   :STATE6A   
356F: E6 01       >472           INC   TEMP+1     
3571: D0 D7 =354A >473           BNE   :STATE6A   
                  >474  
3573: AE 72 30    >475  :STATE6C LDX   FLNAME     ;add '.C' back on
3576: A9 43       >476           LDA   #'C'       
3578: 9D 72 30    >477           STA   FLNAME,X   
                  >478  
357B: A0 2B       >479           LDY   #a2obj     ;user defined filetype
357D: A9 80       >480           LDA   #>comfile  
357F: A2 01       >481           LDX   #<comfile  
3581: 20 88 30    >482           JSR   CREATE     
                  >483  
3584: 20 B6 30    >484           JSR   OPEN       
3587: B0 34 =35BD >485           BCS   :STATE6E   ;if problem
                  >486  
3589: AD 42 DF    >487           LDA   MSGREF     ;save msg refnum
358C: 48          >488           PHA              
358D: AD CD 03    >489           LDA   REFNUM     
3590: 8D 42 DF    >490           STA   MSGREF     ;and replace with current
                  >491  
3593: A9 47       >492           LDA   #'G'       ;save i/d bytes
3595: 8D 8C 02    >493           STA   LNBUF+140  
3598: A9 53       >494           LDA   #'S'       
359A: 8D 8D 02    >495           STA   LNBUF+141  
                  >496  
359D: A2 80       >497           LDX   #<LNBUF+128 ;write out header (with label info)
359F: A9 02       >498           LDA   #>LNBUF+128 
35A1: A0 01       >499           LDY   #1         
35A3: 20 38 31    >500           JSR   WRBLK      
                  >501  
35A6: 38          >502           SEC              
35A7: A5 6A       >503           LDA   LOMEM+1    
35A9: E9 51       >504           SBC   #>CODEND   ;find # of pages in module
35AB: 0A          >505           ASL              ;multiply by 2 into blocks
35AC: A8          >506           TAY              
35AD: C8          >507           INY              ;add in extra page just in case
35AE: C8          >508           INY              
                  >509  
35AF: A2 00       >510           LDX   #<CODEND   ;write rest of data
35B1: A9 51       >511           LDA   #>CODEND   
35B3: 20 38 31    >512           JSR   WRBLK      
                  >513  
35B6: 20 D8 30    >514           JSR   CLOSE      ;finish up
35B9: 68          >515           PLA              
35BA: 8D 42 DF    >516           STA   MSGREF     ;and restore
                  >517  
35BD: A2 03       >518  :STATE6E LDX   #compwipe  
35BF: 20 BF 19    >519           JSR   PRCMPMSG   
35C2: 4C E8 1B    >520           JMP   PAUSE      ;were done
                  >521  
                  >522  *-------------------------------
                  >523  * ----- add to symbol table ----
                  >524  *-------------------------------
                  >525  
35C5: A0 FF       >526  ADD_SYM  LDY   #-1        
35C7: C8          >527  :ADD_SM2 INY              ;find last char of label
35C8: B9 00 02    >528           LDA   LNBUF,Y    
35CB: 20 6E 17    >529           JSR   CONV       ;convert to uppercase
35CE: 99 00 02    >530           STA   LNBUF,Y    
35D1: C9 20       >531           CMP   #' '       
35D3: F0 08 =35DD >532           BEQ   :ADD_SM3   
35D5: C9 3A       >533           CMP   #':'       
35D7: F0 04 =35DD >534           BEQ   :ADD_SM3   
35D9: C9 0D       >535           CMP   #cr        
35DB: D0 EA =35C7 >536           BNE   :ADD_SM2   
                  >537  
35DD: 88          >538  :ADD_SM3 DEY              
35DE: B9 00 02    >539           LDA   LNBUF,Y    ;set high-bit of last char
35E1: 09 80       >540           ORA   #hibit     
35E3: 99 00 02    >541           STA   LNBUF,Y    
                  >542  
35E6: AD 07 02    >543           LDA   LNBUF+7    ;mark last char just in case
35E9: 09 80       >544           ORA   #hibit     
35EB: 8D 07 02    >545           STA   LNBUF+7    
                  >546  
35EE: AE 36 DF    >547           LDX   SYMNUM     ;check for overflow
35F1: E0 FF       >548           CPX   #$FF       
35F3: F0 24 =3619 >549           BEQ   :ADD_SM6   
                  >550  
35F5: A9 A6       >551           LDA   #>SYMTAB   
35F7: 8D 03 36    >552           STA   :ADD_SM5+2 ;set up table
35FA: A0 FF       >553           LDY   #-1        
35FC: C8          >554  :ADD_SM4 INY              
35FD: B9 00 02    >555           LDA   LNBUF,Y    
3600: 08          >556           PHP              
3601: 9D 00 A6    >557  :ADD_SM5 STA   SYMTAB,X   ;*** self-modified ***
3604: EE 03 36    >558           INC   :ADD_SM5+2 
3607: 28          >559           PLP              
3608: 10 F2 =35FC >560           BPL   :ADD_SM4   ;loop until done
                  >561  
360A: A5 00       >562           LDA   TEMP       
360C: 9D 00 AE    >563           STA   SYMTAB+L8,X ;save label location
360F: A5 01       >564           LDA   TEMP+1     
3611: 9D 00 AF    >565           STA   SYMTAB+L9,X 
3614: EE 36 DF    >566           INC   SYMNUM     ;add to table
3617: 18          >567           CLC              
3618: 60          >568           RTS              
                  >569  
3619: 38          >570  :ADD_SM6 SEC              ;symbol tabel overflow
361A: 60          >571           RTS              
                  >572  
                  >573  *-------------------------------
                  >574  * ----- add to label table -----
                  >575  *-------------------------------
                  >576  
361B: A2 06       >577  ADD_L12  LDX   #nosymbol  
361D: 20 73 19    >578           JSR   SHERR      ;missing symbol
3620: 38          >579           SEC              
3621: 60          >580           RTS              
                  >581  
3622: AC 38 DF    >582  ADD_LBL  LDY   LNCNT      
3625: 88          >583           DEY              
3626: C8          >584  :ADD_LB1 INY              
3627: B9 00 02    >585           LDA   LNBUF,Y    
362A: C9 0D       >586           CMP   #cr        
362C: F0 ED =361B >587           BEQ   ADD_L12    ;eol?, opps, error
                  >588  
362E: 20 51 17    >589           JSR   TST_ALF    ;gobble until a legal char
3631: B0 F3 =3626 >590           BCS   :ADD_LB1   
3633: 8C 38 DF    >591           STY   LNCNT      ;save new location
3636: 88          >592           DEY              
3637: A2 08       >593           LDX   #8         
3639: C8          >594  :ADD_LB2 INY              ;find last char of label
363A: B9 00 02    >595           LDA   LNBUF,Y    
363D: C9 20       >596           CMP   #' '       
363F: F0 16 =3657 >597           BEQ   :ADD_LB3   
3641: C9 3A       >598           CMP   #':'       
3643: F0 12 =3657 >599           BEQ   :ADD_LB3   
3645: C9 0D       >600           CMP   #cr        
3647: F0 0E =3657 >601           BEQ   :ADD_LB3   
                  >602  
3649: 20 6E 17    >603           JSR   CONV       ;convert to upper
364C: CA          >604           DEX              
364D: D0 02 =3651 >605           BNE   :ADD_L2A   
                  >606  
364F: 09 80       >607           ORA   #hibit     ;always fix 8th char
3651: 99 00 02    >608  :ADD_L2A STA   LNBUF,Y    
3654: 4C 39 36    >609           JMP   :ADD_LB2   
                  >610  
3657: 8C 39 DF    >611  :ADD_LB3 STY   LNCNT2     ;save new line count
365A: 88          >612           DEY              
365B: B9 00 02    >613           LDA   LNBUF,Y    ;set high-bit of last char
365E: 09 80       >614           ORA   #hibit     
3660: 99 00 02    >615           STA   LNBUF,Y    
                  >616  
3663: AE 37 DF    >617           LDX   LBLNUM     ;check for overflow
3666: E0 FF       >618           CPX   #$FF       
3668: F0 45 =36AF >619           BEQ   ADD_L11    
                  >620  
366A: A2 FF       >621           LDX   #-1        ;go through and add to table
366C: E8          >622  :ADD_LB4 INX              
366D: EC 37 DF    >623           CPX   LBLNUM     
3670: F0 1B =368D >624           BEQ   :ADD_LB7   ;add new label
                  >625  
3672: A9 9E       >626           LDA   #>LBLTAB   
3674: 8D 7F 36    >627           STA   :ADD_LB6+2 ;set up table
                  >628  
3677: AC 38 DF    >629           LDY   LNCNT      
367A: B9 00 02    >630  :ADD_LB5 LDA   LNBUF,Y    
367D: DD 00 9E    >631  :ADD_LB6 CMP   LBLTAB,X   ;*** self-modified ***
3680: 08          >632           PHP              
3681: EE 7F 36    >633           INC   :ADD_LB6+2 
3684: C8          >634           INY              
3685: 28          >635           PLP              
3686: D0 E4 =366C >636           BNE   :ADD_LB4   
                  >637  
3688: 0A          >638           ASL              ;put high-bit into carry
3689: 90 EF =367A >639           BCC   :ADD_LB5   ;loop until done
368B: B0 19 =36A6 >640           BCS   :ADD_L10   ;we already have label in table
                  >641  
368D: A9 9E       >642  :ADD_LB7 LDA   #>LBLTAB   
368F: 8D 9B 36    >643           STA   :ADD_LB9+2 ;move label into new location
3692: AC 38 DF    >644           LDY   LNCNT      
3695: B9 00 02    >645  :ADD_LB8 LDA   LNBUF,Y    
3698: 08          >646           PHP              
3699: 9D 00 9E    >647  :ADD_LB9 STA   LBLTAB,X   
369C: EE 9B 36    >648           INC   :ADD_LB9+2 
369F: C8          >649           INY              
36A0: 28          >650           PLP              
36A1: 10 F2 =3695 >651           BPL   :ADD_LB8   
                  >652  
36A3: EE 37 DF    >653           INC   LBLNUM     ;increment count
36A6: AC 39 DF    >654  :ADD_L10 LDY   LNCNT2     
36A9: 8C 38 DF    >655           STY   LNCNT      
36AC: 8A          >656           TXA              ;return label number
36AD: 18          >657           CLC              
36AE: 60          >658           RTS              
                  >659  
36AF: A2 04       >660  ADD_L11  LDX   #symfull   
36B1: 20 73 19    >661           JSR   SHERR      
36B4: 38          >662           SEC              ;symbol tabel overflow
36B5: 60          >663           RTS              
                  >664  
                  >665  *-------------------------------
                  >666  * ----- get a token -----
                  >667  *-------------------------------
                  >668  
36B6: A9 00       >669  TOKEN    LDA   #<SYMTXT   ;point at token table
36B8: 85 02       >670           STA   TEMP2      
36BA: A9 D5       >671           LDA   #>SYMTXT   
36BC: 85 03       >672           STA   TEMP2+1    
36BE: A0 00       >673           LDY   #0         
36C0: 8C 3A DF    >674           STY   TOKTYP     ;start token count
36C3: F0 0D =36D2 >675           BEQ   :TOKEN4    ;try and find a match
                  >676  
36C5: EE 3A DF    >677  :TOKEN1  INC   TOKTYP     ;try next token
36C8: B1 02       >678  :TOKEN2  LDA   (TEMP2),Y  
36CA: C8          >679           INY              
36CB: D0 02 =36CF >680           BNE   :TOKEN3    
                  >681  
36CD: E6 03       >682           INC   TEMP2+1    
36CF: 0A          >683  :TOKEN3  ASL              ;put into carry
36D0: 90 F6 =36C8 >684           BCC   :TOKEN2    ;was high bit set?
                  >685  
36D2: AE 38 DF    >686  :TOKEN4  LDX   LNCNT      ;get line offset
36D5: B1 02       >687  :TOKEN5  LDA   (TEMP2),Y  ;were done, no match
36D7: F0 1C =36F5 >688           BEQ   :TOKEN7    
                  >689  
36D9: 85 0A       >690           STA   PRN        
36DB: BD 00 02    >691           LDA   LNBUF,X    ;check it
36DE: 20 6E 17    >692           JSR   CONV       
36E1: 45 0A       >693           EOR   PRN        ;match bits
36E3: 0A          >694           ASL              ;move bit 7
36E4: D0 DF =36C5 >695           BNE   :TOKEN1    ;no match
                  >696  
36E6: E8          >697           INX              ;increment pointers
36E7: C8          >698           INY              
36E8: D0 02 =36EC >699           BNE   :TOKEN6    
36EA: E6 03       >700           INC   TEMP2+1    
                  >701  
36EC: 90 E7 =36D5 >702  :TOKEN6  BCC   :TOKEN5    ;keep checking
                  >703  
36EE: 8E 38 DF    >704           STX   LNCNT      ;save new text pointer
36F1: AD 3A DF    >705           LDA   TOKTYP     
36F4: 60          >706           RTS              
                  >707  
36F5: BD 00 02    >708  :TOKEN7  LDA   LNBUF,X    ;get char
36F8: EE 38 DF    >709           INC   LNCNT      
36FB: 20 6E 17    >710           JSR   CONV       ;make uppercase
36FE: 09 80       >711           ORA   #hibit     
3700: 60          >712           RTS              
                   40            PUT   CMD        
                  >2    ********************************
                  >3    *                              *
                  >4    *     ACOS.OBJ - Commands      *
                  >5    *                              *
                  >6    ********************************
                                  3-MAR-23   9:23:19 AM
                  >8    *-------------------------------
                  >9    * print statement
                  >10   *-------------------------------
                  >11   
3701: A2 05       >12   ERR      LDX   #syntax    
3703: 4C 91 19    >13            JMP   ERROR      
                  >14   
3706: 60          >15   NIL      RTS              
                  >16   
3707: A9 00       >17   DO_PRNT  LDA   #0         ;PRINT
3709: 20 85 24    >18            JSR   GETDEV     
370C: 20 08 1D    >19            JSR   SETOVEC    ;set output vector
370F: 4C 4C 37    >20            JMP   :DO_PR0    
                  >21   
3712: 20 1B 09    >22   :DO_PR0A JSR   VIDWND     
3715: 20 DC 18    >23            JSR   TOPSHOW    
3718: A6 22       >24            LDX   WNDTOP     
371A: E8          >25            INX              
371B: E4 25       >26            CPX   CV         
371D: 90 02 =3721 >27            BLT   :DO_PR1    
371F: 86 25       >28            STX   CV         
                  >29   
3721: 20 F2 19    >30   :DO_PR1  JSR   INPTYP     ;check for eol
3724: D0 26 =374C >31            BNE   :DO_PR0    
3726: 60          >32            RTS              
                  >33   
3727: 20 AB 1D    >34   :DO_PR1A JSR   INPNUM     ;handle "@"
372A: CA          >35            DEX              
372B: 86 24       >36            STX   CH         
372D: 20 E4 16    >37            JSR   CHKBYT     
3730: C9 AC       >38            CMP   #","       
3732: D0 18 =374C >39            BNE   :DO_PR0    
                  >40   
3734: 20 CC 16    >41            JSR   GETBYT     
3737: 20 AB 1D    >42            JSR   INPNUM     
373A: CA          >43            DEX              
373B: 86 25       >44            STX   CV         
373D: 4C 4C 37    >45            JMP   :DO_PR0    
                  >46   
3740: A9 0D       >47   :DO_PR9  LDA   #cr        ;print cr/lf
3742: 4C B5 37    >48            JMP   DO_OUT     
                  >49   
3745: A9 0D       >50   :DO_PR1B LDA   #cr        ;handle "\"
3747: 29 7F       >51            AND   #clrhi     
3749: 20 B5 37    >52   :DO_PR1C JSR   DO_OUT     
                  >53   
374C: 20 F2 19    >54   :DO_PR0  JSR   INPTYP     ;get data
374F: F0 EF =3740 >55            BEQ   :DO_PR9    ;eol?
                  >56   
3751: C9 01       >57            CMP   #1         
3753: F0 47 =379C >58            BEQ   :DO_PR5    ;token?
3755: C9 02       >59            CMP   #2         
3757: F0 28 =3781 >60            BEQ   :DO_PR2    ;hard-coded text?
3759: C9 03       >61            CMP   #3         
375B: F0 36 =3793 >62            BEQ   :DO_PR4    ;number?
375D: C9 05       >63            CMP   #5         
375F: F0 3B =379C >64            BEQ   :DO_PR5    ;string variable?
3761: C9 06       >65            CMP   #6         
3763: F0 2E =3793 >66            BEQ   :DO_PR4    ;numeric variable?
                  >67   
3765: 20 CC 16    >68            JSR   GETBYT     ;must be control
3768: C9 AC       >69            CMP   #","       
376A: F0 DD =3749 >70            BEQ   :DO_PR1C   ;print it
376C: C9 BB       >71            CMP   #";"       
376E: F0 B1 =3721 >72            BEQ   :DO_PR1    ;no cr
3770: C9 C0       >73            CMP   #"@"       
3772: F0 B3 =3727 >74            BEQ   :DO_PR1A   ;position
3774: C9 DC       >75            CMP   #"\"       
3776: F0 CD =3745 >76            BEQ   :DO_PR1B   ;cr/lf
3778: C9 DE       >77            CMP   #"^"       
377A: F0 96 =3712 >78            BEQ   :DO_PR0A   ;display top
                  >79   
377C: A2 05       >80            LDX   #syntax    ;syntax error
377E: 4C E1 12    >81            JMP   BADERR     
                  >82   
3781: 20 CC 16    >83   :DO_PR2  JSR   GETBYT     
3784: 20 CC 16    >84   :DO_PR3  JSR   GETBYT     
3787: F0 C3 =374C >85            BEQ   :DO_PR0    ;if eol
                  >86   
3789: C9 A2       >87            CMP   #"""       
378B: F0 BF =374C >88            BEQ   :DO_PR0    ;gobble
378D: 20 B5 37    >89            JSR   DO_OUT     
3790: 4C 84 37    >90            JMP   :DO_PR3    ;and loop
                  >91   
3793: 20 AB 1D    >92   :DO_PR4  JSR   INPNUM     ;get number
3796: 20 3E 1A    >93            JSR   DECOUT     
3799: 4C 4C 37    >94            JMP   :DO_PR0    
                  >95   
379C: 20 D8 1E    >96   :DO_PR5  JSR   ARGTYP     
379F: 90 F2 =3793 >97            BCC   :DO_PR4    ;if it is a number
                  >98   
37A1: 20 F7 1E    >99            JSR   INSTR2     ;set up pointers
37A4: 98          >100           TYA              
37A5: AA          >101           TAX              
37A6: E8          >102           INX              
37A7: A0 00       >103           LDY   #0         
                  >104  
37A9: CA          >105  :DO_PR6  DEX              
37AA: F0 A0 =374C >106           BEQ   :DO_PR0    ;print out string
                  >107  
37AC: B1 0D       >108           LDA   (STRLOC),Y 
37AE: 20 B5 37    >109           JSR   DO_OUT     
37B1: C8          >110           INY              
37B2: 4C A9 37    >111           JMP   :DO_PR6    
                  >112  
37B5: 6C 15 00    >113  DO_OUT   JMP   (VECTOR)   
                  >114  
                  >115  *-------------------------------
                  >116  * goto statement
                  >117  *-------------------------------
                  >118  
37B8: 20 BD 16    >119  DO_GOTO  JSR   GETRAW     ;get address
37BB: 48          >120           PHA              
37BC: 20 BD 16    >121           JSR   GETRAW     
                  >122  
37BF: 85 05       >123  DO_GT2   STA   PRGPTR+1   ;put into program counter
37C1: 68          >124           PLA              
37C2: 85 04       >125           STA   PRGPTR     
37C4: 60          >126           RTS              
                  >127  
                  >128  *-------------------------------
                  >129  * gosub statement
                  >130  *-------------------------------
                  >131  
37C5: 20 E2 37    >132  DO_GSB   JSR   TST_GSB    ;make sure there is room
37C8: 20 BD 16    >133           JSR   GETRAW     ;get address
37CB: 48          >134           PHA              
37CC: 20 BD 16    >135           JSR   GETRAW     
37CF: 48          >136           PHA              
                  >137  
37D0: A5 04       >138           LDA   PRGPTR     
37D2: 9D A6 DE    >139           STA   GSBSTK,X   ;put current address onto gosub stack
37D5: E8          >140           INX              
37D6: A5 05       >141           LDA   PRGPTR+1   
37D8: 9D A6 DE    >142           STA   GSBSTK,X   
37DB: E8          >143           INX              
37DC: 86 78       >144           STX   GSBLVL     
37DE: 68          >145           PLA              
37DF: 4C BF 37    >146           JMP   DO_GT2     ;do the goto
                  >147  
37E2: A6 78       >148  TST_GSB  LDX   GSBLVL     
37E4: E0 20       >149           CPX   #32        
37E6: D0 14 =37FC >150           BNE   :TSTGSB3   ;there's enough room
                  >151  
37E8: A2 00       >152           LDX   #0         
37EA: BD A9 DE    >153  :TSTGSB2 LDA   GSBSTK+3,X 
37ED: 9D A7 DE    >154           STA   GSBSTK+1,X ;kill oldest gosub
37F0: BD A8 DE    >155           LDA   GSBSTK+2,X 
37F3: 9D A6 DE    >156           STA   GSBSTK,X   
37F6: E8          >157           INX              
37F7: E8          >158           INX              
37F8: E0 1E       >159           CPX   #30        
37FA: D0 EE =37EA >160           BNE   :TSTGSB2   
                  >161  
37FC: 60          >162  :TSTGSB3 RTS              
                  >163  
                  >164  *-------------------------------
                  >165  * push a level onto the stack
                  >166  *-------------------------------
                  >167  
37FD: 20 E2 37    >168  DO_PUSH  JSR   TST_GSB    ;make sure there is room
3800: 20 BD 16    >169           JSR   GETRAW     ;put data onto stack
3803: 9D A6 DE    >170           STA   GSBSTK,X   
3806: E8          >171           INX              
3807: 20 BD 16    >172           JSR   GETRAW     
380A: 9D A6 DE    >173           STA   GSBSTK,X   
380D: E8          >174           INX              
380E: 86 78       >175           STX   GSBLVL     
3810: 60          >176           RTS              
                  >177  
                  >178  *-------------------------------
                  >179  * pop a level off the gosub stack
                  >180  *-------------------------------
                  >181  
3811: A4 78       >182  DO_POP   LDY   GSBLVL     ;make sure there is something to pop
3813: F0 04 =3819 >183           BEQ   :DO_POP2   ;nothing to pop -- give error
                  >184  
3815: 88          >185           DEY              
3816: 88          >186           DEY              
3817: 84 78       >187           STY   GSBLVL     
3819: 60          >188  :DO_POP2 RTS              
                  >189  
                  >190  *-------------------------------
                  >191  * return to the address on the stack
                  >192  *-------------------------------
                  >193  
381A: A2 0E       >194  DO_RET   LDX   #nogosub   
381C: A4 78       >195           LDY   GSBLVL     ;make sure there is a return address
381E: F0 0F =382F >196           BEQ   DO_RET3    ;nothing to return to -- give error
                  >197  
3820: 88          >198           DEY              
3821: B9 A6 DE    >199           LDA   GSBSTK,Y   
3824: 85 05       >200           STA   PRGPTR+1   ;return to caller
3826: 88          >201           DEY              
3827: B9 A6 DE    >202           LDA   GSBSTK,Y   
382A: 85 04       >203           STA   PRGPTR     
382C: 84 78       >204           STY   GSBLVL     
382E: 60          >205  DO_RET2  RTS              
                  >206  
382F: 4C E1 12    >207  DO_RET3  JMP   BADERR     ;No gosubs
                  >208  
                  >209  *-------------------------------
                  >210  * clear a device
                  >211  *-------------------------------
                  >212  
3832: 20 CC 16    >213  CLRDEV   JSR   GETBYT     ;gobble
3835: 20 AB 1D    >214           JSR   INPNUM     
3838: E0 08       >215           CPX   #8         
383A: F0 10 =384C >216           BEQ   :CLR_ED    ;clear editor?
                  >217  
383C: E0 09       >218           CPX   #9         
383E: F0 0F =384F >219           BEQ   :JCLRTOP   ;clear screen top?
                  >220  
3840: E0 0A       >221           CPX   #10        
3842: D0 EA =382E >222           BNE   DO_RET2    ;clear ram drive?
                  >223  
3844: A9 00       >224           LDA   #0         
3846: 85 75       >225           STA   RAMPTR     ;clear ram drive
3848: 8D 80 B6    >226           STA   RAMDRV     
384B: 60          >227           RTS              
                  >228  
                  >229  *-------------------------------
                  >230  * clear the editor
                  >231  *-------------------------------
                  >232  
384C: 4C 77 45    >233  :CLR_ED  JMP   ED_CLR     ;clear editor
                  >234  
                  >235  *-------------------------------
                  >236  * clear user stats at screen top
                  >237  *-------------------------------
                  >238  
384F: 4C BA 18    >239  :JCLRTOP JMP   CLRTOP     
                  >240  
                  >241  *-------------------------------
                  >242  * clear the gosub stack
                  >243  *-------------------------------
                  >244  
3852: A9 00       >245  CLRSTK   LDA   #0         
3854: 85 78       >246           STA   GSBLVL     ;reset gosub stack
3856: 4C CC 16    >247           JMP   GETBYT     ;gobble!
                  >248  
                  >249  *-------------------------------
                  >250  * clear the keyboard buffer
                  >251  *-------------------------------
                  >252  
3859: A9 00       >253  CLRKEY   LDA   #0         
385B: 85 63       >254           STA   TYPIN      ;reset type-ahead buffer
385D: 85 64       >255           STA   TYPOUT     
385F: 4C CC 16    >256           JMP   GETBYT     ;gobble!
                  >257  
                  >258  *-------------------------------
                  >259  * clear command
                  >260  *-------------------------------
                  >261  
3862: 20 E4 16    >262  DO_CLR   JSR   CHKBYT     
3865: C9 A3       >263           CMP   #"#"       
3867: F0 C9 =3832 >264           BEQ   CLRDEV     ;clear a device
3869: C9 05       >265           CMP   #gosub     
386B: F0 E5 =3852 >266           BEQ   CLRSTK     ;clear the stack
386D: C9 2A       >267           CMP   #key       
386F: F0 E8 =3859 >268           BEQ   CLRKEY     ;clear the type-ahead buffer
                  >269  
                  >270  *-------------------------------
                  >271  * clear statement
                  >272  *-------------------------------
                  >273  
3871: A9 00       >274  CLEAR    LDA   #<ENDMOD   ;save ending address
3873: 85 73       >275           STA   HIMEM      
3875: A9 9E       >276           LDA   #>ENDMOD   
3877: 85 74       >277           STA   HIMEM+1    
                  >278  
3879: A4 73       >279           LDY   HIMEM      ;clear out pointers
387B: 84 00       >280           STY   TEMP       
387D: A4 74       >281           LDY   HIMEM+1    
387F: 88          >282           DEY              
3880: 84 01       >283           STY   TEMP+1     
3882: A0 FA       >284           LDY   #$FA       
3884: A9 00       >285           LDA   #0         
3886: 85 79       >286           STA   FORLVL     ;reset for-next level
3888: 91 00       >287           STA   (TEMP),Y   
388A: A5 69       >288           LDA   LOMEM      ;reset string space
388C: 85 08       >289           STA   VARSTR     
388E: A5 6A       >290           LDA   LOMEM+1    
3890: 85 09       >291           STA   VARSTR+1   
                  >292  
3892: 38          >293           SEC              
3893: A5 74       >294           LDA   HIMEM+1    ;midmem = lomem+(himem-lomem)/2
3895: E5 6A       >295           SBC   LOMEM+1    
3897: 4A          >296           LSR              
3898: 18          >297           CLC              
3899: 65 6A       >298           ADC   LOMEM+1    
389B: 85 6E       >299           STA   MIDMEM+1   ;compute initial midmem value
389D: A9 00       >300           LDA   #0         
389F: 85 6D       >301           STA   MIDMEM     
                  >302  
38A1: 8D 32 DF    >303           STA   FROMERR    
38A4: 8D 33 DF    >304           STA   FROMERR+1  
38A7: 60          >305           RTS              
                  >306  
                  >307  *-------------------------------
                  >308  * let statement
                  >309  *-------------------------------
                  >310  
38A8: 20 E4 16    >311  DO_LET   JSR   CHKBYT     ;doing a string?
38AB: C9 02       >312           CMP   #string    
38AD: D0 03 =38B2 >313           BNE   :DO_LET0   ;nope
                  >314  
38AF: 20 BB 20    >315           JSR   CHKFRE     ;free old strings
38B2: 20 25 1D    >316  :DO_LET0 JSR   VARSET     ;set up pointers to variable
38B5: 20 EF 16    >317           JSR   GOBEQU     
                  >318  
38B8: A5 81       >319           LDA   VNAME      
38BA: 48          >320           PHA              
38BB: A5 83       >321           LDA   VPTR       ;save var address
38BD: 48          >322           PHA              
38BE: A5 84       >323           LDA   VPTR+1     
38C0: 48          >324           PHA              
                  >325  
38C1: A5 81       >326           LDA   VNAME      ;check name to see if string
38C3: 10 06 =38CB >327           BPL   :DO_LET2   ;or number
                  >328  
38C5: 20 07 1F    >329           JSR   INPSTR     ;get string address and length
38C8: 4C CE 38    >330           JMP   :DO_LET3   
                  >331  
38CB: 20 AB 1D    >332  :DO_LET2 JSR   INPNUM     
38CE: 86 00       >333  :DO_LET3 STX   TEMP       ;save a
38D0: 85 01       >334           STA   TEMP+1     
38D2: 84 07       >335           STY   SAVE_Y     
                  >336  
38D4: 68          >337           PLA              
38D5: 85 84       >338           STA   VPTR+1     ;point back at var
38D7: 68          >339           PLA              
38D8: 85 83       >340           STA   VPTR       
38DA: 68          >341           PLA              
38DB: 10 20 =38FD >342           BPL   :DO_LET5   ;if numeric
                  >343  
38DD: A0 00       >344           LDY   #0         
38DF: B1 83       >345           LDA   (VPTR),Y   
38E1: 85 02       >346           STA   TEMP2      
38E3: C8          >347           INY              
38E4: B1 83       >348           LDA   (VPTR),Y   
38E6: 85 03       >349           STA   TEMP2+1    ;see if variable is in low memory
38E8: F0 13 =38FD >350           BEQ   :DO_LET5   ;if new var...
                  >351  
38EA: C9 51       >352           CMP   #>CODEND   
38EC: B0 0F =38FD >353           BGE   :DO_LET5   ;nope
                  >354  
38EE: C8          >355           INY              
38EF: B1 83       >356           LDA   (VPTR),Y   ;get length
38F1: AA          >357           TAX              
                  >358  
38F2: A0 00       >359           LDY   #0         
38F4: B1 00       >360  :DO_LET4 LDA   (TEMP),Y   
38F6: 91 02       >361           STA   (TEMP2),Y  ;copy string
38F8: C8          >362           INY              
38F9: CA          >363           DEX              
38FA: D0 F8 =38F4 >364           BNE   :DO_LET4   
38FC: 60          >365           RTS              
                  >366  
38FD: A0 00       >367  :DO_LET5 LDY   #0         ;save low address or byte
38FF: A5 00       >368           LDA   TEMP       
3901: 91 83       >369           STA   (VPTR),Y   
3903: C8          >370           INY              
3904: A5 01       >371           LDA   TEMP+1     
3906: 91 83       >372           STA   (VPTR),Y   ;save high address or byte
3908: C8          >373           INY              
3909: A5 07       >374           LDA   SAVE_Y     
390B: 91 83       >375           STA   (VPTR),Y   ;save length
390D: A9 00       >376           LDA   #0         
390F: 85 10       >377           STA   TTLLEN     
3911: 60          >378  DO_IF4   RTS              
                  >379  
                  >380  *-------------------------------
                  >381  * if statement
                  >382  *-------------------------------
                  >383  
3912: 20 AB 1D    >384  DO_IF    JSR   INPNUM     ;evaluate expression
3915: 86 00       >385           STX   TEMP       
3917: 05 00       >386           ORA   TEMP       
3919: D0 F6 =3911 >387           BNE   DO_IF4     
                  >388  
391B: 20 37 39    >389  :DO_IF2  JSR   IFGOB      ;loop until a chain
391E: C9 09       >390           CMP   #chain2    
3920: F0 04 =3926 >391           BEQ   DO_IF3     
3922: C9 18       >392           CMP   #else      
3924: D0 F5 =391B >393           BNE   :DO_IF2    ;is there an else clause?
                  >394  
3926: 2C 9B 16    >395  DO_IF3   BIT   SHWTRC     
3929: 10 E6 =3911 >396           BPL   DO_IF4     ;just return
392B: 4C 5B 1B    >397           JMP   LIST       
                  >398  
                  >399  *-------------------------------
                  >400  * else statement
                  >401  *-------------------------------
                  >402  
392E: 20 37 39    >403  DO_ELSE  JSR   IFGOB      ;loop until a chain
3931: C9 09       >404           CMP   #chain2    
3933: D0 F9 =392E >405           BNE   DO_ELSE    
3935: F0 EF =3926 >406           BEQ   DO_IF3     ;link back to code
                  >407  
                  >408  *-------------------------------
                  >409  * gobble program bytes
                  >410  *-------------------------------
                  >411  
3937: 20 BD 16    >412  IFGOB    JSR   GETRAW     
393A: C9 04       >413           CMP   #goto      
393C: F0 08 =3946 >414           BEQ   :IFGOB1    ;is byte followed by data?
393E: C9 05       >415           CMP   #gosub     
3940: F0 04 =3946 >416           BEQ   :IFGOB1    
3942: C9 06       >417           CMP   #push      
3944: D0 CB =3911 >418           BNE   DO_IF4     ;else, return
                  >419  
3946: 20 BD 16    >420  :IFGOB1  JSR   GETRAW     
3949: 4C BD 16    >421           JMP   GETRAW     
                  >422  
                  >423  *-------------------------------
                  >424  * handle modem calls
                  >425  *-------------------------------
                  >426  
394C: 20 8F 1E    >427  DO_MDM   JSR   INPNARG    
394F: E0 03       >428           CPX   #3         
3951: B0 10 =3963 >429           BGE   :DO_MDM2   
                  >430  
3953: 8A          >431           TXA              
3954: 0A          >432           ASL              
3955: AA          >433           TAX              
3956: BD 64 39    >434           LDA   MDMJMP,X   
3959: 85 00       >435           STA   TEMP       
395B: BD 65 39    >436           LDA   MDMJMP+1,X 
395E: 85 01       >437           STA   TEMP+1     
3960: 6C 00 00    >438           JMP   (TEMP)     ;go to routine
                  >439  
3963: 60          >440  :DO_MDM2 RTS              
                  >441  
3964: 6A 39       >442  MDMJMP   DA    MDM0       ;wait for call
3966: D1 39       >443           DA    MDM1       ;hang up
3968: EF 39       >444           DA    MDM2       ;dud command for now
                  >445  
                  >446  *-------------------------------
                  >447  * handle waiting for a call
                  >448  *-------------------------------
                  >449  
396A: A9 00       >450  MDM0     LDA   #0         
396C: 8D 35 DF    >451           STA   REMOTE     
396F: 20 12 0E    >452           JSR   MDMHANG    ;hang up phone
3972: 20 09 0E    >453           JSR   MDMRSET    ;setup for answer
3975: A2 00       >454           LDX   #0         
3977: 8E 34 DF    >455           STX   NULLS      ;reset nulls
397A: 86 1C       >456           STX   EXEC       ;reset possible exec mode
397C: 86 5D       >457           STX   DOCHAT     ;reset chat mode
                  >458  
397E: CA          >459           DEX              
397F: 8E 35 DF    >460           STX   REMOTE     ;setup for local only
3982: 8E 40 3B    >461           STX   VIDECHO    ;turn off any echo
                  >462  
3985: A9 01       >463  :MDM0_1  LDA   #'A'-ctrl  
3987: 8D 27 04    >464           STA   TOPRIGHT   
                  >465  
398A: 20 21 09    >466  :MDM0_2  JSR   VIDKEY     ;check for keypress
398D: 10 14 =39A3 >467           BPL   :MDM0_3    
                  >468  
398F: 8D 10 C0    >469           STA   KBDSTRB    ;clear keyboard
3992: 29 1F       >470           AND   #$1F       ;make into [0-31] range
3994: C9 07       >471           CMP   #'G'-ctrl  
3996: F0 23 =39BB >472           BEQ   :MDM0_5    ;do local
3998: C9 11       >473           CMP   #'Q'-ctrl  
399A: F0 1C =39B8 >474           BEQ   :MDM0_4    ;quit
399C: C9 01       >475           CMP   #'A'-ctrl  
399E: D0 03 =39A3 >476           BNE   :MDM0_3    ;keep checking
                  >477  
39A0: 20 0F 0E    >478           JSR   MDMANS     ;answer phone
                  >479  
39A3: 20 0C 0E    >480  :MDM0_3  JSR   MDMRING    ;check for connect
39A6: B0 21 =39C9 >481           BCS   :MDM0_6    ;we got a connect
                  >482  
39A8: 20 F5 03    >483           JSR   USERVEC    ;do user sub-routine
39AB: AD 27 04    >484           LDA   TOPRIGHT   
39AE: C9 1A       >485           CMP   #'Z'-ctrl  
39B0: F0 D3 =3985 >486           BEQ   :MDM0_1    
39B2: EE 27 04    >487           INC   TOPRIGHT   
39B5: 4C 8A 39    >488           JMP   :MDM0_2    
                  >489  
39B8: 4C 07 13    >490  :MDM0_4  JMP   RESTART1   ;quit
                  >491  
39BB: 20 12 0E    >492  :MDM0_5  JSR   MDMHANG    ;hang up (disable AA)
39BE: A9 00       >493           LDA   #0         
39C0: 8D 35 DF    >494           STA   REMOTE     ;set to local
39C3: 8D 02 0E    >495           STA   SPCINIT    
39C6: 4C 3A 18    >496           JMP   CLRBUF     ;clear keyboard buffer
                  >497  
39C9: 20 15 0E    >498  :MDM0_6  JSR   MDMIN      ;get modem input
39CC: B0 FB =39C9 >499           BCS   :MDM0_6    ;and gobble until gone
39CE: 4C 3A 18    >500           JMP   CLRBUF     ;clear keyboard buffer
                  >501  
                  >502  *-------------------------------
                  >503  * hang up
                  >504  *-------------------------------
                  >505  * this code centers the copyright message
                  >506  * but kevin does not like it so we removed it
                  >507  *
                  >508  *MDM1 LDA #20 ;default to 40 columns
                  >509  * BIT RD80VID ;in 80 column mode?
                  >510  * BPL :CENTER ;nope
                  >511  * LDA #40 ;reset for 80 columns
                  >512  *
                  >513  *:CENTER SEC ;subtract length/2
                  >514  * SBC #COPEND-COPNOT/2
                  >515  * TAY
                  >516  * LDA #' ' ;print spaces to center
                  >517  *]LOOP JSR COUT
                  >518  * DEY
                  >519  * BPL ]LOOP
                  >520  
39D1: A9 79       >521  MDM1     LDA   #<COPNOT   ;point to data to print
39D3: 85 00       >522           STA   TEMP       
39D5: A9 4F       >523           LDA   #>COPNOT   
39D7: 85 01       >524           STA   TEMP+1     
39D9: A0 2C       >525           LDY   #COPEND-COPNOT ;set length
39DB: 88          >526           DEY              
39DC: B1 00       >527  :PRNTCPY LDA   (TEMP),Y   
39DE: 49 2C       >528           EOR   #COPEND-COPNOT ;translate
39E0: 6A          >529           ROR              
39E1: 20 7B 17    >530           JSR   COUT       
39E4: 88          >531           DEY              
39E5: 10 F5 =39DC >532           BPL   :PRNTCPY   
                  >533  
39E7: A9 00       >534  MDM1_2   LDA   #0         
39E9: 8D 35 DF    >535           STA   REMOTE     ;set local modem
39EC: 4C 12 0E    >536           JMP   MDMHANG    ;hang up phone
                  >537  
                  >538  *-------------------------------
                  >539  * dud command for now
                  >540  *-------------------------------
                  >541  
39EF: A9 00       >542  MDM2     LDA   #0         
39F1: 8D 35 DF    >543           STA   REMOTE     
39F4: 4C 24 0E    >544           JMP   MDMDTR     ;raise DTR so that we can talk to the modem
                  >545  
                  >546  *-------------------------------
                  >547  * get the length of a string
                  >548  *-------------------------------
                  >549  
39F7: 20 99 1E    >550  DO_LEN   JSR   INPSARG    ;point to string
39FA: A5 0F       >551           LDA   STRLEN     ;get length
39FC: 8D 25 DF    >552  SVDATA   STA   DATA+1     
39FF: A2 00       >553           LDX   #0         
3A01: 8E 26 DF    >554           STX   DATA+2     
3A04: E8          >555           INX              
3A05: 8E 24 DF    >556           STX   DATA       
3A08: 60          >557           RTS              
                  >558  
                  >559  *-------------------------------
                  >560  * input a line of text or data
                  >561  *-------------------------------
                  >562  
3A09: 20 BB 20    >563  DO_IN    JSR   CHKFRE     ;check the free memory
3A0C: A9 81       >564           LDA   #%10000001 
3A0E: 8D 99 16    >565           STA   INPMODE    ;default input mode
3A11: A9 00       >566           LDA   #0         
3A13: 85 34       >567           STA   INTOUT     ;reset output interrupt
3A15: 8D 00 B6    >568           STA   INTBUF     
                  >569  
3A18: 20 85 24    >570           JSR   GETDEV     ;setup dev pointer
3A1B: 20 FA 1C    >571           JSR   SETIVEC    ;set input vector
3A1E: 8E E3 28    >572           STX   SHWIN      ;save channel #
                  >573  
3A21: 20 E4 16    >574  :DO_IN2D JSR   CHKBYT     
3A24: C9 A2       >575           CMP   #"""       
3A26: F0 29 =3A51 >576           BEQ   :DO_IN2C   ;check for string
3A28: C9 DC       >577           CMP   #"\"       
3A2A: F0 1A =3A46 >578           BEQ   :DO_IN2E   
3A2C: C9 C0       >579           CMP   #"@"       
3A2E: D0 3B =3A6B >580           BNE   :DO_IN3    
                  >581  
3A30: 20 CC 16    >582           JSR   GETBYT     ;gobble "@"
3A33: 20 CC 16    >583           JSR   GETBYT     
3A36: 29 0F       >584           AND   #$F        ;see if its all ligit
3A38: A8          >585           TAY              
3A39: C0 05       >586           CPY   #5         
3A3B: B0 2E =3A6B >587           BGE   :DO_IN3    
                  >588  
3A3D: B9 C4 DC    >589           LDA   MODEBYT,Y  
3A40: 8D 99 16    >590           STA   INPMODE    ;set new mode
3A43: 4C 21 3A    >591           JMP   :DO_IN2D   
                  >592  
3A46: A9 0D       >593  :DO_IN2E LDA   #cr        ;handle "\"
3A48: 20 7B 17    >594           JSR   COUT       
3A4B: 20 CC 16    >595           JSR   GETBYT     
3A4E: 4C 21 3A    >596           JMP   :DO_IN2D   
                  >597  
3A51: 20 CC 16    >598  :DO_IN2C JSR   GETBYT     ;gobble up
3A54: 20 CC 16    >599  :DO_IN2A JSR   GETBYT     
3A57: C9 A2       >600           CMP   #"""       
3A59: F0 06 =3A61 >601           BEQ   :DO_IN2B   ;are we done?, yep
                  >602  
3A5B: 20 7B 17    >603           JSR   COUT       
3A5E: 4C 54 3A    >604           JMP   :DO_IN2A   
                  >605  
3A61: 20 E4 16    >606  :DO_IN2B JSR   CHKBYT     
3A64: C9 BB       >607           CMP   #";"       
3A66: D0 03 =3A6B >608           BNE   :DO_IN3    ;possible gobble
                  >609  
3A68: 20 CC 16    >610           JSR   GETBYT     ;gobble colon
                  >611  
3A6B: AE E3 28    >612  :DO_IN3  LDX   SHWIN      ;get back channel #
3A6E: E0 00       >613           CPX   #0         
3A70: F0 1A =3A8C >614           BEQ   :DO_IN3D   ;use console input routine
                  >615  
3A72: A2 00       >616           LDX   #0         
3A74: 20 22 3B    >617  :DO_IN3A JSR   DO_INP     ;get input line
3A77: 29 7F       >618           AND   #clrhi     
3A79: C9 0A       >619           CMP   #lf        
3A7B: F0 F7 =3A74 >620           BEQ   :DO_IN3A   ;gobble lf
                  >621  
3A7D: A8          >622           TAY              ;set zero/non-zero bit
3A7E: D0 02 =3A82 >623           BNE   :DO_IN3B   
                  >624  
3A80: A9 0D       >625           LDA   #cr        
3A82: 9D 00 02    >626  :DO_IN3B STA   LNBUF,X    ;save char
3A85: E8          >627           INX              
3A86: C9 0D       >628           CMP   #cr        
3A88: D0 EA =3A74 >629           BNE   :DO_IN3A   
3A8A: F0 03 =3A8F >630           BEQ   :DO_IN3C   ;nope, yep
                  >631  
3A8C: 20 C4 13    >632  :DO_IN3D JSR   INPLN      ;get console input line
                  >633  
3A8F: A9 00       >634  :DO_IN3C LDA   #0         
3A91: 8D 38 DF    >635           STA   LNCNT      ;reset pointer to start of line
                  >636  
3A94: 20 25 1D    >637  :DO_IN4  JSR   VARSET     
3A97: 20 E4 16    >638           JSR   CHKBYT     ;see if there's more input
3A9A: A2 0D       >639           LDX   #cr        
3A9C: C9 AC       >640           CMP   #","       
3A9E: D0 05 =3AA5 >641           BNE   :DO_IN5    
                  >642  
3AA0: 20 F3 16    >643           JSR   GOBCOM     ;gobble up char
3AA3: A2 2C       >644           LDX   #','       
3AA5: 86 02       >645  :DO_IN5  STX   TEMP2      ;save ending character
                  >646  
3AA7: A5 81       >647           LDA   VNAME      ;input a number?
3AA9: 10 51 =3AFC >648           BPL   :DO_IN8    ;yep
                  >649  
3AAB: A0 01       >650           LDY   #1         
3AAD: A5 09       >651           LDA   VARSTR+1   
3AAF: 91 83       >652           STA   (VPTR),Y   ;point at new string
3AB1: 88          >653           DEY              
3AB2: A5 08       >654           LDA   VARSTR     
3AB4: 91 83       >655           STA   (VPTR),Y   
3AB6: 84 03       >656           STY   TEMP2+1    ;zero counter
                  >657  
3AB8: AE 38 DF    >658           LDX   LNCNT      
3ABB: BD 00 02    >659  :DO_IN7  LDA   LNBUF,X    ;get input
3ABE: C9 0D       >660           CMP   #cr        
3AC0: F0 11 =3AD3 >661           BEQ   :DO_IN7A   
                  >662  
3AC2: E8          >663           INX              
3AC3: C5 02       >664           CMP   TEMP2      
3AC5: F0 0C =3AD3 >665           BEQ   :DO_IN7A   ;are we done?
                  >666  
3AC7: 91 08       >667           STA   (VARSTR),Y ;copy
3AC9: E6 03       >668           INC   TEMP2+1    ;inc length counter
                  >669  
3ACB: E6 08       >670           INC   VARSTR     
3ACD: D0 EC =3ABB >671           BNE   :DO_IN7    
3ACF: E6 09       >672           INC   VARSTR+1   
3AD1: D0 E8 =3ABB >673           BNE   :DO_IN7    
                  >674  
3AD3: 8E 38 DF    >675  :DO_IN7A STX   LNCNT      
3AD6: A0 02       >676           LDY   #2         
3AD8: A6 03       >677           LDX   TEMP2+1    ;get the length
3ADA: F0 09 =3AE5 >678           BEQ   :DO_IN7C   ;length 0
                  >679  
3ADC: AD 99 16    >680           LDA   INPMODE    
3ADF: 29 02       >681           AND   #2         
3AE1: F0 02 =3AE5 >682           BEQ   :DO_IN7C   
                  >683  
3AE3: A2 01       >684           LDX   #1         ;use length 1
3AE5: 8A          >685  :DO_IN7C TXA              
3AE6: 91 83       >686           STA   (VPTR),Y   
                  >687  
3AE8: A5 02       >688  :DO_IN7B LDA   TEMP2      ;are we done?
3AEA: C9 0D       >689           CMP   #cr        
3AEC: D0 A6 =3A94 >690           BNE   :DO_IN4    ;nope
                  >691  
3AEE: 20 E4 16    >692           JSR   CHKBYT     
3AF1: C9 DC       >693           CMP   #"\"       
3AF3: D0 06 =3AFB >694           BNE   :DO_IN7D   ;get another line?, nope
                  >695  
3AF5: 20 CC 16    >696           JSR   GETBYT     ;gobble
3AF8: 4C 6B 3A    >697           JMP   :DO_IN3    
                  >698  
3AFB: 60          >699  :DO_IN7D RTS              
                  >700  
3AFC: AD 38 DF    >701  :DO_IN8  LDA   LNCNT      
3AFF: 85 13       >702           STA   TEMP3      
3B01: A9 02       >703           LDA   #>LNBUF    
3B03: 85 14       >704           STA   TEMP3+1    
3B05: 20 2A 1B    >705           JSR   ZNUMIN     ;get number
                  >706  
3B08: A0 01       >707           LDY   #1         
3B0A: 91 83       >708           STA   (VPTR),Y   
3B0C: 88          >709           DEY              ;save it
3B0D: 8A          >710           TXA              
3B0E: 91 83       >711           STA   (VPTR),Y   
                  >712  
3B10: A6 13       >713           LDX   TEMP3      
3B12: 8E 38 DF    >714           STX   LNCNT      ;reset line counter
3B15: BD 00 02    >715           LDA   LNBUF,X    
3B18: C9 0D       >716           CMP   #cr        
3B1A: F0 CC =3AE8 >717           BEQ   :DO_IN7B   ;keep going
                  >718  
3B1C: EE 38 DF    >719           INC   LNCNT      
3B1F: 4C E8 3A    >720           JMP   :DO_IN7B   ;finish up
                  >721  
3B22: 6C 56 00    >722  DO_INP   JMP   (VECTOR2)  ;get a byte of input
                  >723  
3B25: A9 00       >724  NO_INP   LDA   #0         ;no input available
3B27: 60          >725  NO_OUT   RTS              
                  >726  
                  >727  *-------------------------------
                  >728  * set echo
                  >729  *-------------------------------
                  >730  
3B28: 20 EF 16    >731  DO_ECHO  JSR   GOBEQU     ;gobble equal sign
3B2B: 20 07 1F    >732           JSR   INPSTR     
3B2E: A9 FF       >733           LDA   #$FF       
3B30: A4 0F       >734           LDY   STRLEN     ;see if it is legal 1 char
3B32: C0 01       >735           CPY   #1         
3B34: D0 06 =3B3C >736           BNE   :DO_ECH2   
                  >737  
3B36: A0 00       >738           LDY   #0         
3B38: B1 0D       >739           LDA   (STRLOC),Y ;get char and save
3B3A: 29 7F       >740           AND   #clrhi     
3B3C: 8D 40 3B    >741  :DO_ECH2 STA   VIDECHO    
                  >742  
3B3F: 60          >743           RTS              
                  >744  
3B40: FF          >745  VIDECHO  DB    -1         
                  >746  
                  >747  *-------------------------------
                  >748  * get the instr()
                  >749  *-------------------------------
                  >750  
3B41: 20 99 1E    >751  DO_INST  JSR   INPSARG    
3B44: A5 0F       >752           LDA   STRLEN     ;save address and length of string
3B46: 48          >753           PHA              
3B47: A5 0D       >754           LDA   STRLOC     
3B49: 48          >755           PHA              
3B4A: A5 0E       >756           LDA   STRLOC+1   
3B4C: 48          >757           PHA              
                  >758  
3B4D: 20 99 1E    >759           JSR   INPSARG    ;get other string
                  >760  
3B50: 68          >761           PLA              
3B51: 85 01       >762           STA   TEMP+1     ;restore first string info
3B53: 68          >763           PLA              
3B54: 85 00       >764           STA   TEMP       
3B56: 68          >765           PLA              
3B57: 85 02       >766           STA   TEMP2      
                  >767  
3B59: 20 E4 16    >768           JSR   CHKBYT     ;Lane Roathe - support optional index [,start]
3B5C: A2 00       >769           LDX   #0         ;default index is zero
3B5E: C9 AC       >770           CMP   #","       
3B60: D0 09 =3B6B >771           BNE   :DO_NSR0   
                  >772  
3B62: 20 F3 16    >773           JSR   GOBCOM     ;eat ,
3B65: 20 AB 1D    >774           JSR   INPNUM     ;get index in X
3B68: 20 CC 16    >775           JSR   GETBYT     ;eat )
                  >776  :DO_NSR0                  
3B6B: E0 00       >777           CPX   #0         
3B6D: F0 01 =3B70 >778           BEQ   :DO_NSR1   
3B6F: CA          >779           DEX              
                  >780  :DO_NSR1                  
3B70: 86 03       >781           STX   TEMP2+1    
                  >782  
3B72: A2 01       >783           LDX   #1         ;def location is 1 for null match
3B74: A5 02       >784           LDA   TEMP2      
3B76: F0 3B =3BB3 >785           BEQ   :DO_NSR7   ;if null string, always match
                  >786  
3B78: 38          >787           SEC              
3B79: A5 0F       >788           LDA   STRLEN     
3B7B: E5 03       >789           SBC   TEMP2+1    ;how many chars to search after index?
3B7D: 90 43 =3BC2 >790           BCC   :DO_NSR6   ; none!
3B7F: 85 0F       >791           STA   STRLEN     
                  >792  
3B81: 18          >793           CLC              
3B82: A5 0D       >794           LDA   STRLOC     
3B84: 65 03       >795           ADC   TEMP2+1    ;advance source string past index
3B86: 85 0D       >796           STA   STRLOC     
3B88: A5 0E       >797           LDA   STRLOC+1   
3B8A: 69 00       >798           ADC   #0         
3B8C: 85 0E       >799           STA   STRLOC+1   
                  >800  
3B8E: 38          >801           SEC              
3B8F: A5 0F       >802           LDA   STRLEN     ;how many chars to search?
3B91: E5 02       >803           SBC   TEMP2      
3B93: 90 2D =3BC2 >804           BCC   :DO_NSR6   ;none!
                  >805  
3B95: AA          >806           TAX              
3B96: E8          >807           INX              
3B97: 86 03       >808           STX   TEMP2+1    ;save passes plus 1
                  >809  
3B99: A2 00       >810           LDX   #0         ;start at pass 0
3B9B: A0 00       >811  :DO_NSR2 LDY   #0         ;start checking at byte 0
3B9D: B1 00       >812  :DO_NSR3 LDA   (TEMP),Y   ;get first byte
3B9F: 20 6E 17    >813           JSR   CONV       ;make upper
3BA2: 85 13       >814           STA   TEMP3      ;save
3BA4: B1 0D       >815           LDA   (STRLOC),Y ;get second byte
3BA6: 20 6E 17    >816           JSR   CONV       ;make upper
3BA9: C5 13       >817           CMP   TEMP3      
3BAB: D0 0A =3BB7 >818           BNE   :DO_NSR4   ;do they match?, nope
                  >819  
3BAD: C8          >820           INY              ;inc pointer
3BAE: C4 02       >821           CPY   TEMP2      
3BB0: D0 EB =3B9D >822           BNE   :DO_NSR3   ;we done?, nope
                  >823  
3BB2: E8          >824           INX              ;get pass+1
3BB3: 8A          >825  :DO_NSR7 TXA              
3BB4: 4C FC 39    >826           JMP   SVDATA     ;return
                  >827  
3BB7: E6 0D       >828  :DO_NSR4 INC   STRLOC     ;check against next byte
3BB9: D0 02 =3BBD >829           BNE   :DO_NSR5   
3BBB: E6 0E       >830           INC   STRLOC+1   
3BBD: E8          >831  :DO_NSR5 INX              ;count up passes
3BBE: E4 03       >832           CPX   TEMP2+1    
3BC0: D0 D9 =3B9B >833           BNE   :DO_NSR2   ;are we done?, nope
                  >834  
3BC2: A9 00       >835  :DO_NSR6 LDA   #0         ;no match
3BC4: 4C FC 39    >836           JMP   SVDATA     
                  >837  
3BC7: A2 09       >838           LDX   #badtype   ;type mismatch error
3BC9: 4C E1 12    >839           JMP   BADERR     
                  >840  
                  >841  *-------------------------------
                  >842  * get the left$
                  >843  *-------------------------------
                  >844  
3BCC: 20 25 3C    >845  DO_LFT   JSR   DO_ISTR    ;get string and length
3BCF: 4C 1C 3C    >846           JMP   DO_XSTR    ;we're done
                  >847  
                  >848  *-------------------------------
                  >849  * get the right$
                  >850  *-------------------------------
                  >851  
3BD2: 20 25 3C    >852  DO_RGT   JSR   DO_ISTR    
3BD5: 38          >853           SEC              
3BD6: A5 03       >854           LDA   TEMP2+1    
3BD8: E5 02       >855           SBC   TEMP2      ;find out how much is to be used
3BDA: F0 0B =3BE7 >856           BEQ   :DO_RGT2   
                  >857  
3BDC: 18          >858           CLC              
3BDD: 65 00       >859           ADC   TEMP       ;get start of string
3BDF: 85 00       >860           STA   TEMP       
3BE1: A9 00       >861           LDA   #0         
3BE3: 65 01       >862           ADC   TEMP+1     
3BE5: 85 01       >863           STA   TEMP+1     
3BE7: 4C 1C 3C    >864  :DO_RGT2 JMP   DO_XSTR    ;finish up
                  >865  
                  >866  *-------------------------------
                  >867  * get the mid$
                  >868  *-------------------------------
                  >869  
3BEA: 20 25 3C    >870  DO_MID   JSR   DO_ISTR    ;point to string
3BED: C6 02       >871           DEC   TEMP2      
                  >872  
3BEF: 18          >873           CLC              
3BF0: A5 02       >874           LDA   TEMP2      
3BF2: 65 00       >875           ADC   TEMP       
3BF4: 85 00       >876           STA   TEMP       ;get start of string
3BF6: A9 00       >877           LDA   #0         
3BF8: 65 01       >878           ADC   TEMP+1     
3BFA: 85 01       >879           STA   TEMP+1     
                  >880  
3BFC: 20 E4 16    >881           JSR   CHKBYT     
3BFF: A2 FF       >882           LDX   #-1        
3C01: C9 AC       >883           CMP   #","       
3C03: D0 09 =3C0E >884           BNE   :DO_MID2   ;see if there is a length arg, nope
                  >885  
3C05: 20 F3 16    >886           JSR   GOBCOM     ;gobble
3C08: 20 AB 1D    >887           JSR   INPNUM     ;get it
3C0B: 20 CC 16    >888           JSR   GETBYT     ;gobble )
                  >889  
3C0E: 38          >890  :DO_MID2 SEC              
3C0F: A5 03       >891           LDA   TEMP2+1    
3C11: E5 02       >892           SBC   TEMP2      ;compute maximum length
                  >893  
3C13: 86 03       >894           STX   TEMP2+1    
3C15: C5 03       >895           CMP   TEMP2+1    
3C17: 90 01 =3C1A >896           BLT   :DO_MID3   ;find out which to use
                  >897  
3C19: 8A          >898           TXA              
3C1A: 85 02       >899  :DO_MID3 STA   TEMP2      
                  >900  
3C1C: A6 00       >901  DO_XSTR  LDX   TEMP       ;return string loc & length
3C1E: A5 01       >902           LDA   TEMP+1     
3C20: A4 02       >903           LDY   TEMP2      
3C22: 4C 9E 42    >904           JMP   SVSTR      
                  >905  
3C25: 20 A1 1E    >906  DO_ISTR  JSR   INPARG     ;get the string
3C28: A5 0D       >907           LDA   STRLOC     ;save string info
3C2A: 85 00       >908           STA   TEMP       
3C2C: A5 0E       >909           LDA   STRLOC+1   
3C2E: 85 01       >910           STA   TEMP+1     
3C30: A5 0F       >911           LDA   STRLEN     
3C32: 85 03       >912           STA   TEMP2+1    
                  >913  
3C34: 20 8F 1E    >914           JSR   INPNARG    
3C37: 86 02       >915           STX   TEMP2      ;get the number
3C39: E4 03       >916           CPX   TEMP2+1    
3C3B: 90 02 =3C3F >917           BLT   :DO_IST2   ;make length legal
                  >918  
3C3D: A6 03       >919           LDX   TEMP2+1    
3C3F: 86 02       >920  :DO_IST2 STX   TEMP2      
3C41: 60          >921           RTS              
                  >922  
                  >923  *-------------------------------
                  >924  * handle the chr$() function
                  >925  *-------------------------------
                  >926  
3C42: 20 8F 1E    >927  DO_CHR   JSR   INPNARG    ;get char number
3C45: 8A          >928           TXA              
3C46: 48          >929           PHA              
                  >930  
3C47: 20 E4 16    >931           JSR   CHKBYT     
3C4A: A2 01       >932           LDX   #1         ;check for more data
3C4C: C9 AC       >933           CMP   #","       
3C4E: D0 03 =3C53 >934           BNE   :DO_CHR2   
                  >935  
3C50: 20 8F 1E    >936           JSR   INPNARG    
3C53: 8E 27 DF    >937  :DO_CHR2 STX   DATA+3     ;get number of chars
                  >938  
3C56: A5 08       >939           LDA   VARSTR     ;point to string
3C58: 8D 25 DF    >940           STA   DATA+1     
3C5B: A5 09       >941           LDA   VARSTR+1   
3C5D: 8D 26 DF    >942           STA   DATA+2     
                  >943  
3C60: 68          >944           PLA              
3C61: A0 00       >945           LDY   #0         
3C63: 91 08       >946  :DO_CHR3 STA   (VARSTR),Y ;create string
3C65: E6 08       >947           INC   VARSTR     
3C67: D0 02 =3C6B >948           BNE   :DO_CHR4   
3C69: E6 09       >949           INC   VARSTR+1   
                  >950  
3C6B: CA          >951  :DO_CHR4 DEX              
3C6C: D0 F5 =3C63 >952           BNE   :DO_CHR3   
                  >953  
3C6E: A9 02       >954           LDA   #2         
3C70: 8D 24 DF    >955           STA   DATA       ;data type 2
3C73: 60          >956           RTS              
                  >957  
                  >958  *-------------------------------
                  >959  * get the value from a string
                  >960  *-------------------------------
                  >961  
3C74: 20 CC 16    >962  DO_VAL   JSR   GETBYT     ;gobble (
3C77: 20 F7 1E    >963           JSR   INSTR2     ;don't use any space
3C7A: A4 0F       >964           LDY   STRLEN     
3C7C: A9 00       >965           LDA   #0         
3C7E: 99 00 02    >966           STA   LNBUF,Y    ;terminate string
3C81: 88          >967  :DO_VAL2 DEY              
3C82: 30 08 =3C8C >968           BMI   :DO_VAL3   
                  >969  
3C84: B1 0D       >970           LDA   (STRLOC),Y 
3C86: 99 00 02    >971           STA   LNBUF,Y    ;copy string
3C89: 4C 81 3C    >972           JMP   :DO_VAL2   
                  >973  
3C8C: A9 00       >974  :DO_VAL3 LDA   #<LNBUF    ;point to string
3C8E: 85 13       >975           STA   TEMP3      
3C90: A9 02       >976           LDA   #>LNBUF    
3C92: 85 14       >977           STA   TEMP3+1    
3C94: 20 2A 1B    >978           JSR   ZNUMIN     ;get number
3C97: 8E 25 DF    >979           STX   DATA+1     
3C9A: 8D 26 DF    >980           STA   DATA+2     
3C9D: 20 CC 16    >981           JSR   GETBYT     ;gobble )
3CA0: A9 01       >982           LDA   #1         
3CA2: 8D 24 DF    >983           STA   DATA       ;data type 1
3CA5: 60          >984           RTS              
                  >985  
                  >986  *-------------------------------
                  >987  * set interupt key to spacevar (for editor)
                  >988  *-------------------------------
                  >989  
3CA6: 38          >990  DO_SED   SEC              ;set flag
3CA7: B0 01 =3CAA >991           BCS   XINT       
                  >992  
                  >993  *-------------------------------
                  >994  * set interupt keys that can be used
                  >995  *-------------------------------
                  >996  
3CA9: 18          >997  DO_SINT  CLC              ;fall into aint routine
3CAA: 08          >998  XINT     PHP              
3CAB: A0 7F       >999           LDY   #127       
3CAD: A9 00       >1000          LDA   #0         
3CAF: 85 34       >1001          STA   INTOUT     ;reset output
3CB1: 99 00 B6    >1002 :SINT2   STA   INTBUF,Y   ;clear int buffer
3CB4: 88          >1003          DEY              
3CB5: 10 FA =3CB1 >1004          BPL   :SINT2     ;loop and fall into "addint"
3CB7: 28          >1005          PLP              ;restore status
3CB8: B0 19 =3CD3 >1006          BCS   AINT0      ;just enable spacebar
                  >1007 
                  >1008 *-------------------------------
                  >1009 * add interupt keys
                  >1010 *-------------------------------
                  >1011 
3CBA: 20 A1 1E    >1012 DO_AINT  JSR   INPARG     ;get arg
3CBD: 4A          >1013          LSR              
3CBE: B0 27 =3CE7 >1014          BCS   AINT1      ;error, should be a string
                  >1015 
3CC0: AE 28 DF    >1016          LDX   NUMB       
3CC3: E0 01       >1017          CPX   #1         
3CC5: F0 0C =3CD3 >1018          BEQ   AINT0      ;fix stop char
3CC7: E0 02       >1019          CPX   #2         
3CC9: D0 36 =3D01 >1020          BNE   AINT3      ;there's a problem
                  >1021 
3CCB: A9 FF       >1022          LDA   #$FF       
3CCD: AE 0F 08    >1023          LDX   NXTCHR     ;flag "next-message" char
3CD0: 9D 00 B6    >1024          STA   INTBUF,X   
                  >1025 
3CD3: A9 FF       >1026 AINT0    LDA   #$FF       
3CD5: AE 0E 08    >1027          LDX   STPCHR     ;flag "stop-message" char
3CD8: 9D 00 B6    >1028          STA   INTBUF,X   
3CDB: 8D 00 B6    >1029          STA   INTBUF     ;enable int's
3CDE: 8D 7F B6    >1030          STA   INTBUF+127 ;special int flag
3CE1: A9 00       >1031          LDA   #0         
3CE3: 8D 19 18    >1032          STA   INTCHR     ;clear int char
3CE6: 60          >1033          RTS              
                  >1034 
3CE7: 4A          >1035 AINT1    LSR              ;put arg count into carry
                  >1036 
3CE8: C6 0F       >1037          DEC   STRLEN     
3CEA: D0 12 =3CFE >1038          BNE   AINT2      
3CEC: 08          >1039          PHP              
3CED: A0 00       >1040          LDY   #0         
3CEF: B1 0D       >1041          LDA   (STRLOC),Y ;get key
3CF1: 20 6E 17    >1042          JSR   CONV       
                  >1043 
3CF4: A8          >1044          TAY              
3CF5: A9 FF       >1045          LDA   #$FF       
3CF7: 8D 00 B6    >1046          STA   INTBUF     ;enable int
3CFA: 99 00 B6    >1047          STA   INTBUF,Y   ;mark as an int key
3CFD: 28          >1048          PLP              
3CFE: B0 BA =3CBA >1049 AINT2    BCS   DO_AINT    
3D00: 60          >1050          RTS              
                  >1051 
3D01: A2 09       >1052 AINT3    LDX   #badtype   ;type mismatch error
3D03: 4C E1 12    >1053          JMP   BADERR     
                  >1054 
                  >1055 *-------------------------------
                  >1056 * get a single character
                  >1057 *-------------------------------
                  >1058 
3D06: 20 BB 20    >1059 DO_GET   JSR   CHKFRE     ;make sure enough memory
3D09: A9 00       >1060          LDA   #0         
3D0B: 85 34       >1061          STA   INTOUT     ;reset output
3D0D: 8D 00 B6    >1062          STA   INTBUF     
3D10: 20 25 1D    >1063          JSR   VARSET     ;setup var
3D13: A5 81       >1064          LDA   VNAME      
3D15: 10 EA =3D01 >1065          BPL   AINT3      ;its a number
                  >1066 
3D17: 20 26 17    >1067          JSR   CHKTIME    ;check for timeout
3D1A: 90 2A =3D46 >1068          BCC   :DO_GET3   ;opps, timeout!
                  >1069 
3D1C: 20 C3 14    >1070 :DO_GET0 JSR   KEYIN      ;get the char
3D1F: 24 5D       >1071          BIT   DOCHAT     
3D21: 10 08 =3D2B >1072          BPL   :DO_GET2   ;all is well
                  >1073 
3D23: C6 5E       >1074          DEC   INCHAT     
3D25: 20 9F 1C    >1075          JSR   DO_CHAT    ;handle chat
3D28: 4C 1C 3D    >1076          JMP   :DO_GET0   
                  >1077 
3D2B: 20 6E 17    >1078 :DO_GET2 JSR   CONV       
3D2E: A0 00       >1079          LDY   #0         
3D30: 91 08       >1080          STA   (VARSTR),Y ;save character
                  >1081 
3D32: A5 08       >1082          LDA   VARSTR     
3D34: 91 83       >1083          STA   (VPTR),Y   ;point to char
3D36: C8          >1084          INY              
3D37: A5 09       >1085          LDA   VARSTR+1   
3D39: 91 83       >1086          STA   (VPTR),Y   
3D3B: C8          >1087          INY              
3D3C: A9 01       >1088          LDA   #1         
3D3E: 91 83       >1089          STA   (VPTR),Y   ;length 1
                  >1090 
3D40: E6 08       >1091          INC   VARSTR     
3D42: D0 02 =3D46 >1092          BNE   :DO_GET3   ;inc string space
3D44: E6 09       >1093          INC   VARSTR+1   
                  >1094 
3D46: 60          >1095 :DO_GET3 RTS              
                  >1096 
                  >1097 *-------------------------------
                  >1098 * set up variable pointers
                  >1099 *-------------------------------
                  >1100 
3D47: 20 25 1D    >1101 DO_SET   JSR   VARSET     ;set up pointers
3D4A: 20 EF 16    >1102          JSR   GOBEQU     
                  >1103 
3D4D: 20 E4 16    >1104          JSR   CHKBYT     ;set to null?
3D50: C9 A2       >1105          CMP   #"""       
3D52: D0 12 =3D66 >1106          BNE   :SET2      ;nope
                  >1107 
3D54: 20 CC 16    >1108          JSR   GETBYT     ;gobble quotes
3D57: 20 CC 16    >1109          JSR   GETBYT     
                  >1110 
3D5A: A5 08       >1111          LDA   VARSTR     ;point at empty space
3D5C: 85 00       >1112          STA   TEMP       
3D5E: A5 09       >1113          LDA   VARSTR+1   
3D60: 85 01       >1114          STA   TEMP+1     
3D62: A2 00       >1115          LDX   #0         ;set length to zero
3D64: F0 1E =3D84 >1116          BEQ   :SET3      
                  >1117 
3D66: A5 83       >1118 :SET2    LDA   VPTR       
3D68: 48          >1119          PHA              
3D69: A5 84       >1120          LDA   VPTR+1     ;save current pointers
3D6B: 48          >1121          PHA              
                  >1122 
3D6C: 20 AB 1D    >1123          JSR   INPNUM     ;get address of string
3D6F: 48          >1124          PHA              
3D70: 8A          >1125          TXA              
3D71: 48          >1126          PHA              
3D72: 20 F3 16    >1127          JSR   GOBCOM     
3D75: 20 AB 1D    >1128          JSR   INPNUM     ;get length of string
                  >1129 
3D78: 68          >1130          PLA              
3D79: 85 00       >1131          STA   TEMP       ;restore address of string
3D7B: 68          >1132          PLA              
3D7C: 85 01       >1133          STA   TEMP+1     
                  >1134 
3D7E: 68          >1135          PLA              
3D7F: 85 84       >1136          STA   VPTR+1     ;restore pointers to orig var
3D81: 68          >1137          PLA              
3D82: 85 83       >1138          STA   VPTR       
                  >1139 
3D84: A0 02       >1140 :SET3    LDY   #2         
3D86: 8A          >1141          TXA              ;save file length
3D87: 91 83       >1142          STA   (VPTR),Y   
3D89: 88          >1143          DEY              
                  >1144 
3D8A: A5 01       >1145          LDA   TEMP+1     
3D8C: 91 83       >1146          STA   (VPTR),Y   ;save high byte of address
3D8E: 88          >1147          DEY              
3D8F: A5 00       >1148          LDA   TEMP       
3D91: 91 83       >1149          STA   (VPTR),Y   ;save low byte of address
3D93: 60          >1150          RTS              
                  >1151 
                  >1152 *-------------------------------
                  >1153 * get a number in string form
                  >1154 *-------------------------------
                  >1155 
3D94: 20 8F 1E    >1156 DO_STR   JSR   INPNARG    ;get arg
                  >1157 
3D97: A5 15       >1158          LDA   VECTOR     ;save current vector value
3D99: 48          >1159          PHA              
3D9A: A5 16       >1160          LDA   VECTOR+1   
3D9C: 48          >1161          PHA              
                  >1162 
3D9D: A9 06       >1163          LDA   #<NIL      ;suppress output
3D9F: 85 15       >1164          STA   VECTOR     
3DA1: A9 37       >1165          LDA   #>NIL      
3DA3: 85 16       >1166          STA   VECTOR+1   
                  >1167 
3DA5: 20 FF 1D    >1168          JSR   GETNUMB    ;print number to memory
3DA8: 20 3E 1A    >1169          JSR   DECOUT     
                  >1170 
3DAB: 68          >1171          PLA              
3DAC: 85 16       >1172          STA   VECTOR+1   ;restore vector
3DAE: 68          >1173          PLA              
3DAF: 85 15       >1174          STA   VECTOR     
                  >1175 
3DB1: A5 08       >1176          LDA   VARSTR     ;point to string
3DB3: 8D 25 DF    >1177          STA   DATA+1     
3DB6: A5 09       >1178          LDA   VARSTR+1   
3DB8: 8D 26 DF    >1179          STA   DATA+2     
                  >1180 
3DBB: AD 18 DF    >1181          LDA   TXTNUM     
3DBE: 8D 27 DF    >1182          STA   DATA+3     ;save length
                  >1183 
3DC1: A0 00       >1184          LDY   #0         
3DC3: A2 01       >1185          LDX   #1         
3DC5: BD 18 DF    >1186 :DO_STR2 LDA   TXTNUM,X   
3DC8: 91 08       >1187          STA   (VARSTR),Y ;copy byte
3DCA: E8          >1188          INX              
3DCB: E6 08       >1189          INC   VARSTR     
3DCD: D0 02 =3DD1 >1190          BNE   :DO_STR3   ;point to next byte
3DCF: E6 09       >1191          INC   VARSTR+1   
                  >1192 
3DD1: CE 18 DF    >1193 :DO_STR3 DEC   TXTNUM     
3DD4: D0 EF =3DC5 >1194          BNE   :DO_STR2   ;count the digits
                  >1195 
3DD6: A9 02       >1196          LDA   #2         
3DD8: 8D 24 DF    >1197          STA   DATA       ;we're done
3DDB: 60          >1198          RTS              
                  >1199 
                  >1200 *-------------------------------
                  >1201 * "not" a value
                  >1202 *-------------------------------
                  >1203 
3DDC: 20 AB 1D    >1204 DO_NOT   JSR   INPNUM     ;get value
3DDF: 86 00       >1205          STX   TEMP       
3DE1: A2 01       >1206          LDX   #1         
3DE3: 05 00       >1207          ORA   TEMP       ;see if its zero or non-zero
3DE5: F0 01 =3DE8 >1208          BEQ   :DO_NOT2   
                  >1209 
3DE7: CA          >1210          DEX              
3DE8: 8A          >1211 :DO_NOT2 TXA              
3DE9: 4C FC 39    >1212          JMP   SVDATA     ;save result
                  >1213 
                  >1214 *-------------------------------
                  >1215 * check a flag
                  >1216 *-------------------------------
                  >1217 
3DEC: 20 E4 16    >1218 DO_FLAG  JSR   CHKBYT     
3DEF: C9 A8       >1219          CMP   #"("       
3DF1: F0 1A =3E0D >1220          BEQ   :FLAG2     ;is there an arg?, yep
                  >1221 
3DF3: 24 6B       >1222          BIT   IMMDEF     ;was it an assignment?
3DF5: 10 0D =3E04 >1223          BPL   :FLAG1     ;nope
                  >1224 
3DF7: 20 EF 16    >1225          JSR   GOBEQU     ;gobble equal's
3DFA: 20 AB 1D    >1226          JSR   INPNUM     ;get location
3DFD: 8E 77 3E    >1227          STX   FLGPTR     ;that's it!
3E00: 8D 78 3E    >1228          STA   FLGPTR+1   
3E03: 60          >1229          RTS              
                  >1230 
3E04: AE 77 3E    >1231 :FLAG1   LDX   FLGPTR     ;get current pointer
3E07: AD 78 3E    >1232          LDA   FLGPTR+1   
3E0A: 4C 9A 21    >1233          JMP   DO_MATH    ;and return
                  >1234 
3E0D: 24 6B       >1235 :FLAG2   BIT   IMMDEF     ;check exec status
3E0F: 08          >1236          PHP              ;and save it
                  >1237 
3E10: 20 8F 1E    >1238          JSR   INPNARG    ;get arg
3E13: 8A          >1239          TXA              
3E14: 29 07       >1240          AND   #%00000111 ;save bit number
3E16: AA          >1241          TAX              
3E17: BD 6F 3E    >1242          LDA   BITVAL,X   
3E1A: 85 02       >1243          STA   TEMP2      ;convert to bit value
3E1C: 4E 29 DF    >1245          LSR   NUMB+1     
3E1F: 6E 28 DF    >1246          ROR   NUMB       
3E22: 4E 29 DF    >1245          LSR   NUMB+1     
3E25: 6E 28 DF    >1246          ROR   NUMB       
3E28: 4E 29 DF    >1245          LSR   NUMB+1     
3E2B: 6E 28 DF    >1246          ROR   NUMB       
3E2E: 18          >1248          CLC              
3E2F: AD 28 DF    >1249          LDA   NUMB       
3E32: 6D 77 3E    >1250          ADC   FLGPTR     
3E35: 85 00       >1251          STA   TEMP       ;add in start
3E37: AD 29 DF    >1252          LDA   NUMB+1     
3E3A: 6D 78 3E    >1253          ADC   FLGPTR+1   
3E3D: 85 01       >1254          STA   TEMP+1     
                  >1255 
3E3F: 28          >1256          PLP              
3E40: 30 0D =3E4F >1257          BMI   :FLAG4     ;yep
                  >1258 
3E42: A0 00       >1259          LDY   #0         
3E44: B1 00       >1260          LDA   (TEMP),Y   ;get byte
3E46: 25 02       >1261          AND   TEMP2      ;and value
3E48: F0 02 =3E4C >1262          BEQ   :FLAG3     
                  >1263 
3E4A: A9 01       >1264          LDA   #1         ;return flag setting
3E4C: 4C FC 39    >1265 :FLAG3   JMP   SVDATA     
                  >1266 
3E4F: 20 EF 16    >1267 :FLAG4   JSR   GOBEQU     ;gobble equal's
3E52: 20 AB 1D    >1268          JSR   INPNUM     
3E55: A0 00       >1269          LDY   #0         
3E57: AD 28 DF    >1270          LDA   NUMB       ;check for zero
3E5A: 0D 29 DF    >1271          ORA   NUMB+1     
3E5D: D0 09 =3E68 >1272          BNE   :FLAG5     ;non-zero
                  >1273 
3E5F: A5 02       >1274          LDA   TEMP2      ;get bit
3E61: 49 FF       >1275          EOR   #$FF       ;make into mask
3E63: 31 00       >1276          AND   (TEMP),Y   ;kill bit
3E65: 91 00       >1277          STA   (TEMP),Y   ;save
3E67: 60          >1278          RTS              
                  >1279 
3E68: A5 02       >1280 :FLAG5   LDA   TEMP2      ;get bit
3E6A: 11 00       >1281          ORA   (TEMP),Y   ;add in
3E6C: 91 00       >1282          STA   (TEMP),Y   ;save
3E6E: 60          >1283          RTS              
                  >1284 
3E6F: 01 02 04 08 >1285 BITVAL   HEX   0102040810204080 
                  >1286 
3E77: 00 00       >1287 FLGPTR   DA    0          
                  >1288 
                  >1289 *-------------------------------
                  >1290 * get value of a nibble
                  >1291 *-------------------------------
                  >1292 
3E79: 20 E4 16    >1293 DO_NIB   JSR   CHKBYT     ;do they want to check data?
3E7C: C9 A8       >1294          CMP   #"("       
3E7E: F0 16 =3E96 >1295          BEQ   :NIB2      ;yep
                  >1296 
3E80: 24 6B       >1297          BIT   IMMDEF     ;get address
3E82: 10 0B =3E8F >1298          BPL   :NIB1      
                  >1299 
3E84: 20 EF 16    >1300          JSR   GOBEQU     ;gobble
3E87: 20 AB 1D    >1301          JSR   INPNUM     
3E8A: 86 65       >1302          STX   NIBPTR     ;save pointer
3E8C: 85 66       >1303          STA   NIBPTR+1   
3E8E: 60          >1304          RTS              
                  >1305 
3E8F: A6 65       >1306 :NIB1    LDX   NIBPTR     ;get point to nibble
3E91: A5 66       >1307          LDA   NIBPTR+1   
3E93: 4C 9A 21    >1308          JMP   DO_MATH    
                  >1309 
3E96: 24 6B       >1310 :NIB2    BIT   IMMDEF     ;is this an assignment?
3E98: 08          >1311          PHP              
3E99: 20 8F 1E    >1312          JSR   INPNARG    ;get arg
3E9C: 28          >1313          PLP              
3E9D: 30 10 =3EAF >1314          BMI   :NIB4      ;yep
                  >1315 
3E9F: 8A          >1316          TXA              
3EA0: 4A          >1317          LSR              ;divide by 2
3EA1: A8          >1318          TAY              
3EA2: B1 65       >1319          LDA   (NIBPTR),Y ;get byte
                  >1320 
3EA4: B0 04 =3EAA >1321          BCS   :NIB3      ;nope
                  >1322 
3EA6: 4A          >1324          LSR              
3EA7: 4A          >1324          LSR              
3EA8: 4A          >1324          LSR              
3EA9: 4A          >1324          LSR              
3EAA: 29 0F       >1326 :NIB3    AND   #$F        ;get rid of any extra
3EAC: 4C FC 39    >1327          JMP   SVDATA     
                  >1328 
3EAF: 8A          >1329 :NIB4    TXA              
3EB0: 48          >1330          PHA              
                  >1331 
3EB1: 20 EF 16    >1332          JSR   GOBEQU     ;gobble
3EB4: 20 AB 1D    >1333          JSR   INPNUM     
                  >1334 
3EB7: 68          >1335          PLA              ;get back offset
3EB8: 4A          >1336          LSR              ;divide
3EB9: A8          >1337          TAY              ;save
                  >1338 
3EBA: 08          >1339          PHP              
3EBB: 8A          >1340          TXA              ;get data
3EBC: C9 10       >1341          CMP   #16        
3EBE: 90 02 =3EC2 >1342          BLT   :NIB4A     ;in range?, yep
                  >1343 
3EC0: A9 0F       >1344          LDA   #15        ;set to max
3EC2: 85 00       >1345 :NIB4A   STA   TEMP       ;save
3EC4: 0A          >1347          ASL              
3EC5: 0A          >1347          ASL              
3EC6: 0A          >1347          ASL              
3EC7: 0A          >1347          ASL              
3EC8: 85 01       >1349          STA   TEMP+1     ;save x 16
                  >1350 
3ECA: 28          >1351          PLP              
3ECB: B0 09 =3ED6 >1352          BCS   :NIB5      ;do appropriate save
                  >1353 
3ECD: B1 65       >1354          LDA   (NIBPTR),Y ;get orig byte
3ECF: 29 0F       >1355          AND   #$F        ;kill old stuff
3ED1: 05 01       >1356          ORA   TEMP+1     ;insert new
3ED3: 91 65       >1357          STA   (NIBPTR),Y ;save
3ED5: 60          >1358          RTS              
                  >1359 
3ED6: B1 65       >1360 :NIB5    LDA   (NIBPTR),Y ;get orig byte
3ED8: 29 F0       >1361          AND   #$F0       ;kill old
3EDA: 05 00       >1362          ORA   TEMP       ;insert new
3EDC: 91 65       >1363          STA   (NIBPTR),Y ;save
3EDE: 60          >1364          RTS              
                  >1365 
                  >1366 *-------------------------------
                  >1367 * get value of a byte (like peek)
                  >1368 *-------------------------------
                  >1369 
3EDF: 20 E4 16    >1370 DO_BYT   JSR   CHKBYT     ;set the pointer?
3EE2: C9 A8       >1371          CMP   #"("       
3EE4: F0 16 =3EFC >1372          BEQ   :BYT2      ;nope
                  >1373 
3EE6: 24 6B       >1374          BIT   IMMDEF     ;do they want to know what it is?
3EE8: 10 0B =3EF5 >1375          BPL   :BYT1      ;yep
                  >1376 
3EEA: 20 EF 16    >1377          JSR   GOBEQU     ;gobble
3EED: 20 AB 1D    >1378          JSR   INPNUM     
3EF0: 86 67       >1379          STX   BYTPTR     ;save new pointer
3EF2: 85 68       >1380          STA   BYTPTR+1   
3EF4: 60          >1381          RTS              
                  >1382 
3EF5: A6 67       >1383 :BYT1    LDX   BYTPTR     ;return current pointer
3EF7: A5 68       >1384          LDA   BYTPTR+1   
3EF9: 4C 9A 21    >1385          JMP   DO_MATH    
                  >1386 
3EFC: 24 6B       >1387 :BYT2    BIT   IMMDEF     ;is this an assignment?
3EFE: 08          >1388          PHP              
3EFF: 20 8F 1E    >1389          JSR   INPNARG    ;get arg
3F02: 28          >1390          PLP              
3F03: 30 08 =3F0D >1391          BMI   :BYT3      ;yep -- ^^^^
                  >1392 
3F05: AC 28 DF    >1393          LDY   NUMB       ;get index
3F08: B1 67       >1394          LDA   (BYTPTR),Y ;get data
3F0A: 4C FC 39    >1395          JMP   SVDATA     
                  >1396 
3F0D: 8A          >1397 :BYT3    TXA              
3F0E: 48          >1398          PHA              ;save arg
3F0F: 20 EF 16    >1399          JSR   GOBEQU     ;gobble
3F12: 20 AB 1D    >1400          JSR   INPNUM     ;get value
3F15: C9 00       >1401          CMP   #0         
3F17: F0 02 =3F1B >1402          BEQ   :BYT3A     ;in range?, yep
                  >1403 
3F19: A2 FF       >1404          LDX   #255       ;use max
                  >1405 
3F1B: 68          >1406 :BYT3A   PLA              
3F1C: A8          >1407          TAY              ;restore offset
                  >1408 
3F1D: 8A          >1409          TXA              
3F1E: 91 67       >1410          STA   (BYTPTR),Y ;save value
3F20: 60          >1411          RTS              
                   41            PUT   CMD2       
                  >2    ********************************
                  >3    *                              *
                  >4    *     ACOS.OBJ - Commands2     *
                  >5    *                              *
                  >6    ********************************
                                  3-MAR-23   9:23:22 AM
                  >8    *-------------------------------
                  >9    * check for keypress
                  >10   *-------------------------------
                  >11   
3F21: 20 0D 17    >12   DO_KEY   JSR   CHKDCD     ;make key check for carrier
3F24: A9 00       >13            LDA   #0         
3F26: 20 7B 17    >14            JSR   COUT       ;poll modem/keyboard
                  >15   
3F29: 20 8F 1E    >16            JSR   INPNARG    ;gobble argument
3F2C: E0 01       >17            CPX   #1         
3F2E: F0 10 =3F40 >18            BEQ   :DO_KEY3   ;check for 'stop' char?
3F30: E0 02       >19            CPX   #2         
3F32: F0 11 =3F45 >20            BEQ   :DO_KEY4   ;check for 'next' char?
3F34: E0 03       >21            CPX   #3         
3F36: F0 1B =3F53 >22            BEQ   :DO_KEY1   ;check for any int taking place
                  >23   
3F38: 20 43 18    >24            JSR   GETCHR     ;check buffer
                  >25   
3F3B: 29 7F       >26   :DO_KEY2 AND   #clrhi     
3F3D: 4C FC 39    >27            JMP   SVDATA     
                  >28   
3F40: AE 0E 08    >29   :DO_KEY3 LDX   STPCHR     ;check stop char
3F43: D0 03 =3F48 >30            BNE   :DO_KEY5   ;-- always branch
                  >31   
3F45: AE 0F 08    >32   :DO_KEY4 LDX   NXTCHR     ;check next char
3F48: A9 00       >33   :DO_KEY5 LDA   #0         
3F4A: EC 19 18    >34            CPX   INTCHR     
3F4D: D0 EC =3F3B >35            BNE   :DO_KEY2   ;did they hit it?, nope
                  >36   
3F4F: A9 01       >37            LDA   #1         ;yep
3F51: D0 E8 =3F3B >38            BNE   :DO_KEY2   ;-- always branch
                  >39   
3F53: A5 34       >40   :DO_KEY1 LDA   INTOUT     ;has output been interupted?
3F55: 4C FC 39    >41            JMP   SVDATA     
                  >42   
                  >43   *-------------------------------
                  >44   * get width from index
                  >45   *-------------------------------
                  >46   
3F58: 20 8F 1E    >47   DO_WID   JSR   INPNARG    ;get arg
3F5B: E0 05       >48            CPX   #5         
3F5D: B0 06 =3F65 >49            BGE   WOK        ;in range?, nope
                  >50   
3F5F: BD 10 08    >51            LDA   WIDTH,X    ;get width
3F62: 4C FC 39    >52            JMP   SVDATA     
                  >53   
3F65: A2 05       >54   WOK      LDX   #syntax    ;syntax error
3F67: 4C E1 12    >55   GO_ERR   JMP   BADERR     
                  >56   
                  >57   *-------------------------------
                  >58   * handle for-next statement
                  >59   *-------------------------------
                  >60   
3F6A: A5 79       >61   DO_FOR   LDA   FORLVL     
3F6C: A2 11       >62            LDX   #forfull   
3F6E: C9 10       >63            CMP   #16        
3F70: F0 F5 =3F67 >64            BEQ   GO_ERR     ;for stack full error
                  >65   
3F72: A0 02       >66            LDY   #2         ;save variable name on stk
3F74: B1 04       >67            LDA   (PRGPTR),Y ;since DO_LET could return
3F76: 48          >68            PHA              ;a possible second variable
3F77: 88          >69            DEY              ;name
3F78: B1 04       >70            LDA   (PRGPTR),Y 
3F7A: 48          >71            PHA              
3F7B: 20 A8 38    >72            JSR   DO_LET     ;do assign
                  >73   
3F7E: A6 79       >74            LDX   FORLVL     ;get level
3F80: 68          >75            PLA              ;save var pointer
3F81: 9D C6 DE    >76            STA   FORVAR,X   
3F84: 68          >77            PLA              
3F85: 9D C7 DE    >78            STA   FORVAR+1,X 
                  >79   
3F88: A2 31       >80            LDX   #to        ;gobble "TO" statement
3F8A: 20 F5 16    >81            JSR   GOBBLE     
                  >82   
3F8D: 20 AB 1D    >83            JSR   INPNUM     
3F90: A4 79       >84            LDY   FORLVL     ;get level
3F92: 99 D7 DE    >85            STA   FOREND+1,Y 
3F95: 8A          >86            TXA              
3F96: 99 D6 DE    >87            STA   FOREND,Y   ;save end value
                  >88   
3F99: A9 01       >89            LDA   #<1        
3F9B: 99 E6 DE    >90            STA   FORSTP,Y   ;save default step count (1)
3F9E: A9 00       >91            LDA   #>1        
3FA0: 99 E7 DE    >92            STA   FORSTP+1,Y 
                  >93   
3FA3: 20 E4 16    >94            JSR   CHKBYT     ;did they specify a step?
3FA6: C9 32       >95            CMP   #step      
3FA8: D0 14 =3FBE >96            BNE   :DO_FOR1   ;nope
                  >97   
3FAA: 20 CC 16    >98            JSR   GETBYT     ;gobble "step"
3FAD: 20 AB 1D    >99            JSR   INPNUM     ;get step
3FB0: A4 79       >100           LDY   FORLVL     
3FB2: 99 E7 DE    >101           STA   FORSTP+1,Y ;save desired step
3FB5: 8A          >102           TXA              
3FB6: 99 E6 DE    >103           STA   FORSTP,Y   
                  >104  
3FB9: 19 E7 DE    >105           ORA   FORSTP+1,Y ;did they try step 0?
3FBC: F0 A7 =3F65 >106           BEQ   WOK        ;the dolt! error out
                  >107  
3FBE: A6 79       >108  :DO_FOR1 LDX   FORLVL     ;save address of 'FOR' section
3FC0: A5 04       >109           LDA   PRGPTR     
3FC2: 9D F6 DE    >110           STA   FORLOC,X   
3FC5: A5 05       >111           LDA   PRGPTR+1   
3FC7: 9D F7 DE    >112           STA   FORLOC+1,X 
                  >113  
3FCA: E6 79       >114           INC   FORLVL     ;inc level
3FCC: E6 79       >115           INC   FORLVL     
3FCE: 60          >116           RTS              
                  >117  
                  >118  *-------------------------------
                  >119  * handle "next" part of for-next loop
                  >120  *-------------------------------
                  >121  
3FCF: A6 79       >122  DO_NXT   LDX   FORLVL     ;check for next without for
3FD1: F0 5D =4030 >123           BEQ   :DO_NXT6   
                  >124  
3FD3: 20 E4 16    >125           JSR   CHKBYT     ;check for specified variable
3FD6: C9 01       >126           CMP   #number    
3FD8: D0 1D =3FF7 >127           BNE   :DO_NXT2   ;none, use next on stack
                  >128  
3FDA: 20 25 1D    >129           JSR   VARSET     ;get variable
3FDD: A6 79       >130           LDX   FORLVL     ;find variable in stack
3FDF: CA          >131  :DO_NXT1 DEX              ;back down 1 level
3FE0: CA          >132           DEX              
3FE1: 30 4D =4030 >133           BMI   :DO_NXT6   
                  >134  
3FE3: BD C6 DE    >135           LDA   FORVAR,X   
3FE6: C5 81       >136           CMP   VNAME      
3FE8: D0 F5 =3FDF >137           BNE   :DO_NXT1   
                  >138  
3FEA: BD C7 DE    >139           LDA   FORVAR+1,X 
3FED: C5 82       >140           CMP   VNAME+1    
3FEF: D0 EE =3FDF >141           BNE   :DO_NXT1   
                  >142  
3FF1: E8          >143           INX              ;set the pointer into stack
3FF2: E8          >144           INX              
3FF3: 86 79       >145           STX   FORLVL     
3FF5: D0 0F =4006 >146           BNE   :DO_NXT3   
                  >147  
3FF7: CA          >148  :DO_NXT2 DEX              ;get next variable in stack
3FF8: CA          >149           DEX              
3FF9: BD C6 DE    >150           LDA   FORVAR,X   
3FFC: 85 81       >151           STA   VNAME      
3FFE: BD C7 DE    >152           LDA   FORVAR+1,X 
4001: 85 82       >153           STA   VNAME+1    
4003: 20 47 1D    >154           JSR   VARSET3    ;find variable in memory
4006: A6 79       >155  :DO_NXT3 LDX   FORLVL     ;back down to it
4008: CA          >156           DEX              
4009: CA          >157           DEX              
400A: A5 83       >158           LDA   VPTR       
400C: 85 00       >159           STA   TEMP       ;restore var pointer
400E: A5 84       >160           LDA   VPTR+1     
4010: 85 01       >161           STA   TEMP+1     
                  >162  
4012: A0 01       >163           LDY   #1         
4014: BD E7 DE    >164           LDA   FORSTP+1,X ;doing negative step?
4017: 30 18 =4031 >165           BMI   :DO_NXT7   ;yes, do it
                  >166  
4019: B1 00       >167           LDA   (TEMP),Y   ;check high - are we done?
401B: DD D7 DE    >168           CMP   FOREND+1,X 
401E: 90 26 =4046 >169           BLT   :DO_NXT9   ;no, loop
4020: F0 02 =4024 >170           BEQ   :DO_NXT4   ;hmmm, check low byte
4022: B0 08 =402C >171           BGE   :DO_NXT5   ;yes, we are done
                  >172  
4024: 88          >173  :DO_NXT4 DEY              ;check low - are we done?
4025: B1 00       >174           LDA   (TEMP),Y   
4027: DD D6 DE    >175           CMP   FOREND,X   
402A: 90 1A =4046 >176           BLT   :DO_NXT9   ;no, loop
                  >177  
402C: C6 79       >178  :DO_NXT5 DEC   FORLVL     ;conclude loop
402E: C6 79       >179           DEC   FORLVL     
4030: 60          >180  :DO_NXT6 RTS              
                  >181  
4031: B1 00       >182  :DO_NXT7 LDA   (TEMP),Y   
4033: DD D7 DE    >183           CMP   FOREND+1,X ;check high - are we done?
4036: F0 04 =403C >184           BEQ   :DO_NXT8   ;maybe, check mid byte
4038: 90 F2 =402C >185           BLT   :DO_NXT5   ;yes, finish up
403A: B0 0A =4046 >186           BGE   :DO_NXT9   ;nope, loop
                  >187  
403C: 88          >188  :DO_NXT8 DEY              ;Are we done with low byte?
403D: B1 00       >189           LDA   (TEMP),Y   
403F: DD D6 DE    >190           CMP   FOREND,X   
4042: F0 E8 =402C >191           BEQ   :DO_NXT5   ;yes, finish up
4044: 90 E6 =402C >192           BLT   :DO_NXT5   ;if less, we are done
                  >193  
4046: BD F6 DE    >194  :DO_NXT9 LDA   FORLOC,X   
4049: 85 04       >195           STA   PRGPTR     ;point to "for" location
404B: BD F7 DE    >196           LDA   FORLOC+1,X 
404E: 85 05       >197           STA   PRGPTR+1   
4050: 18          >198           CLC              ;add in step value
4051: A0 00       >199           LDY   #0         
4053: BD E6 DE    >200           LDA   FORSTP,X   
4056: 71 00       >201           ADC   (TEMP),Y   
4058: 91 00       >202           STA   (TEMP),Y   ;do low
405A: C8          >203           INY              
405B: BD E7 DE    >204           LDA   FORSTP+1,X 
405E: 71 00       >205           ADC   (TEMP),Y   
4060: 91 00       >206           STA   (TEMP),Y   ;do high
4062: 60          >207           RTS              
                  >208  
                  >209  *-------------------------------
                  >210  * move memory
                  >211  *-------------------------------
                  >212  
4063: 20 AB 1D    >213  DO_MOVE  JSR   INPNUM     ;get source address
4066: 86 02       >214           STX   TEMP2      
4068: 85 03       >215           STA   TEMP2+1    
                  >216  
406A: 20 F3 16    >217           JSR   GOBCOM     ;gobble comma
406D: 20 AB 1D    >218           JSR   INPNUM     ;get # of bytes to move
4070: 8A          >219           TXA              
4071: 48          >220           PHA              
                  >221  
4072: A2 31       >222           LDX   #to        
4074: 20 F5 16    >223           JSR   GOBBLE     ;gobble 'TO' statement
                  >224  
4077: 20 AB 1D    >225           JSR   INPNUM     ;get destination address
407A: 86 00       >226           STX   TEMP       
407C: 85 01       >227           STA   TEMP+1     
                  >228  
407E: 68          >229           PLA              
407F: AA          >230           TAX              ;get back # of bytes to move
                  >231  
4080: A0 00       >232           LDY   #0         
4082: B1 02       >233  :MOVE2   LDA   (TEMP2),Y  
4084: 91 00       >234           STA   (TEMP),Y   ;copy byte
4086: C8          >235           INY              
4087: CA          >236           DEX              
4088: D0 F8 =4082 >237           BNE   :MOVE2     ;count down, were done!
408A: 60          >238           RTS              
                  >239  
                  >240  *-------------------------------
                  >241  * get location of scratch ram
                  >242  *-------------------------------
                  >243  
408B: A2 00       >244  DO_RAM   LDX   #<SCRATCH  
408D: A9 03       >245           LDA   #>SCRATCH  
408F: 4C 9A 21    >246           JMP   DO_MATH    
                  >247  
                  >248  *-------------------------------
                  >249  * get location of aux scratch ram
                  >250  *-------------------------------
                  >251  
4092: A2 40       >252  DO_RAM2  LDX   #<SCRATCH+64 
4094: A9 03       >253           LDA   #>SCRATCH+64 
4096: 4C 9A 21    >254           JMP   DO_MATH    
                  >255  
                  >256  *-------------------------------
                  >257  * generate a random character
                  >258  *-------------------------------
                  >259  
4099: A5 C9       >260  DO_RNDS  LDA   RND        
409B: 29 1F       >261           AND   #$1F       ;make in range [0-31]
409D: C9 1A       >262           CMP   #'Z'-ctrl  
409F: 90 02 =40A3 >263           BLT   :DO_RND2   ;in range
                  >264  
40A1: E9 0A       >265           SBC   #10        ;put into range
40A3: A0 00       >266  :DO_RND2 LDY   #0         
40A5: 69 41       >267           ADC   #'A'       
40A7: 91 08       >268           STA   (VARSTR),Y ;save character
40A9: A5 CA       >269           LDA   RND+1      
40AB: 49 B4       >270           EOR   #$B4       
40AD: 65 C9       >271           ADC   RND        
40AF: 85 C9       >272           STA   RND        ;re-seed for next pass
40B1: 2A          >273           ROL              
40B2: 2A          >274           ROL              
40B3: 2A          >275           ROL              
40B4: 85 CA       >276           STA   RND+1      
                  >277  
40B6: A6 08       >278           LDX   VARSTR     ;point to random char
40B8: A5 09       >279           LDA   VARSTR+1   
40BA: C8          >280           INY              
                  >281  
40BB: E6 08       >282           INC   VARSTR     
40BD: D0 02 =40C1 >283           BNE   :DO_RND3   
40BF: E6 09       >284           INC   VARSTR+1   
40C1: 4C 9E 42    >285  :DO_RND3 JMP   SVSTR      ;save location of char
                  >286  
                  >287  *-------------------------------
                  >288  * get a random number
                  >289  *-------------------------------
                  >290  
40C4: 20 8F 1E    >291  DO_RND   JSR   INPNARG    ;get range
40C7: 86 00       >292           STX   TEMP       ;save range
40C9: 85 01       >293           STA   TEMP+1     
40CB: A8          >294           TAY              ;is it below 256?
40CC: F0 02 =40D0 >295           BEQ   :DO_RN0    ;yep, just get 8 bit seed
40CE: A5 CA       >296           LDA   RND+1      
40D0: A6 C9       >297  :DO_RN0  LDX   RND        ;get seed
                  >298  
40D2: C5 01       >299  :DO_RN2  CMP   TEMP+1     
40D4: F0 05 =40DB >300           BEQ   :DO_RN4    ;check low
40D6: B0 09 =40E1 >301           BGE   :DO_RN5    ;kill number
40D8: 4C 9A 21    >302  :DO_RN3  JMP   DO_MATH    ;return number
                  >303  
40DB: E4 00       >304  :DO_RN4  CPX   TEMP       
40DD: F0 F9 =40D8 >305           BEQ   :DO_RN3    ;check low byte
40DF: 90 F7 =40D8 >306           BLT   :DO_RN3    ;all is well, return
                  >307  
40E1: 48          >308  :DO_RN5  PHA              
40E2: 38          >309           SEC              
40E3: 8A          >310           TXA              
40E4: E5 00       >311           SBC   TEMP       ;(AX) = (AX) - range
40E6: AA          >312           TAX              
40E7: 68          >313           PLA              
40E8: E5 01       >314           SBC   TEMP+1     
40EA: B0 E6 =40D2 >315           BCS   :DO_RN2    ;loop and check
                  >316  
                  >317  *-------------------------------
                  >318  * fill a range of memory
                  >319  *-------------------------------
                  >320  
40EC: 20 AB 1D    >321  DO_FILL  JSR   INPNUM     
40EF: 86 00       >322           STX   TEMP       ;point to fill location
40F1: 85 01       >323           STA   TEMP+1     
40F3: 20 F3 16    >324           JSR   GOBCOM     ;gobble
                  >325  
40F6: 20 AB 1D    >326           JSR   INPNUM     ;get number of bytes to fill
40F9: 86 02       >327           STX   TEMP2      
40FB: 20 F3 16    >328           JSR   GOBCOM     ;gobble
                  >329  
40FE: 20 AB 1D    >330           JSR   INPNUM     ;get byte to fill with
4101: 8A          >331           TXA              
                  >332  
4102: A0 00       >333           LDY   #0         
4104: 91 00       >334  :FILL2   STA   (TEMP),Y   ;fill
4106: C8          >335           INY              
4107: C6 02       >336           DEC   TEMP2      
4109: D0 F9 =4104 >337           BNE   :FILL2     ;repeat
410B: 60          >338           RTS              
                  >339  
                  >340  *-------------------------------
                  >341  * setup no carrier vector
                  >342  *-------------------------------
                  >343  
410C: A9 00       >344  DO_NOCD  LDA   #0         
410E: 8D 2C DF    >345           STA   NOCDFLG    ;reset carrier vector
4111: 20 CC 16    >346           JSR   GETBYT     ;see if it has a vector
4114: C9 04       >347           CMP   #goto      
4116: D0 0F =4127 >348           BNE   :DO_NOC2   ;was it goto?
                  >349  
4118: 20 CC 16    >350           JSR   GETBYT     ;get low byte of routine
411B: 8D 2D DF    >351           STA   NOCDVEC    
411E: 20 CC 16    >352           JSR   GETBYT     ;get high byte of routine
4121: 8D 2E DF    >353           STA   NOCDVEC+1  
4124: CE 2C DF    >354           DEC   NOCDFLG    
4127: 60          >355  :DO_NOC2 RTS              
                  >356  
                  >357  *-------------------------------
                  >358  * return error numer
                  >359  *-------------------------------
                  >360  
4128: A5 DE       >361  DO_ERRNO LDA   ERRNO      
412A: 4C FC 39    >362           JMP   SVDATA     
                  >363  
                  >364  *-------------------------------
                  >365  * setup error vector
                  >366  *-------------------------------
                  >367  
412D: A9 00       >368  DO_ONERR LDA   #0         
412F: 8D 2F DF    >369           STA   ONERRFLG   ;reset onerr vector
4132: 20 CC 16    >370           JSR   GETBYT     ;see if it has a vector
4135: C9 04       >371           CMP   #goto      
4137: D0 0F =4148 >372           BNE   :DO_ERR2   ;was it goto?
                  >373  
4139: 20 CC 16    >374           JSR   GETBYT     ;get low byte of routine
413C: 8D 30 DF    >375           STA   ONERRVEC   
413F: 20 CC 16    >376           JSR   GETBYT     ;get high byte of routine
4142: 8D 31 DF    >377           STA   ONERRVEC+1 
4145: CE 2F DF    >378           DEC   ONERRFLG   
4148: 60          >379  :DO_ERR2 RTS              
                  >380  
                  >381  *-------------------------------
                  >382  * resume command
                  >383  *-------------------------------
                  >384  
4149: AD 32 DF    >385  DO_RESUM LDA   FROMERR    ;was there an error?
414C: 0D 33 DF    >386           ORA   FROMERR+1  
414F: F0 2D =417E >387           BEQ   :NOERR     ;no error occurred
                  >388  
4151: AD 32 DF    >389           LDA   FROMERR    ;replace error location
4154: 85 04       >390           STA   PRGPTR     
4156: AD 33 DF    >391           LDA   FROMERR+1  
4159: 85 05       >392           STA   PRGPTR+1   
                  >393  
415B: 20 E4 16    >394           JSR   CHKBYT     ;get the byte there
415E: 4C 64 41    >395           JMP   :TSTIT     
                  >396  
4161: 20 CC 16    >397  ]LOOP    JSR   GETBYT     ;get next byte
4164: C9 09       >398  :TSTIT   CMP   #chain2    ;end of line?
4166: F0 15 =417D >399           BEQ   :DONE      ;yes, continue with pgm
4168: C9 04       >400           CMP   #goto      ;a goto?
416A: F0 08 =4174 >401           BEQ   :DO_LBL    
416C: C9 05       >402           CMP   #gosub     ;a gosub?
416E: F0 04 =4174 >403           BEQ   :DO_LBL    
4170: C9 06       >404           CMP   #push      ;a push?
4172: D0 ED =4161 >405           BNE   ]LOOP      ;nope, next byte
4174: 20 BD 16    >406  :DO_LBL  JSR   GETRAW     ;skip label address
4177: 20 BD 16    >407           JSR   GETRAW     
417A: 4C 61 41    >408           JMP   ]LOOP      
                  >409  
417D: 60          >410  :DONE    RTS              
                  >411  
417E: A9 00       >412  :NOERR   LDA   #0         ;don't trap this one
4180: 8D 2F DF    >413           STA   ONERRFLG   
4183: A2 19       >414           LDX   #$19       ;no error message
4185: 4C E1 12    >415           JMP   BADERR     
                  >416  
                  >417  *-------------------------------
                  >418  * get general system to program
                  >419  *-------------------------------
                  >420  
4188: 20 8F 1E    >421  DO_INFO  JSR   INPNARG    ;get arg number
418B: E0 07       >422           CPX   #7         
418D: B0 12 =41A1 >423           BGE   :DO_INF2   
                  >424  
418F: 8A          >425           TXA              
4190: 0A          >426           ASL              ;a = a * 2
4191: AA          >427           TAX              
                  >428  
4192: BD A6 41    >429           LDA   INFOJMP,X  
4195: 85 00       >430           STA   TEMP       ;execute routine
4197: BD A7 41    >431           LDA   INFOJMP+1,X 
419A: 85 01       >432           STA   TEMP+1     
419C: 24 6B       >433           BIT   IMMDEF     
419E: 6C 00 00    >434           JMP   (TEMP)     
                  >435  
41A1: A2 05       >436  :DO_INF2 LDX   #syntax    ;syntax error
41A3: 4C E1 12    >437           JMP   BADERR     
                  >438  
41A6: B4 41       >439  INFOJMP  DW    INF0       ;get remote flag
41A8: BA 41       >440           DW    INF1       ;msg board capacity
41AA: D6 41       >441           DW    INF2       ;get users baud rate
41AC: DC 41       >442           DW    INF3       ;get/set nulls
41AE: EE 41       >443           DW    INF4       ;display chat mode
41B0: F8 41       >444           DW    INF5       ;get/set exec flags
41B2: 10 42       >445           DW    INF6       ;number of blocks free
                  >446  
                  >447  *-------------------------------
                  >448  * return online status
                  >449  *-------------------------------
                  >450  
41B4: AD 35 DF    >451  INF0     LDA   REMOTE     ;pass remote flag
41B7: 4C FC 39    >452           JMP   SVDATA     
                  >453  
41BA: A9 00       >454  INF1     LDA   #0         
41BC: 85 00       >455           STA   TEMP       ;zero temp
41BE: AD 44 DF    >456           LDA   MSGINFO+1  ;multiple by 32
41C1: 0A          >458           ASL              
41C2: 26 00       >459           ROL   TEMP       
41C4: 0A          >458           ASL              
41C5: 26 00       >459           ROL   TEMP       
41C7: 0A          >458           ASL              
41C8: 26 00       >459           ROL   TEMP       
41CA: 0A          >458           ASL              
41CB: 26 00       >459           ROL   TEMP       
41CD: 0A          >458           ASL              
41CE: 26 00       >459           ROL   TEMP       
41D0: AA          >461           TAX              
41D1: A5 00       >462           LDA   TEMP       
41D3: 4C 9A 21    >463           JMP   DO_MATH    ;return # of entries
                  >464  
                  >465  *-------------------------------
                  >466  * return users baud rate
                  >467  *-------------------------------
                  >468  
41D6: AD 02 0E    >469  INF2     LDA   SPCINIT    ;get caller speed
41D9: 4C FC 39    >470           JMP   SVDATA     
                  >471  
                  >472  *-------------------------------
                  >473  * read, or set nulls
                  >474  *-------------------------------
                  >475  
41DC: 30 06 =41E4 >476  INF3     BMI   :INF3_0    ;do set, not read
41DE: AD 34 DF    >477           LDA   NULLS      ;return current null setting
41E1: 4C FC 39    >478           JMP   SVDATA     
                  >479  
41E4: 20 EF 16    >480  :INF3_0  JSR   GOBEQU     ;set new null value
41E7: 20 AB 1D    >481           JSR   INPNUM     
41EA: 8E 34 DF    >482           STX   NULLS      
41ED: 60          >483           RTS              
                  >484  
41EE: 20 EF 16    >485  INF4     JSR   GOBEQU     ;set chat mode
41F1: 20 AB 1D    >486           JSR   INPNUM     
41F4: 8A          >487           TXA              
41F5: 4C 27 09    >488           JMP   VIDCHAT    ;carry through
                  >489  
                  >490  *-------------------------------
                  >491  * read or set EXEC mode
                  >492  *-------------------------------
                  >493  
41F8: 30 05 =41FF >494  INF5     BMI   :EXEC1     ;opps, do set, not read
41FA: A5 1C       >495           LDA   EXEC       
41FC: 4C FC 39    >496           JMP   SVDATA     ;return current exec mode
                  >497  
41FF: 20 EF 16    >498  :EXEC1   JSR   GOBEQU     
4202: A9 BF       >499           LDA   #%10111111 
4204: 85 1C       >500           STA   EXEC       ;set exec flag
4206: 20 AB 1D    >501           JSR   INPNUM     ;set new exec mode
4209: E0 00       >502           CPX   #0         
420B: D0 02 =420F >503           BNE   :EXEC2     ;it is already set
                  >504  
420D: 86 1C       >505           STX   EXEC       ;set exec to 0
420F: 60          >506  :EXEC2   RTS              
                  >507  
4210: AD 43 DF    >508  INF6     LDA   MSGINFO    
4213: 0A          >509           ASL              
4214: 0A          >510           ASL              
4215: 85 00       >511           STA   TEMP       ;save total # of bit blocks
                  >512  
4217: 38          >513           SEC              ;new code for fixing the bug found
4218: A5 00       >514           LDA   TEMP       ;by someone in a document named
421A: ED 45 DF    >515           SBC   MSGINFO+2  ;sodapatches
421D: AA          >516           TAX              
421E: A5 00       >517           LDA   TEMP       
4220: ED 46 DF    >518           SBC   MSGINFO+3  
                  >519  
4223: 29 7F       >520           AND   #clrhi     ;kill high bit
4225: 4C 9A 21    >521           JMP   DO_MATH    ;return results
                  >522  
                  >523  *-------------------------------
                  >524  * get date from 2 byte binary
                  >525  *-------------------------------
                  >526  
4228: 90 21 =424B >527  DO_WHEN  BCC   :DO_WH2    ;get data
                  >528  
422A: 20 EF 16    >529           JSR   GOBEQU     ;gobble equal's
422D: 20 D8 1E    >530           JSR   ARGTYP     ;find out data type
4230: B0 08 =423A >531           BCS   :DO_WH1    
                  >532  
4232: 20 AB 1D    >533           JSR   INPNUM     ;get location
4235: 86 17       >534           STX   WHNPTR     ;and save
4237: 85 18       >535           STA   WHNPTR+1   
4239: 60          >536           RTS              
                  >537  
423A: 20 07 1F    >538  :DO_WH1  JSR   INPSTR     ;gobble
423D: 20 02 0D    >539           JSR   GETDATE    ;get date
                  >540  
4240: A0 00       >541           LDY   #0         
4242: 48          >542           PHA              
4243: 8A          >543           TXA              
4244: 91 17       >544           STA   (WHNPTR),Y ;save compacted date
4246: C8          >545           INY              
4247: 68          >546           PLA              
4248: 91 17       >547           STA   (WHNPTR),Y 
424A: 60          >548           RTS              
                  >549  
424B: A0 00       >550  :DO_WH2  LDY   #0         
424D: B1 17       >551           LDA   (WHNPTR),Y ;get compressed date
424F: AA          >552           TAX              
4250: C8          >553           INY              
4251: B1 17       >554           LDA   (WHNPTR),Y 
4253: 4C 6A 42    >555           JMP   DO_DT2     ;translate
                  >556  
                  >557  *-------------------------------
                  >558  * get date
                  >559  *-------------------------------
                  >560  
4256: 90 0F =4267 >561  DO_DATE  BCC   :DO_DT1    ;get the date
                  >562  
4258: 20 EF 16    >563           JSR   GOBEQU     ;gobble equ
425B: 20 F7 1E    >564           JSR   INSTR2     ;get string w/o using memory
425E: A6 0D       >565           LDX   STRLOC     
4260: A5 0E       >566           LDA   STRLOC+1   
4262: A4 0F       >567           LDY   STRLEN     
4264: 4C 08 0D    >568           JMP   SETDATE    ;set the date
                  >569  
4267: 20 02 0D    >570  :DO_DT1  JSR   GETDATE    
426A: 85 00       >571  DO_DT2   STA   TEMP       ;save date data
426C: 86 01       >572           STX   TEMP+1     ;date format: YYYYYYYMMMMDDDDD
                  >573  
426E: A5 01       >574           LDA   TEMP+1     
4270: 29 1F       >575           AND   #$1F       
4272: 20 23 1A    >576           JSR   BINDEC8    ;save day
4275: 8D B0 42    >577           STA   DATESTR+3  
4278: 8E B1 42    >578           STX   DATESTR+4  
                  >579  
427B: A5 01       >580           LDA   TEMP+1     ;get most of month
427D: 46 00       >581           LSR   TEMP       ;shift last bit into carry
427F: 6A          >582           ROR              ;move bit in
4280: 4A          >584           LSR              
4281: 4A          >584           LSR              
4282: 4A          >584           LSR              
4283: 4A          >584           LSR              
4284: 20 23 1A    >586           JSR   BINDEC8    
4287: 8D AD 42    >587           STA   DATESTR    ;save month
428A: 8E AE 42    >588           STX   DATESTR+1  
                  >589  
428D: A5 00       >590           LDA   TEMP       ;get year
428F: 20 23 1A    >591           JSR   BINDEC8    ;make ascii
4292: 8D B3 42    >592           STA   DATESTR+6  
4295: 8E B4 42    >593           STX   DATESTR+7  
                  >594  
4298: A2 AD       >595           LDX   #<DATESTR  ;point to string
429A: A9 42       >596           LDA   #>DATESTR  
429C: A0 08       >597           LDY   #8         
429E: 8E 25 DF    >598  SVSTR    STX   DATA+1     
42A1: 8D 26 DF    >599           STA   DATA+2     
42A4: 8C 27 DF    >600           STY   DATA+3     
42A7: A9 02       >601           LDA   #2         
42A9: 8D 24 DF    >602           STA   DATA       
42AC: 60          >603           RTS              
                  >604  
42AD: 30 38 2F 33 >605  DATESTR  ASC   '08/31/18' 
                  >606  
                  >607  *-------------------------------
                  >608  * get time
                  >609  *-------------------------------
                  >610  
42B5: 20 05 0D    >611  DO_TIME  JSR   GETTIME    ;read clock
42B8: A0 0B       >612           LDY   #11        
42BA: D0 E2 =429E >613           BNE   SVSTR      ;return string
                  >614  
42BC: A2 00       >615  DO_FDATE LDX   #0         
42BE: 8E 93 43    >616           STX   DATEPTR    ;zero date text pointer
                  >617  
42C1: 20 02 0D    >618           JSR   GETDATE    ;get date in ProDOS format
42C4: 85 00       >619           STA   TEMP       ;save year * 2
42C6: 8A          >620           TXA              
42C7: 48          >621           PHA              
42C8: 29 1F       >622           AND   #$1F       
42CA: 85 02       >623           STA   TEMP2      ;save day of month
42CC: 68          >624           PLA              
42CD: 46 00       >625           LSR   TEMP       ;divide year by 2
42CF: 6A          >626           ROR              ;move high bit of month into A
42D0: 29 F0       >627           AND   #$F0       
42D2: 4A          >629           LSR              
42D3: 4A          >629           LSR              
42D4: 4A          >629           LSR              
42D5: 4A          >629           LSR              
42D6: 85 03       >631           STA   TEMP2+1    ;save extracted month
42D8: AA          >632           TAX              
42D9: BD 86 43    >633           LDA   MTH_CNST-1,X 
42DC: 85 13       >634           STA   TEMP3      ;get month constant
                  >635  
42DE: A6 00       >636           LDX   TEMP       ;get year
42E0: 8A          >637           TXA              
42E1: 38          >638           SEC              
42E2: E9 55       >639           SBC   #85        ;subtract 85 from year
42E4: 4A          >640           LSR              ;multiply by 2
42E5: 4A          >641           LSR              
                  >642  
42E6: 18          >643           CLC              
42E7: 65 00       >644           ADC   TEMP       ;add in year again
42E9: E9 53       >645           SBC   #83        ;subtracrt 83
42EB: 20 7F 43    >646           JSR   WEEK_MOD   ;a = a mod 7
                  >647  
42EE: A8          >648           TAY              ;save in Y
42EF: 8A          >649           TXA              ;put year in A
42F0: A2 00       >650           LDX   #0         
42F2: 29 03       >651           AND   #3         ;leap year?
42F4: F0 01 =42F7 >652           BEQ   :FDATE1    
42F6: CA          >653           DEX              
42F7: 86 01       >654  :FDATE1  STX   TEMP+1     ;save leap year flag
                  >655  
42F9: 98          >656           TYA              ;get interm day of week back
42FA: 18          >657           CLC              
42FB: 65 13       >658           ADC   TEMP3      ;add in month constant
42FD: 65 02       >659           ADC   TEMP2      ;add in day of month
                  >660  
42FF: A4 03       >661           LDY   TEMP2+1    ;get month number
4301: C0 03       >662           CPY   #3         
4303: 90 02 =4307 >663           BLT   :FDATE2    
4305: 65 01       >664           ADC   TEMP+1     ;add in leap year flag
4307: 20 7F 43    >665  :FDATE2  JSR   WEEK_MOD   ;a = a mod 7
                  >666  
430A: AA          >667           TAX              ;move day to X
430B: BC BA DD    >668           LDY   DAYINDEX,X ;get index to day text
430E: A2 04       >669           LDX   #4         ;4 characters
4310: B9 C1 DD    >670  :FDATE3  LDA   DAYS,Y     ;move the text
4313: CA          >671           DEX              
4314: F0 06 =431C >672           BEQ   :FDATE4    
4316: 20 6E 43    >673           JSR   PUTA       
4319: C8          >674           INY              
431A: D0 F4 =4310 >675           BNE   :FDATE3    
                  >676  
431C: A9 2E       >677  :FDATE4  LDA   #'.'       ;insert ". "
431E: A2 20       >678           LDX   #' '       
4320: 20 6A 43    >679           JSR   PUTAX      
                  >680  
4323: A5 03       >681           LDA   TEMP2+1    ;get the month number
4325: AA          >682           TAX              
4326: BC D5 DD    >683           LDY   MTHINDEX-1,X ;get index into month text
4329: A2 04       >684           LDX   #4         
432B: B9 E2 DD    >685  :FDATE5  LDA   MONTHS,Y   ;move month text to string
432E: CA          >686           DEX              
432F: F0 06 =4337 >687           BEQ   :FDATE6    
4331: 20 6E 43    >688           JSR   PUTA       
4334: C8          >689           INY              
4335: D0 F4 =432B >690           BNE   :FDATE5    
                  >691  
4337: A9 20       >692  :FDATE6  LDA   #' '       ;put in a space
4339: 20 6E 43    >693           JSR   PUTA       
                  >694  
433C: A5 02       >695           LDA   TEMP2      ;get day of month number
433E: 20 23 1A    >696           JSR   BINDEC8    ;make it text
4341: C9 30       >697           CMP   #'0'       
4343: D0 02 =4347 >698           BNE   :FDATE7    ;change leading 0 to space
4345: A9 20       >699           LDA   #' '       
4347: 20 6A 43    >700  :FDATE7  JSR   PUTAX      ;save day of month
                  >701  
434A: A9 2C       >702           LDA   #','       ;add in a ", "
434C: A2 20       >703           LDX   #' '       
434E: 20 6A 43    >704           JSR   PUTAX      
                  >705  
4351: A9 32       >706           LDA   #'2'       ;stuff in the leading 20
4353: A2 30       >707           LDX   #'0'       
4355: 20 6A 43    >708           JSR   PUTAX      
                  >709  
4358: A5 00       >710           LDA   TEMP       ;get year - 2000
435A: 20 23 1A    >711           JSR   BINDEC8    ;convert to text
435D: 20 6A 43    >712           JSR   PUTAX      ;save it
                  >713  
4360: A2 94       >714           LDX   #<FMTDATE  ;point to string
4362: A9 43       >715           LDA   #>FMTDATE  
4364: AC 93 43    >716           LDY   DATEPTR    ;get the length
4367: 4C 9E 42    >717           JMP   SVSTR      ;put it to program
                  >718  
436A: 20 6E 43    >719  PUTAX    JSR   PUTA       ;put the text in A
436D: 8A          >720           TXA              ;move X to A
436E: 8E 7E 43    >721  PUTA     STX   X_DATE     ;save X
4371: AE 93 43    >722           LDX   DATEPTR    ;get text pointer
4374: 9D 94 43    >723           STA   FMTDATE,X  ;store the character
4377: EE 93 43    >724           INC   DATEPTR    ;bump the length pointer
437A: AE 7E 43    >725           LDX   X_DATE     ;get back X
437D: 60          >726           RTS              
                  >727  
437E: 00          >728  X_DATE   DB    0          
                  >729  
437F: 38          >730  WEEK_MOD SEC              ;subtract 7 till < 0
4380: E9 07       >731  :MOD     SBC   #7         
4382: B0 FC =4380 >732           BCS   :MOD       
4384: 69 07       >733           ADC   #7         ;add back in 7 for MOD
4386: 60          >734           RTS              
                  >735  
4387: 00 03 03 06 >736  MTH_CNST DB    0,3,3,6,1,4,6,2,5,0,3,5 
                  >737  
4393: 00          >738  DATEPTR  DB    0          
                  >739  
4394: 46 72 69 2E >740  FMTDATE  ASC   'Fri. Aug 31, 2018' 
                  >741  
                  >742  *-------------------------------
                  >743  * do time computations
                  >744  *-------------------------------
                  >745  
43A5: 20 8F 1E    >746  DO_CLOK  JSR   INPNARG    ;get function number
43A8: E0 03       >747           CPX   #3         
43AA: B0 1D =43C9 >748           BGE   CLKRTN     
                  >749  
43AC: 8A          >750           TXA              
43AD: 0A          >751           ASL              ;x = x * 2
43AE: AA          >752           TAX              
                  >753  
43AF: BD BC 43    >754           LDA   CLKJMP,X   
43B2: 85 00       >755           STA   TEMP       ;setup address for jump
43B4: BD BD 43    >756           LDA   CLKJMP+1,X 
43B7: 85 01       >757           STA   TEMP+1     
43B9: 6C 00 00    >758           JMP   (TEMP)     
                  >759  
43BC: C2 43       >760  CLKJMP   DA    CLK0       
43BE: CA 43       >761           DA    CLK1       
43C0: D0 43       >762           DA    CLK2       
                  >763  
                  >764  *-------------------------------
                  >765  * reset timer
                  >766  *-------------------------------
                  >767  
43C2: 20 FA 43    >768  CLK0     JSR   CONVSEC    ;get base in seconds
43C5: 86 6F       >769           STX   CLKBASE    
43C7: 85 70       >770           STA   CLKBASE+1  
43C9: 60          >771  CLKRTN   RTS              
                  >772  
                  >773  *-------------------------------
                  >774  * get connect time in seconds
                  >775  *-------------------------------
                  >776  
43CA: 20 E3 43    >777  CLK1     JSR   SECON      
43CD: 4C 9A 21    >778  CLK1A    JMP   DO_MATH    ;save time
                  >779  
                  >780  *-------------------------------
                  >781  * get time limit
                  >782  *-------------------------------
                  >783  
43D0: A6 71       >784  CLK2     LDX   TIMEON     
43D2: A5 72       >785           LDA   TIMEON+1   
43D4: 24 6B       >786           BIT   IMMDEF     ;check exec status
43D6: 10 F5 =43CD >787           BPL   CLK1A      
                  >788  
43D8: 20 EF 16    >789           JSR   GOBEQU     ;gobble
43DB: 20 AB 1D    >790           JSR   INPNUM     ;get time limit
43DE: 86 71       >791           STX   TIMEON     ;save time limit
43E0: 85 72       >792           STA   TIMEON+1   
43E2: 60          >793           RTS              
                  >794  
                  >795  *-------------------------------
                  >796  * find time on in seconds
                  >797  *-------------------------------
                  >798  
43E3: 20 FA 43    >799  SECON    JSR   CONVSEC    ;get current time in seconds
43E6: 38          >800           SEC              
43E7: 48          >801           PHA              
43E8: 8A          >802           TXA              
43E9: E5 6F       >803           SBC   CLKBASE    ;time on = current - base
43EB: AA          >804           TAX              
43EC: 68          >805           PLA              
43ED: E5 70       >806           SBC   CLKBASE+1  
43EF: B0 08 =43F9 >807           BCS   :SECON1    
                  >808  
43F1: 48          >809           PHA              
43F2: 8A          >810           TXA              
43F3: 69 C0       >811           ADC   #<ROLTIME  ;time past midnight
43F5: AA          >812           TAX              ;add in rolover
43F6: 68          >813           PLA              
43F7: 69 A8       >814           ADC   #>ROLTIME  
43F9: 60          >815  :SECON1  RTS              
                  >816  
          =A8C0   >817  ROLTIME  =     43200      ;# seconds in 12 hours
                  >818  
43FA: 20 05 0D    >819  CONVSEC  JSR   GETTIME    
43FD: 86 13       >820           STX   TEMP3      ;point to time string
43FF: 85 14       >821           STA   TEMP3+1    
                  >822  
4401: A9 3C       >823           LDA   #60        
4403: 8D 25 DF    >824           STA   DATA+1     ;set up multiplier
4406: A9 00       >825           LDA   #0         
4408: 8D 26 DF    >826           STA   DATA+2     
440B: 8D 27 DF    >827           STA   DATA+3     
                  >828  
440E: 20 2A 1B    >829           JSR   ZNUMIN     ;get hour
4411: 8A          >830           TXA              
4412: D0 02 =4416 >831           BNE   :CONVSC2   ;not 0 hours
                  >832  
4414: A9 18       >833           LDA   #24        ;make 0 hundred into 24 hundred
                  >834  
4416: C9 0D       >835  :CONVSC2 CMP   #13        
4418: 90 02 =441C >836           BLT   :CONVSC3   ;is it out of range?, nope
                  >837  
441A: E9 0C       >838           SBC   #12        ;make into 1-12 range
                  >839  
441C: AA          >840  :CONVSC3 TAX              ;save result
441D: A9 00       >841           LDA   #0         
441F: 20 06 1E    >842           JSR   SAVNUMB    
4422: 20 E9 21    >843           JSR   DO_MUL0    ;multiply into minutes
                  >844  
4425: E6 13       >845           INC   TEMP3      
4427: 20 2A 1B    >846           JSR   ZNUMIN     ;get minute
                  >847  
442A: 18          >848           CLC              
442B: 8A          >849           TXA              
442C: 6D 3F DF    >850           ADC   RESULT     ;add in minutes
442F: AA          >851           TAX              
4430: A9 00       >852           LDA   #0         
4432: 6D 40 DF    >853           ADC   RESULT+1   
4435: 20 06 1E    >854           JSR   SAVNUMB    
                  >855  
4438: A9 3C       >856           LDA   #60        
443A: 8D 25 DF    >857           STA   DATA+1     ;multiply by 60
443D: 20 E9 21    >858           JSR   DO_MUL0    
                  >859  
4440: E6 13       >860           INC   TEMP3      ;position to seconds
4442: 20 2A 1B    >861           JSR   ZNUMIN     
                  >862  
4445: 18          >863           CLC              
4446: 8A          >864           TXA              
4447: 6D 3F DF    >865           ADC   RESULT     ;add in seconds
444A: AA          >866           TAX              
444B: A9 00       >867           LDA   #0         
444D: 6D 40 DF    >868           ADC   RESULT+1   
4450: 60          >869           RTS              
                  >870  
4451: 20 C8 14    >871  CHK4SN   JSR   KEYIN2     ;check for serial # access
4454: C9 3F       >872           CMP   #'?'       
4456: F0 03 =445B >873           BEQ   :SHOWSN    
                  >874  
4458: 4C 71 44    >875           JMP   :NOSHOW    
                  >876  
445B: A9 70       >877  :SHOWSN  LDA   #<SERNUM   ;print serial #
445D: 85 00       >878           STA   TEMP       
445F: A9 4F       >879           LDA   #>SERNUM   
4461: 85 01       >880           STA   TEMP+1     
                  >881  
4463: A0 09       >882           LDY   #SEREND-SERNUM ;point to data to print
4465: 88          >883           DEY              
                  >884  
4466: B1 00       >885  ]LOOP    LDA   (TEMP),Y   
4468: 49 09       >886           EOR   #SEREND-SERNUM 
446A: 6A          >887           ROR              
446B: 20 7B 17    >888           JSR   COUT       
446E: 88          >889           DEY              
446F: 10 F5 =4466 >890           BPL   ]LOOP      
                  >891  
4471: 60          >892  :NOSHOW  RTS              
                  >893  
                  >894  *-------------------------------
                  >895  * poke a value
                  >896  *-------------------------------
                  >897  
4472: 20 AB 1D    >898  DO_POKE  JSR   INPNUM     ;get place to poke
4475: 86 00       >899           STX   TEMP       
4477: 85 01       >900           STA   TEMP+1     
4479: 20 F3 16    >901           JSR   GOBCOM     ;gobble
447C: 20 AB 1D    >902           JSR   INPNUM     ;get value
447F: 8A          >903           TXA              
4480: A0 00       >904           LDY   #0         
4482: 91 00       >905           STA   (TEMP),Y   ;no offset
4484: 60          >906           RTS              
                  >907  
                  >908  *-------------------------------
                  >909  * peek a location
                  >910  *-------------------------------
                  >911  
4485: 20 8F 1E    >912  DO_PEEK  JSR   INPNARG    ;get arg
4488: 86 00       >913           STX   TEMP       
448A: 85 01       >914           STA   TEMP+1     
448C: A0 00       >915           LDY   #0         
448E: B1 00       >916           LDA   (TEMP),Y   ;get value
4490: 4C FC 39    >917           JMP   SVDATA     ;return in
                  >918  
                  >919  *-------------------------------
                  >920  * produce a tone with apple speaker
                  >921  *-------------------------------
                  >922  
4493: A9 FF       >923  DO_TONE  LDA   #$FF       
4495: 85 03       >924           STA   TEMP2+1    ;default to 1 tone
                  >925  
4497: 20 8F 1E    >926           JSR   INPNARG    ;get tone argument
449A: 86 02       >927           STX   TEMP2      
                  >928  
449C: 20 8F 1E    >929           JSR   INPNARG    ;get duration/tone2 argument
449F: 86 01       >930           STX   TEMP+1     ;save as duration
44A1: 90 0E =44B1 >931           BCC   :TONE2     ;last argument -- everything is correct
                  >932  
44A3: 20 E4 16    >933           JSR   CHKBYT     ;check for last argument
44A6: C9 AC       >934           CMP   #","       
44A8: D0 31 =44DB >935           BNE   :TONE6     ;do normal single tone
                  >936  
44AA: 86 03       >937           STX   TEMP2+1    ;save second tone
44AC: 20 8F 1E    >938           JSR   INPNARG    ;get real duration
44AF: 86 01       >939           STX   TEMP+1     ;save duration
                  >940  
44B1: 46 01       >941  :TONE2   LSR   TEMP+1     ;correct timing to match old routine
44B3: A5 03       >942           LDA   TEMP2+1    
44B5: 85 14       >943           STA   TEMP3+1    ;reset second tone
                  >944  
44B7: A5 02       >945  :TONE3   LDA   TEMP2      
44B9: 85 13       >946           STA   TEMP3      ;reset first tone
44BB: AD 30 C0    >947           LDA   SPKR       ;click speaker
                  >948  
44BE: CA          >949  :TONE4   DEX              
44BF: D0 04 =44C5 >950           BNE   :TONE5     ;time down
44C1: C6 01       >951           DEC   TEMP+1     
44C3: 30 25 =44EA >952           BMI   :TONE8     ;done with tone
                  >953  
44C5: 48          >954  :TONE5   PHA              
44C6: 68          >955           PLA              
44C7: C6 13       >956           DEC   TEMP3      
44C9: F0 EC =44B7 >957           BEQ   :TONE3     ;count down first tone
                  >958  
44CB: 48          >959           PHA              
44CC: 68          >960           PLA              ;count down second tone
44CD: C6 14       >961           DEC   TEMP3+1    
44CF: D0 ED =44BE >962           BNE   :TONE4     ;nope, do main loop
                  >963  
44D1: A5 03       >964           LDA   TEMP2+1    
44D3: 85 14       >965           STA   TEMP3+1    ;reset second tone
44D5: AD 30 C0    >966           LDA   SPKR       ;click speaker
44D8: 4C BE 44    >967           JMP   :TONE4     ;go main loop
                  >968  
44DB: CA          >969  :TONE6   DEX              
44DC: D0 05 =44E3 >970           BNE   :TONE7     
                  >971  
44DE: A6 02       >972           LDX   TEMP2      
44E0: AD 30 C0    >973           LDA   SPKR       ;modified from "keeper" code
44E3: 88          >974  :TONE7   DEY              
44E4: D0 F5 =44DB >975           BNE   :TONE6     
                  >976  
44E6: C6 01       >977           DEC   TEMP+1     
44E8: D0 F1 =44DB >978           BNE   :TONE6     
44EA: 60          >979  :TONE8   RTS              
                  >980  
44EB: A9 00       >981  DO_TEXT  LDA   #0         
44ED: 85 22       >982           STA   WNDTOP     ;set to full screen
44EF: 4C 03 09    >983  DO_HOME  JMP   VIDCLS     ;clear the local screen
                  >984  
                  >985  *-------------------------------
                  >986  * read status of a paddle
                  >987  *-------------------------------
                  >988  
44F2: 20 8F 1E    >989  DO_PDL   JSR   INPNARG    ;get paddle number
44F5: AD 70 C0    >990           LDA   PTRIG      ;toggle paddle trigger
44F8: A0 00       >991           LDY   #0         
44FA: EA          >992           NOP              ;give delay so we dont
44FB: EA          >993           NOP              ;get a false read
44FC: BD 64 C0    >994  :DO_PDL2 LDA   PDLS,X     ;check paddle flag
44FF: 10 04 =4505 >995           BPL   :DO_PDL3   ;we are done
4501: C8          >996           INY              
4502: D0 F8 =44FC >997           BNE   :DO_PDL2   ;keep counting
4504: 88          >998           DEY              ;change 0 to 255
4505: 98          >999  :DO_PDL3 TYA              
4506: 4C FC 39    >1000          JMP   SVDATA     ;return value
                  >1001 
                  >1002 *-------------------------------
                  >1003 * get ascii value of a string
                  >1004 *-------------------------------
                  >1005 
4509: 20 99 1E    >1006 DO_ASC   JSR   INPSARG    ;read string
450C: A9 FF       >1007          LDA   #-1        
450E: A6 0F       >1008          LDX   STRLEN     ;any string there?
4510: F0 04 =4516 >1009          BEQ   :DO_ASC2   ;nope, return value of 255
                  >1010 
4512: A0 00       >1011          LDY   #0         
4514: B1 0D       >1012          LDA   (STRLOC),Y 
4516: 4C FC 39    >1013 :DO_ASC2 JMP   SVDATA     ;return byte
                  >1014 
                  >1015 *-------------------------------
                  >1016 * call a machine-language rotine
                  >1017 *-------------------------------
                  >1018 
4519: 20 AB 1D    >1019 DO_CALL  JSR   INPNUM     ;get address
451C: 86 00       >1020          STX   TEMP       
451E: 85 01       >1021          STA   TEMP+1     
4520: 6C 00 00    >1022          JMP   (TEMP)     ;transfer control
                   42            PUT   EDIT       
                  >2    ********************************
                  >3    *                              *
                  >4    *      MultiPro - Editor       *
                  >5    *                              *
                  >6    ********************************
                                  3-MAR-23   9:23:25 AM
                  >8    *-------------------------------
                  >9    * system editor
                  >10   *-------------------------------
                  >11   
4523: 20 8F 1E    >12   DO_EDIT  JSR   INPNARG    ;get arg
4526: E0 06       >13            CPX   #6         
4528: B0 10 =453A >14            BGE   :ED_ERR    
                  >15   
452A: 8A          >16            TXA              
452B: 0A          >17            ASL              
452C: AA          >18            TAX              
452D: BD 3D 45    >19            LDA   EDJMP,X    
4530: 85 00       >20            STA   TEMP       
4532: BD 3E 45    >21            LDA   EDJMP+1,X  
4535: 85 01       >22            STA   TEMP+1     
4537: 6C 00 00    >23            JMP   (TEMP)     ;do it
                  >24   
453A: 4C D7 12    >25   :ED_ERR  JMP   SYNTAX     
                  >26   
453D: 77 45       >27   EDJMP    DA    ED_CLR     
453F: 49 45       >28            DA    ED_STX     
4541: 87 45       >29            DA    ED_SPC     
4543: 9E 45       >30            DA    ED_WIDTH   
4545: B5 45       >31            DA    ED_MODE    
4547: 97 45       >32            DA    ED_LOC     
                  >33   
                  >34   *-------------------------------
                  >35   * entering the editor
                  >36   *-------------------------------
                  >37   
4549: BA          >38   ED_STX   TSX              
454A: 8E 46 4C    >39            STX   EDSTACK    ;save stack
454D: 8A          >40            TXA              
454E: E9 20       >41            SBC   #32        ;move stack 32 levels down
4550: AA          >42            TAX              
4551: 9A          >43            TXS              
                  >44   
4552: A9 00       >45            LDA   #0         
4554: 8D 4E 4C    >46            STA   PROMPT     ;turn off prompts
4557: 8D 47 4C    >47            STA   EXE_DOT    ;enable dot commands
455A: 8D 00 B6    >48            STA   INTBUF     ;don't allow int's
455D: 85 34       >49            STA   INTOUT     ;make sure output is on
455F: 8D 50 4C    >50            STA   DOT_E      ;make sure '.e' is not active
4562: 85 0A       >51            STA   ERVAL      
                  >52   
4564: A9 7B       >53            LDA   #<COUT     ;point output to console/modem
4566: 85 15       >54            STA   VECTOR     
4568: A9 17       >55            LDA   #>COUT     
456A: 85 16       >56            STA   VECTOR+1   
                  >57   
456C: 20 B2 4E    >58            JSR   FINDEND    ;setup end pointers
456F: AD 00 9E    >59            LDA   EDBUF      ;check contents of buffer
4572: F0 65 =45D9 >60            BEQ   ED_LNCR    ;nothing there
                  >61   
4574: 4C 1D 46    >62            JMP   ED_CMD     ;handle command line
                  >63   
                  >64   *-------------------------------
                  >65   * clear the editor
                  >66   *-------------------------------
                  >67   
4577: A9 00       >68   ED_CLR   LDA   #0         
4579: 8D 00 9E    >69            STA   EDBUF      ;reset data pointer
457C: 85 54       >70            STA   EDLINE     ;zero line counter
457E: 85 55       >71            STA   EDLINE+1   
4580: 85 19       >72            STA   EDPTR      
4582: A9 9E       >73            LDA   #>EDBUF    
4584: 85 1A       >74            STA   EDPTR+1    
4586: 60          >75            RTS              
                  >76   
                  >77   *-------------------------------
                  >78   * return bytes in editor
                  >79   *-------------------------------
                  >80   
4587: 20 B2 4E    >81   ED_SPC   JSR   FINDEND    
458A: 38          >82            SEC              
458B: A5 19       >83            LDA   EDPTR      
458D: E9 00       >84            SBC   #<EDBUF    ;length = end - start
458F: AA          >85            TAX              
4590: A5 1A       >86            LDA   EDPTR+1    
4592: E9 9E       >87            SBC   #>EDBUF    
4594: 4C 9A 21    >88            JMP   DO_MATH    
                  >89   
                  >90   *-------------------------------
                  >91   * get location of USE buffer
                  >92   *-------------------------------
                  >93   
4597: A2 00       >94   ED_LOC   LDX   #<EDBUF    ;4k RAM area
4599: A9 9E       >95            LDA   #>EDBUF    
459B: 4C 9A 21    >96            JMP   DO_MATH    
                  >97   
459E: 24 6B       >98   ED_WIDTH BIT   IMMDEF     ;get cmd
45A0: 30 06 =45A8 >99            BMI   :WIDTH1    ;yep
                  >100  
45A2: AD 4D 4C    >101           LDA   VIDLEN     ;return current width
45A5: 4C FC 39    >102           JMP   SVDATA     
                  >103  
45A8: 20 EF 16    >104  :WIDTH1  JSR   GOBEQU     ;gobble equ
45AB: 20 AB 1D    >105           JSR   INPNUM     ;get video width
45AE: 8A          >106           TXA              
45AF: F0 03 =45B4 >107           BEQ   WIDTH2     ;opps, problem
                  >108  
45B1: 8E 4D 4C    >109           STX   VIDLEN     ;save it
45B4: 60          >110  WIDTH2   RTS              
                  >111  
                  >112  *-------------------------------
                  >113  * read or set backspace mode
                  >114  *-------------------------------
                  >115  
45B5: 24 6B       >116  ED_MODE  BIT   IMMDEF     
45B7: 30 06 =45BF >117           BMI   :MODE1     setting it
                  >118  
45B9: AD 4C 4C    >119           LDA   NONBS      
45BC: 4C FC 39    >120           JMP   SVDATA     return data
                  >121  
45BF: 20 EF 16    >122  :MODE1   JSR   GOBEQU     gobble
45C2: A9 40       >123           LDA   #$40       
45C4: 8D 4C 4C    >124           STA   NONBS      non-destruct bs mode
45C7: 20 AB 1D    >125           JSR   INPNUM     get mode
45CA: E0 01       >126           CPX   #1         
45CC: F0 E6 =45B4 >127           BEQ   WIDTH2     we were correct, return
                  >128  
45CE: 0E 4C 4C    >129           ASL   NONBS      set to destruct bs
45D1: E0 02       >130           CPX   #2         
45D3: F0 DF =45B4 >131           BEQ   WIDTH2     do it
                  >132  
45D5: 0E 4C 4C    >133           ASL   NONBS      unknown mode
45D8: 60          >134           RTS              
                  >135  
45D9: 20 EF 4E    >136  ED_LNCR  JSR   PRCRLF     add a line feed
45DC: AD 4A 4C    >137  ED_LN    LDA   WWFLAG     
45DF: 8D 49 4C    >138           STA   WWRAP      get word-wrap status
45E2: A6 19       >139  :ED_LN0  LDX   EDPTR      get a line of text
45E4: A5 1A       >140           LDA   EDPTR+1    
45E6: 20 C9 49    >141           JSR   GETEDLN    
                  >142  
45E9: 86 19       >143           STX   EDPTR      save new end address
45EB: 85 1A       >144           STA   EDPTR+1    
45ED: AD 4B 4C    >145           LDA   WWEXTRA    
45F0: D0 0F =4601 >146           BNE   :ED_LN1    
                  >147  
45F2: A9 00       >148           LDA   #0         add in end of editor
45F4: A8          >149           TAY              
45F5: 91 19       >150           STA   (EDPTR),Y  
45F7: 90 08 =4601 >151           BCC   :ED_LN1    they did not type done
                  >152  
45F9: A9 00       >153           LDA   #0         
45FB: 8D 50 4C    >154           STA   DOT_E      
45FE: 4C 1D 46    >155           JMP   ED_CMD     if they typed 'done'
                  >156  
                  >157  
4601: E6 54       >158  :ED_LN1  INC   EDLINE     
4603: D0 02 =4607 >159           BNE   :ED_LN2    add line to editor
4605: E6 55       >160           INC   EDLINE+1   
                  >161  
4607: 38          >162  :ED_LN2  SEC              
4608: A5 1A       >163           LDA   EDPTR+1    check for 3.75k
460A: E9 AD       >164           SBC   #>EBUFEND  
460C: D0 CE =45DC >165           BNE   ED_LN      there is plenty
                  >166  
460E: A9 00       >167           LDA   #0         
4610: 8D 49 4C    >168           STA   WWRAP      turn off word-wrap
4613: AD 4B 4C    >169           LDA   WWEXTRA    is there word-wrap data?
4616: D0 CA =45E2 >170           BNE   :ED_LN0    yep
4618: A2 02       >171           LDX   #thats4k   
461A: 20 B4 19    >172           JSR   PREDMSG    
                  >173  
461D: A9 00       >174  ED_CMD   LDA   #<LNBUF    point to line buffer
461F: 85 1D       >175           STA   ARGPTR     
4621: A9 02       >176           LDA   #>LNBUF    
4623: 85 1E       >177           STA   ARGPTR+1   
                  >178  
4625: A2 01       >179           LDX   #editing   
4627: 20 B4 19    >180           JSR   PREDMSG    
462A: 20 30 46    >181           JSR   ED_CMD2    
462D: 4C 1D 46    >182           JMP   ED_CMD     
                  >183  
4630: 20 DB 4C    >184  ED_CMD2  JSR   GETCMD     
4633: 20 55 4C    >185           JSR   MATCH      
4636: FF          >186           DB    -1         
4637: C4 49       >187           DA    ED_EX      
4639: 3F          >188           ASC   '?'        
463A: 71 46       >189           DA    ED_HLP     
463C: 41          >190           ASC   'A'        
463D: B0 46       >191           DA    ED_ABT     
463F: 43          >192           ASC   'C'        
4640: C7 46       >193           DA    ED_CONT    
4642: 44          >194           ASC   'D'        
4643: D9 46       >195           DA    ED_DEL     
4645: 45          >196           ASC   'E'        
4646: 23 47       >197           DA    ED_ED      
4648: 48          >198           ASC   'H'        
4649: 76 46       >199           DA    ED_HLP2    
464B: 49          >200           ASC   'I'        
464C: BF 47       >201           DA    ED_INS     
464E: 4C          >202           ASC   'L'        
464F: 2B 48       >203           DA    ED_LST     
4651: 4E          >204           ASC   'N'        
4652: 81 48       >205           DA    ED_NEW     
4654: 4F          >206           ASC   'O'        
4655: 36 49       >207           DA    ED_OK      
4657: 53          >208           ASC   'S'        
4658: 36 49       >209           DA    ED_OK      
465A: 5A          >210           ASC   'Z'        
465B: 9E 48       >211           DA    ED_USED    
465D: 00          >212           DB    0          
                  >213  
465E: 24 1C       >214           BIT   EXEC       check for sysop
4660: 10 0A =466C >215           BPL   :ED_CMD3   nope
                  >216  
4662: 20 55 4C    >217           JSR   MATCH      check the rest
4665: 52          >218           ASC   'R'        
4666: D6 48       >219           DA    ED_RD      
4668: 57          >220           ASC   'W'        
4669: 00 49       >221           DA    ED_WRT     
466B: 00          >222           DB    0          
                  >223  
466C: A2 03       >224  :ED_CMD3 LDX   #badcmd    
466E: 4C B4 19    >225           JMP   PREDMSG    
                  >226  
4671: A2 11       >227  ED_HLP   LDX   #edithelp  show the help stuff
4673: 4C B4 19    >228           JMP   PREDMSG    
                  >229  
4676: A9 A6       >230  ED_HLP2  LDA   #<HLPFILE  point to filename
4678: 85 0D       >231           STA   STRLOC     
467A: A9 46       >232           LDA   #>HLPFILE  
467C: 85 0E       >233           STA   STRLOC+1   
467E: A9 0B       >234           LDA   #11        
4680: 85 0F       >235           STA   STRLEN     
4682: 20 66 2F    >236           JSR   MOVNM0     move name
4685: 20 F2 23    >237           JSR   IFOPEN     open into a unused channel
4688: B0 17 =46A1 >238           BCS   :ED_HLP5   
                  >239  
468A: 20 A6 3C    >240           JSR   DO_SED     make spacebar work
468D: 20 1F 31    >241  :ED_HLP3 JSR   RDBYTE     get data
4690: B0 09 =469B >242           BCS   :ED_HLP4   end of data
                  >243  
4692: 20 7B 17    >244           JSR   COUT       show data
4695: 24 34       >245           BIT   INTOUT     did they interupt?
4697: 10 F4 =468D >246           BPL   :ED_HLP3   nope
                  >247  
4699: E6 34       >248           INC   INTOUT     re-enable output
469B: EE 00 B6    >249  :ED_HLP4 INC   INTBUF     
469E: 4C D8 30    >250           JMP   CLOSE      close file
                  >251  
46A1: A2 06       >252  :ED_HLP5 LDX   #nofile    system error
46A3: 4C CA 19    >253           JMP   PRMSG      
                  >254  
46A6: 62 3A 68 6C >255  HLPFILE  ASC   'b:hlp.edit' 
                  >256  
46B0: A2 04       >257  ED_ABT   LDX   #abort?    
46B2: 20 B4 19    >258           JSR   PREDMSG    
46B5: 20 DB 4C    >259           JSR   GETCMD     
46B8: C9 59       >260           CMP   #'Y'       
46BA: D0 1C =46D8 >261           BNE   ED_RTS     
                  >262  
46BC: 20 77 45    >263           JSR   ED_CLR     clear editor
46BF: A2 05       >264           LDX   #aborted   
46C1: 20 B4 19    >265  ED_CON1  JSR   PREDMSG    
46C4: 4C C4 49    >266           JMP   ED_EX      return
                  >267  
46C7: A2 05       >268  ED_CONT  LDX   #aborted   thats 4k message
46C9: 38          >269           SEC              
46CA: A5 1A       >270           LDA   EDPTR+1    enough space?
46CC: E9 AD       >271           SBC   #>EBUFEND  
46CE: F0 F1 =46C1 >272           BEQ   ED_CON1    yep
                  >273  
46D0: 20 1F 4F    >274           JSR   CONT       continue...
46D3: 68          >275           PLA              
46D4: 68          >276           PLA              
46D5: 4C DC 45    >277           JMP   ED_LN      get more stuff
                  >278  
46D8: 60          >279  ED_RTS   RTS              
                  >280  
46D9: A2 07       >281  ED_DEL   LDX   #delete?   
46DB: 20 B4 19    >282           JSR   PREDMSG    
46DE: 20 C4 13    >283           JSR   INPLN      
46E1: 20 02 4F    >284           JSR   CHKLIST    do list?
46E4: B0 F3 =46D9 >285           BCS   ED_DEL     yes we did
                  >286  
46E6: 20 5B 4D    >287  DOT_DEL  JSR   XYARG      get arg's
46E9: F0 ED =46D8 >288           BEQ   ED_RTS     
46EB: B0 21 =470E >289           BCS   ED_ERR     
                  >290  
46ED: A6 50       >291           LDX   X_ARG      get line number
46EF: A5 51       >292           LDA   X_ARG+1    
46F1: 20 F2 4C    >293           JSR   FINDLN     find the line
46F4: 20 20 4D    >294  :ED_DEL2 JSR   FNDLEN     get the length
46F7: A8          >295           TAY              
46F8: C8          >296           INY   kill       CR
46F9: A6 00       >297           LDX   TEMP       
46FB: A5 01       >298           LDA   TEMP+1     
46FD: 20 5A 4E    >299           JSR   DEL_TXT    delete the line
                  >300  
4700: A5 54       >301           LDA   EDLINE     decrease line count
4702: D0 02 =4706 >302           BNE   :ED_DEL3   
4704: C6 55       >303           DEC   EDLINE+1   
                  >304  
4706: C6 54       >305  :ED_DEL3 DEC   EDLINE     
4708: 20 1B 4E    >306           JSR   INCXARG    
470B: 90 E7 =46F4 >307           BCC   :ED_DEL2   loop until done
470D: 60          >308  CR_RET2  RTS              
                  >309  
470E: 4C B7 47    >310  ED_ERR   JMP   CR_ERR     link to error routine
                  >311  
4711: 2C 47 4C    >312  DOT_E1   BIT   EXE_DOT    
4714: 10 F7 =470D >313           BPL   CR_RET2    
                  >314  
4716: 68          >315           PLA   handle     the '.e' option
4717: 68          >316           PLA              
4718: A0 00       >317           LDY   #0         
471A: 8C 47 4C    >318           STY   EXE_DOT    no dot command
                  >319  
471D: CE 50 4C    >320           DEC   DOT_E      
4720: 4C FB 4A    >321           JMP   EDLNCR2    
                  >322  
4723: A2 08       >323  ED_ED    LDX   #edit?     
4725: 20 B4 19    >324           JSR   PREDMSG    
4728: 20 C4 13    >325           JSR   INPLN      
472B: 20 02 4F    >326           JSR   CHKLIST    do a list?
472E: B0 F3 =4723 >327           BCS   ED_ED      we did
                  >328  
4730: 20 3E 4D    >329  DOT_ED   JSR   XARG       get line number
4733: F0 DC =4711 >330           BEQ   DOT_E1     just a return (was BEQ CR_RTS2)
4735: B0 D7 =470E >331           BCS   ED_ERR     opps, a problem
                  >332  
4737: 20 EF 4E    >333           JSR   PRCRLF     
473A: A6 50       >334           LDX   X_ARG      get line number
473C: A5 51       >335           LDA   X_ARG+1    
473E: 20 F2 4C    >336           JSR   FINDLN     get address
4741: 20 20 4D    >337           JSR   FNDLEN     get length
4744: 85 02       >338           STA   TEMP2      
4746: 48          >339           PHA   save       orig length
4747: AA          >340           TAX              
4748: F0 0B =4755 >341           BEQ   :ED_ED3    
                  >342  
474A: A0 00       >343           LDY   #0         
474C: B1 00       >344  :ED_ED2  LDA   (TEMP),Y   
474E: 99 00 02    >345           STA   LNBUF,Y    move data to lnbuf
4751: C8          >346           INY              
4752: CA          >347           DEX              
4753: D0 F7 =474C >348           BNE   :ED_ED2    
                  >349  
4755: A5 00       >350  :ED_ED3  LDA   TEMP       save address
4757: 48          >351           PHA              
4758: A5 01       >352           LDA   TEMP+1     
475A: 48          >353           PHA              
                  >354  
475B: A9 00       >355           LDA   #<LNBUF    point at lnbuf
475D: 85 00       >356           STA   TEMP       
475F: A9 02       >357           LDA   #>LNBUF    
4761: 85 01       >358           STA   TEMP+1     
4763: 20 F3 4E    >359           JSR   SHOWLN     show line number
4766: 20 D0 4B    >360           JSR   LSTLINE    print line
4769: 2C 4C 4C    >361           BIT   NONBS      check bs mode
476C: 50 06 =4774 >362           BVC   :ED_ED8    print line again
                  >363  
476E: 20 C5 4B    >364           JSR   EDLN7      back up
4771: 4C 7E 47    >365           JMP   :ED_ED7    do edit
                  >366  
4774: 20 EF 4E    >367  :ED_ED8  JSR   PRCRLF     add a return
4777: 20 F3 4E    >368           JSR   SHOWLN     show the line number
477A: A0 00       >369           LDY   #0         
477C: 84 02       >370           STY   TEMP2      kill line, reset line
                  >371  
477E: EE 49 4C    >372  :ED_ED7  INC   WWRAP      toggle word wrap off
4781: 20 EB 49    >373           JSR   GETEDL2    edit line
4784: CE 49 4C    >374           DEC   WWRAP      put word wrap to old state
                  >375  
4787: 68          >376           PLA              
4788: 85 14       >377           STA   TEMP3+1    save old line address
478A: 68          >378           PLA              
478B: 85 13       >379           STA   TEMP3      
                  >380  
478D: 68          >381           PLA              
478E: B0 26 =47B6 >382           BCS   CR_RET     if they typed 'done'
                  >383  
4790: 38          >384  :ED_ED7A SEC              
4791: E5 02       >385           SBC   TEMP2      find out length
4793: F0 10 =47A5 >386           BEQ   :ED_ED5    hmm, same length!
4795: 90 07 =479E >387           BCC   :ED_ED4    
                  >388  
4797: A8          >389           TAY              
4798: 20 5E 4E    >390           JSR   DEL_TX0    make room
479B: 4C A5 47    >391           JMP   :ED_ED5    
                  >392  
479E: 49 FF       >393  :ED_ED4  EOR   #-1        make positive
47A0: A8          >394           TAY              
47A1: C8          >395           INY              
47A2: 20 83 4E    >396           JSR   INS_TX0    insert
                  >397  
47A5: A0 00       >398  :ED_ED5  LDY   #0         
47A7: A6 02       >399           LDX   TEMP2      get length
47A9: E8          >400           INX              
47AA: B9 00 02    >401  :ED_ED6  LDA   LNBUF,Y    
47AD: 91 13       >402           STA   (TEMP3),Y  copy line back
47AF: C8          >403           INY              
47B0: CA          >404           DEX              
47B1: D0 F7 =47AA >405           BNE   :ED_ED6    
47B3: 4C EA 4E    >406           JMP   PRCRIF     add extra lf (maybe)
                  >407  
47B6: 60          >408  CR_RET   RTS              
                  >409  
47B7: A2 09       >410  CR_ERR   LDX   #badln     
47B9: 20 B4 19    >411           JSR   PREDMSG    
47BC: 4C EA 4E    >412           JMP   PRCRIF     add extra lf (maybe)
                  >413  
47BF: A2 0A       >414  ED_INS   LDX   #insert?   
47C1: 20 B4 19    >415           JSR   PREDMSG    
47C4: 20 C4 13    >416           JSR   INPLN      
47C7: 20 02 4F    >417           JSR   CHKLIST    do a list?
47CA: B0 F3 =47BF >418           BCS   ED_INS     
                  >419  
47CC: 20 3E 4D    >420  DOT_INS  JSR   XARG       
47CF: F0 E5 =47B6 >421           BEQ   CR_RET     
47D1: B0 E4 =47B7 >422           BCS   CR_ERR     
47D3: A2 0C       >423           LDX   #insert    
47D5: 20 B4 19    >424           JSR   PREDMSG    
                  >425  
47D8: A2 00       >426  :ED_INS0 LDX   #<LNBUF    point to line
47DA: A9 02       >427           LDA   #>LNBUF    
47DC: 20 C9 49    >428           JSR   GETEDLN    get a line of stuff
47DF: B0 3F =4820 >429           BCS   :ED_INS2   
                  >430  
47E1: A4 02       >431           LDY   TEMP2      save length
47E3: C8          >432           INY   add        1 for CR
47E4: 84 07       >433           STY   SAVE_Y     
47E6: A6 50       >434           LDX   X_ARG      
47E8: A5 51       >435           LDA   X_ARG+1    
47EA: 20 F2 4C    >436           JSR   FINDLN     locate line
47ED: A4 07       >437           LDY   SAVE_Y     
47EF: 20 7F 4E    >438           JSR   INS_TXT    insert text
                  >439  
47F2: A0 00       >440           LDY   #0         
47F4: B9 00 02    >441  :ED_INS1 LDA   LNBUF,Y    
47F7: 91 13       >442           STA   (TEMP3),Y  copy in new line
47F9: C8          >443           INY              
47FA: C6 07       >444           DEC   SAVE_Y     
47FC: D0 F6 =47F4 >445           BNE   :ED_INS1   
                  >446  
47FE: A2 00       >447           LDX   #0         
4800: EC 4B 4C    >448           CPX   WWEXTRA    
4803: F0 0D =4812 >449           BEQ   :ED_IN1B   word-wrap?, nope
                  >450  
4805: B9 00 02    >451  :ED_IN1A LDA   LNBUF,Y    get next bit of data
4808: C8          >452           INY              
4809: 9D 00 02    >453           STA   LNBUF,X    move back
480C: E8          >454           INX              
480D: EC 4B 4C    >455           CPX   WWEXTRA    
4810: D0 F3 =4805 >456           BNE   :ED_IN1A   done?, nope
                  >457  
4812: E6 50       >458  :ED_IN1B INC   X_ARG      
4814: D0 02 =4818 >459           BNE   :ED_IN1C   inc line to insert at
4816: E6 51       >460           INC   X_ARG+1    
                  >461  
4818: E6 54       >462  :ED_IN1C INC   EDLINE     
481A: D0 BC =47D8 >463           BNE   :ED_INS0   inc line count
481C: E6 55       >464           INC   EDLINE+1   
481E: D0 B8 =47D8 >465           BNE   :ED_INS0   
                  >466  
4820: 2C 47 4C    >467  :ED_INS2 BIT   EXE_DOT    is it .i command?
4823: 10 91 =47B6 >468           BPL   CR_RET     nope, return
4825: 4C 1F 4F    >469           JMP   CONT       continue
                  >470  
4828: 4C B7 47    >471  CR_ERR0  JMP   CR_ERR     goto error routine
                  >472  
482B: A2 0B       >473  ED_LST   LDX   #list?     
482D: 20 B4 19    >474           JSR   PREDMSG    
4830: 20 C4 13    >475           JSR   INPLN      
                  >476  
4833: A0 00       >477  DOT_LST  LDY   #0         
4835: 8C 48 4C    >478           STY   SHWLN      reset line # bit
4838: B1 1D       >479           LDA   (ARGPTR),Y 
483A: 20 6E 17    >480           JSR   CONV       
483D: C9 59       >481           CMP   #'Y'       
483F: D0 0B =484C >482           BNE   ED_LST1    show numbers?, nope
                  >483  
4841: A9 FF       >484           LDA   #-1        
4843: 8D 48 4C    >485           STA   SHWLN      show line numbers
4846: E6 1D       >486           INC   ARGPTR     
4848: D0 02 =484C >487           BNE   ED_LST1    point to next char
484A: E6 1E       >488           INC   ARGPTR+1   
                  >489  
484C: 20 5B 4D    >490  ED_LST1  JSR   XYARG      
484F: B0 D7 =4828 >491           BCS   CR_ERR0    
                  >492  
4851: 20 EF 4E    >493           JSR   PRCRLF     
4854: A6 50       >494  ED_SHLN  LDX   X_ARG      get line number
4856: A5 51       >495           LDA   X_ARG+1    
4858: 20 F2 4C    >496           JSR   FINDLN     locate it
                  >497  
485B: 2C 48 4C    >498  :ED_LST2 BIT   SHWLN      show line numbers?
485E: 10 03 =4863 >499           BPL   :ED_LST3   nope
                  >500  
4860: 20 F3 4E    >501           JSR   SHOWLN     add the line number
4863: 20 20 4D    >502  :ED_LST3 JSR   FNDLEN     get the length
4866: 85 02       >503           STA   TEMP2      
4868: 20 D0 4B    >504           JSR   LSTLINE    list the line
                  >505  
486B: 38          >506           SEC   advance    pointer to next line
486C: A5 02       >507           LDA   TEMP2      
486E: 65 00       >508           ADC   TEMP       
4870: 85 00       >509           STA   TEMP       temp = temp + temp2 + 1
4872: A9 00       >510           LDA   #0         
4874: 65 01       >511           ADC   TEMP+1     
4876: 85 01       >512           STA   TEMP+1     
                  >513  
4878: 20 EF 4E    >514           JSR   PRCRLF     add cr
487B: 20 1B 4E    >515           JSR   INCXARG    
487E: 90 DB =485B >516           BCC   :ED_LST2   
4880: 60          >517           RTS              
                  >518  
4881: A2 0D       >519  ED_NEW   LDX   #new?      
4883: 20 B4 19    >520           JSR   PREDMSG    
4886: 20 DB 4C    >521           JSR   GETCMD     
4889: C9 59       >522           CMP   #'Y'       
488B: D0 10 =489D >523           BNE   :ED_NEW2   
                  >524  
488D: 20 77 45    >525           JSR   ED_CLR     clear editor
4890: A2 0E       >526           LDX   #enter     
4892: 20 B4 19    >527           JSR   PREDMSG    enter message now...
4895: A9 00       >528           LDA   #0         
4897: 8D 47 4C    >529           STA   EXE_DOT    allow dot commands
489A: 4C DC 45    >530           JMP   ED_LN      get message
                  >531  
489D: 60          >532  :ED_NEW2 RTS              
                  >533  
489E: A9 0D       >534  ED_USED  LDA   #cr        
48A0: 20 7B 17    >535           JSR   COUT       
48A3: 20 87 45    >536           JSR   ED_SPC     
48A6: AD 26 DF    >537           LDA   DATA+2     
48A9: AE 25 DF    >538           LDX   DATA+1     
48AC: 20 3E 1A    >539           JSR   DECOUT     
48AF: A2 13       >540           LDX   #bytsused  
48B1: 4C B4 19    >541           JMP   PREDMSG    
                  >542  
48B4: AD 4E 4C    >543  DOT_PMT  LDA   PROMPT     
48B7: 49 FF       >544           EOR   #-1        toggle prompt status
48B9: 8D 4E 4C    >545           STA   PROMPT     
48BC: F0 05 =48C3 >546           BEQ   ED_NEW2    dont show prompts
                  >547  
48BE: A9 3E       >548           LDA   #'>'       show first prompt
48C0: 20 7B 17    >549           JSR   COUT       
                  >550  
48C3: 60          >551  ED_NEW2  RTS              
                  >552                            ; common read/write
                  >553  
48C4: 20 C4 13    >554  ED_RW    JSR   INPLN      input data
48C7: A9 00       >555           LDA   #<LNBUF    point to string
48C9: 85 0D       >556           STA   STRLOC     
48CB: A9 02       >557           LDA   #>LNBUF    
48CD: 85 0E       >558           STA   STRLOC+1   
48CF: A9 13       >559           LDA   #19        
48D1: 85 0F       >560           STA   STRLEN     save max length
48D3: 4C 66 2F    >561           JMP   MOVNM0     move the name
                  >562  
48D6: A2 0F       >563  ED_RD    LDX   #readfn?   
48D8: 20 B4 19    >564           JSR   PREDMSG    
48DB: 20 C4 48    >565           JSR   ED_RW      
48DE: 20 F2 23    >566           JSR   IFOPEN     try and open
48E1: B0 18 =48FB >567           BCS   ED_RD4     error, no go
                  >568  
48E3: A9 00       >569           LDA   #<EDBUF    point to date
48E5: 85 19       >570           STA   EDPTR      
48E7: A9 9E       >571           LDA   #>EDBUF    
48E9: 85 1A       >572           STA   EDPTR+1    
                  >573  
48EB: 20 1F 31    >574  :ED_RD2  JSR   RDBYTE     read in file
48EE: 08          >575           PHP              
48EF: 20 4E 4F    >576           JSR   EDOUT      
48F2: 28          >577           PLP              
48F3: 90 F6 =48EB >578           BCC   :ED_RD2    
                  >579  
48F5: 20 D8 30    >580  ED_RD3   JSR   CLOSE      finish up
48F8: 4C B2 4E    >581           JMP   FINDEND    fix pointers
                  >582  
48FB: A2 06       >583  ED_RD4   LDX   #nofile    print no buffers
48FD: 4C CA 19    >584           JMP   PRMSG      
                  >585  
4900: A2 10       >586  ED_WRT   LDX   #writefn?  
4902: 20 B4 19    >587           JSR   PREDMSG    
4905: 20 C4 48    >588           JSR   ED_RW      setup for work
4908: 20 10 32    >589           JSR   DELFILE    delete existing file
490B: A0 04       >590           LDY   #txt       
490D: A9 00       >591           LDA   #0         
490F: A2 00       >592           LDX   #0         
4911: 20 88 30    >593           JSR   CREATE     create a text file
4914: 20 F2 23    >594           JSR   IFOPEN     
4917: B0 DC =48F5 >595           BCS   ED_RD3     error
                  >596  
4919: A9 00       >597           LDA   #0         
491B: 85 1F       >598           STA   DEVCLR     reset device
                  >599  
491D: 20 39 4F    >600  :ED_WR2  JSR   EDINP      get data
4920: C9 00       >601           CMP   #0         
4922: F0 D1 =48F5 >602           BEQ   ED_RD3     thats the end
                  >603  
4924: 20 6A 31    >604           JSR   WRBYTE     write out byte
4927: 90 F4 =491D >605           BCC   :ED_WR2    all is well
4929: A2 07       >606           LDX   #badwrite  
492B: 20 CA 19    >607           JSR   PRMSG      show message
492E: 4C F5 48    >608           JMP   ED_RD3     finish up
                  >609  
4931: A9 00       >610  DOT_OK   LDA   #0         add in eof char
4933: A8          >611           TAY              
4934: 91 00       >612           STA   (TEMP),Y   
                  >613  
4936: 24 1C       >614  ED_OK    BIT   EXEC       exec user online?
4938: 10 03 =493D >615           BPL   :FILT0     
493A: 4C C4 49    >616           JMP   ED_EX      yes, exit
                  >617  
493D: AD 00 50    >618  :FILT0   LDA   FILTER     is filter in place?
4940: F0 46 =4988 >619           BEQ   :XCHECK    nope, check for .X's
                  >620  
4942: A9 00       >621           LDA   #<EDBUF    point to editor buffer
4944: 85 00       >622           STA   TEMP       
4946: A9 9E       >623           LDA   #>EDBUF    
4948: 85 01       >624           STA   TEMP+1     
                  >625  
494A: 4C 7A 49    >626           JMP   :FILT7     start routine
                  >627  
494D: BD 00 50    >628  :FILT1   LDA   FILTER,X   go to next entry
4950: E8          >629           INX              
4951: 0A          >630           ASL   A          at last char?
4952: 90 F9 =494D >631           BCC   :FILT1     nope
                  >632  
4954: A0 00       >633           LDY   #0         start at first byte
4956: BD 00 50    >634  :FILT3   LDA   FILTER,X   get filter char
4959: F0 19 =4974 >635           BEQ   :FILT5     end of table
                  >636  
495B: 85 02       >637           STA   TEMP2      save it
495D: B1 00       >638           LDA   (TEMP),Y   get byte in question
495F: 20 6E 17    >639           JSR   CONV       convert to upper
4962: 45 02       >640           EOR   TEMP2      check against filter - save hi bit
4964: 0A          >641           ASL   A          put high into carry
4965: D0 E6 =494D >642           BNE   :FILT1     no match, keep checking
                  >643  
4967: E8          >644           INX   inc        pointers
4968: C8          >645           INY              
4969: 90 EB =4956 >646           BCC   :FILT3     keep checking for rest of string
                  >647  
496B: A9 2A       >648           LDA   #'*'       change text into *'s
496D: 88          >649  :FILT4   DEY              
496E: 91 00       >650           STA   (TEMP),Y   
4970: C0 00       >651           CPY   #0         
4972: D0 F9 =496D >652           BNE   :FILT4     
                  >653  
4974: E6 00       >654  :FILT5   INC   TEMP       
4976: D0 02 =497A >655           BNE   :FILT7     go to next byte
4978: E6 01       >656           INC   TEMP+1     
                  >657  
497A: A2 00       >658  :FILT7   LDX   #0         start both index's off at 0
497C: A0 00       >659           LDY   #0         
497E: B1 00       >660           LDA   (TEMP),Y   get byte
4980: F0 06 =4988 >661           BEQ   :XCHECK    end
                  >662  
4982: C9 41       >663           CMP   #'A'       
4984: B0 D0 =4956 >664           BGE   :FILT3     is it good data, check it
4986: 90 EC =4974 >665           BLT   :FILT5     goto next byte
                  >666  
4988: A9 00       >667  :XCHECK  LDA   #<EDBUF    look for external file cmd
498A: 85 00       >668           STA   TEMP       
498C: A9 9E       >669           LDA   #>EDBUF    start at beginning
498E: 85 01       >670           STA   TEMP+1     
                  >671  
4990: A0 00       >672           LDY   #0         Y is 0 on first pass only
4992: B1 00       >673  :XCK1    LDA   (TEMP),Y   all other passes, Y is 1
4994: F0 2E =49C4 >674           BEQ   ED_EX      no data
4996: C9 2E       >675           CMP   #'.'       command?
4998: D0 17 =49B1 >676           BNE   :XCK2      no, skip to next line
                  >677  
499A: C8          >678           INY   check      the command
499B: B1 00       >679           LDA   (TEMP),Y   
499D: 20 6E 17    >680           JSR   CONV       
49A0: C9 58       >681           CMP   #'X'       is it an X?
49A2: D0 0D =49B1 >682           BNE   :XCK2      no, skip to next line
                  >683  
49A4: C8          >684           INY   check      if space follows
49A5: B1 00       >685           LDA   (TEMP),Y   
49A7: C9 20       >686           CMP   #' '       is there a space?
49A9: D0 06 =49B1 >687           BNE   :XCK2      no, skip to next line
                  >688  
49AB: A9 2A       >689           LDA   #'*'       replace '.X ' (kills external)
49AD: 91 00       >690           STA   (TEMP),Y   with '.X*' (see DO_SHOW)
49AF: 85 0A       >691           STA   ERVAL      
                  >692  
49B1: A0 00       >693  :XCK2    LDY   #0         set Y back to 0
49B3: E6 00       >694  :XCK3    INC   TEMP       search for end of line
49B5: D0 02 =49B9 >695           BNE   :XCK4      or end of text
49B7: E6 01       >696           INC   TEMP+1     
49B9: B1 00       >697  :XCK4    LDA   (TEMP),Y   
49BB: F0 07 =49C4 >698           BEQ   ED_EX      no more text
49BD: C9 0D       >699           CMP   #cr        
49BF: D0 F2 =49B3 >700           BNE   :XCK3      end of line?, look some more
49C1: C8          >701           INY   Y          is now 1
49C2: D0 CE =4992 >702           BNE   :XCK1      branch always
                  >703  
49C4: AE 46 4C    >704  ED_EX    LDX   EDSTACK    
49C7: 9A          >705           TXS              
49C8: 60          >706           RTS              
                  >707  
                  >708  *-------------------------------
                  >709  * ----- editor routines -----
                  >710  *-------------------------------
                  >711  
49C9: A0 00       >712  GETEDLN  LDY   #0         line length
49CB: 84 02       >713           STY   TEMP2      
49CD: 86 00       >714           STX   TEMP       point to data
49CF: 85 01       >715           STA   TEMP+1     
                  >716  
49D1: 2C 4E 4C    >717           BIT   PROMPT     are prompts on?
49D4: 10 05 =49DB >718           BPL   :GETEDL1   nope
                  >719  
49D6: A9 3E       >720           LDA   #'>'       display prompt
49D8: 20 7B 17    >721           JSR   COUT       
                  >722  
49DB: AD 4B 4C    >723  :GETEDL1 LDA   WWEXTRA    word-wrap?
49DE: F0 0B =49EB >724           BEQ   GETEDL2    nope
                  >725  
49E0: 8C 4B 4C    >726           STY   WWEXTRA    reset word-wrap
49E3: 85 02       >727           STA   TEMP2      save length
49E5: 20 D0 4B    >728           JSR   LSTLINE    list the partial line and fall through
49E8: 4C ED 49    >729           JMP   GETED1     don't want to reset to 0!
                  >730  
49EB: A0 00       >731  GETEDL2  LDY   #0         
                  >732  
49ED: 20 37 15    >733  GETED1   JSR   RDKEY      get input
49F0: 20 F6 49    >734           JSR   GETED2     
49F3: 4C ED 49    >735           JMP   GETED1     
                  >736  
49F6: 20 55 4C    >737  GETED2   JSR   MATCH      
49F9: FF          >738           DB    -1         
49FA: C4 49       >739           DA    ED_EX      carrier lost
49FC: 0D          >740           DB    cr         
49FD: 73 4A       >741           DA    EDLNCR     handle [return]
49FF: 09          >742           DB    tab        
4A00: 20 4B       >743           DA    EDLN0      handle [tab]
4A02: 08          >744           DB    bs         
4A03: 26 4C       >745           DA    EDLN1      handle [backspace, ctrl-h]
4A05: 7F          >746           DB    del        
4A06: 35 4C       >747           DA    EDLN12     handle [delete]
4A08: 18          >748           DB    can        
4A09: 5A 4B       >749           DA    EDLN4      handle [cancel, ctrl-x]
4A0B: 03          >750           DB    ctr        
4A0C: FF 4B       >751           DA    EDLN11     handle [center, ctrl-c]
4A0E: 00          >752           DB    0          finish this set
                  >753  
4A0F: 2C 4C 4C    >754           BIT   NONBS      good bs mode
4A12: 50 1C =4A30 >755           BVC   :GETED2H   no
                  >756  
4A14: 20 55 4C    >757           JSR   MATCH      
4A17: 15          >758           DB    fs         
4A18: 30 4B       >759           DA    EDLN2      handle [forward space, ctrl-u]
4A1A: 14          >760           DB    hak        
4A1B: 3D 4B       >761           DA    EDLN3      handle [truncate, ctrl-t]
4A1D: 04          >762           DB    dc         
4A1E: 6A 4B       >763           DA    EDLN5      handle [delete char, ctrl-d]
4A20: 06          >764           DB    ic         
4A21: 94 4B       >765           DA    EDLN6      handle [insert char, ctrl-f]
4A23: 02          >766           DB    bol        
4A24: C5 4B       >767           DA    EDLN7      handle [begin line, ctrl-b]
4A26: 05          >768           DB    eol        
4A27: D2 4B       >769           DA    EDLN8      handle [end of line, ctrl-e]
4A29: 11          >770           DB    lwd        
4A2A: DF 4B       >771           DA    EDLN9      handle [last word, ctrl-l]
4A2C: 17          >772           DB    nwd        
4A2D: EE 4B       >773           DA    EDLN10     handle [next word, ctrl-n]
4A2F: 00          >774           DB    0          
                  >775  
4A30: C9 20       >776  :GETED2H CMP   #' '       
4A32: 90 11 =4A45 >777           BLT   :GETED2C   control?, yes
                  >778  
4A34: CC 4D 4C    >779           CPY   VIDLEN     
4A37: F0 14 =4A4D >780           BEQ   :GETED3    
4A39: 91 00       >781           STA   (TEMP),Y   store it.
4A3B: 20 7B 17    >782           JSR   COUT       output it
4A3E: C4 02       >783           CPY   TEMP2      
4A40: D0 02 =4A44 >784           BNE   :GETED2B   at end of line?, nope
                  >785  
4A42: E6 02       >786           INC   TEMP2      inc end of line pointer
4A44: C8          >787  :GETED2B INY   inc        data pointer
4A45: 60          >788  :GETED2C RTS              
                  >789  
4A46: 8A          >790  :GETED2Z TXA   restore    Y
4A47: A8          >791           TAY              
4A48: A9 07       >792  :GETED2X LDA   #bel       ring bell
4A4A: 4C 7B 17    >793           JMP   COUT       
                  >794  
4A4D: 2C 49 4C    >795  :GETED3  BIT   WWRAP      is word wrap on?
4A50: 10 F6 =4A48 >796           BPL   :GETED2X   nope
                  >797  
4A52: C9 20       >798           CMP   #' '       
4A54: F0 1D =4A73 >799           BEQ   EDLNCR     was it an even break?, yes
                  >800  
4A56: 91 00       >801           STA   (TEMP),Y   save char
4A58: 98          >802           TYA   save       Y
4A59: AA          >803           TAX              
4A5A: 88          >804  :GETED3A DEY              
4A5B: F0 E9 =4A46 >805           BEQ   :GETED2Z   count down, no spaces in line!
                  >806  
4A5D: B1 00       >807           LDA   (TEMP),Y   check for space
4A5F: C9 20       >808           CMP   #' '       
4A61: D0 F7 =4A5A >809           BNE   :GETED3A   nope, keep looking
                  >810  
4A63: 84 02       >811           STY   TEMP2      save new length
4A65: A0 00       >812           LDY   #0         
                  >813  
4A67: C8          >814  :GETED3B INY   count      number of extra's
4A68: CA          >815           DEX   first      char doesn't count
4A69: 20 D6 4E    >816           JSR   PRBS       backup
4A6C: E4 02       >817           CPX   TEMP2      
4A6E: D0 F7 =4A67 >818           BNE   :GETED3B   we done?, keep looping
                  >819  
4A70: 8C 4B 4C    >820           STY   WWEXTRA    remember extra
                  >821  
4A73: A4 02       >822  EDLNCR   LDY   TEMP2      get line length
4A75: A9 0D       >823           LDA   #cr        
4A77: 91 00       >824           STA   (TEMP),Y   save return at end
4A79: 20 7B 17    >825           JSR   COUT       show it
                  >826  
4A7C: A0 00       >827           LDY   #0         
4A7E: B1 00       >828           LDA   (TEMP),Y   
4A80: 8D 4F 4C    >829           STA   DOT_SAVE   
4A83: C9 2E       >830           CMP   #'.'       
4A85: F0 04 =4A8B >831           BEQ   EDLNCR0    dot command?, yes
4A87: C9 2F       >832           CMP   #'/'       
4A89: D0 70 =4AFB >833           BNE   EDLNCR2    slash command?, no
                  >834  
4A8B: A9 00       >835  EDLNCR0  LDA   #0         
4A8D: 8D 50 4C    >836           STA   DOT_E      
                  >837  
4A90: 2C 47 4C    >838           BIT   EXE_DOT    dot commands allowed?
4A93: 30 66 =4AFB >839           BMI   EDLNCR2    nope
4A95: CE 47 4C    >840           DEC   EXE_DOT    exec a dot command
                  >841  
4A98: 18          >842           CLC              
4A99: A5 00       >843           LDA   TEMP       
4A9B: 85 19       >844           STA   EDPTR      set up arg pointer
4A9D: 69 02       >845           ADC   #2         
4A9F: 85 1D       >846           STA   ARGPTR     
                  >847  
4AA1: A5 01       >848           LDA   TEMP+1     
4AA3: 85 1A       >849           STA   EDPTR+1    
4AA5: 69 00       >850           ADC   #0         
4AA7: 85 1E       >851           STA   ARGPTR+1   
                  >852  
4AA9: A0 00       >853           LDY   #0         
4AAB: 98          >854           TYA   end        text
4AAC: 91 00       >855           STA   (TEMP),Y   
4AAE: C8          >856           INY              
4AAF: B1 00       >857           LDA   (TEMP),Y   get command
4AB1: 20 C7 4A    >858           JSR   EDLNCR1    
                  >859  
4AB4: 20 B2 4E    >860           JSR   FINDEND    get new end pointer
                  >861  
4AB7: A0 00       >862           LDY   #0         
4AB9: 8C 47 4C    >863           STY   EXE_DOT    get a new line
4ABC: 84 02       >864           STY   TEMP2      no in dot command
                  >865  
4ABE: A5 19       >866           LDA   EDPTR      point back to data
4AC0: 85 00       >867           STA   TEMP       
4AC2: A5 1A       >868           LDA   EDPTR+1    
4AC4: 85 01       >869           STA   TEMP+1     
4AC6: 60          >870           RTS              
                  >871  
4AC7: 20 6E 17    >872  EDLNCR1  JSR   CONV       make upper
4ACA: 20 55 4C    >873           JSR   MATCH      
4ACD: 41          >874           ASC   'A'        
4ACE: B0 46       >875           DA    ED_ABT     
4AD0: 44          >876           ASC   'D'        
4AD1: E6 46       >877           DA    DOT_DEL    
4AD3: 45          >878           ASC   'E'        
4AD4: 30 47       >879           DA    DOT_ED     
4AD6: 48          >880           ASC   'H'        
4AD7: D6 4C       >881           DA    DOT_HLP    
4AD9: 49          >882           ASC   'I'        
4ADA: CC 47       >883           DA    DOT_INS    
4ADC: 4C          >884           ASC   'L'        
4ADD: 33 48       >885           DA    DOT_LST    
4ADF: 4E          >886           ASC   'N'        
4AE0: 81 48       >887           DA    ED_NEW     
4AE2: 4F          >888           ASC   'O'        
4AE3: 31 49       >889           DA    DOT_OK     
4AE5: 53          >890           ASC   'S'        
4AE6: 31 49       >891           DA    DOT_OK     
4AE8: 50          >892           ASC   'P'        
4AE9: B4 48       >893           DA    DOT_PMT    
4AEB: 5A          >894           ASC   'Z'        
4AEC: 9E 48       >895           DA    ED_USED    
4AEE: 00          >896           DB    0          
4AEF: 68          >897           PLA              
4AF0: 68          >898           PLA              
                  >899  
4AF1: A0 00       >900           LDY   #0         
4AF3: 8C 47 4C    >901           STY   EXE_DOT    no dot command
4AF6: AD 4F 4C    >902           LDA   DOT_SAVE   
4AF9: 91 00       >903           STA   (TEMP),Y   restore the dot
                  >904  
4AFB: 68          >905  EDLNCR2  PLA   return     from getline
4AFC: 68          >906           PLA              
                  >907  
4AFD: 2C 50 4C    >908           BIT   DOT_E      is it a '.e'?
4B00: 30 19 =4B1B >909           BMI   :EDLNCR5   yes, so handle it
                  >910  
4B02: A5 02       >911           LDA   TEMP2      was length correct?
4B04: C9 04       >912           CMP   #4         
4B06: D0 07 =4B0F >913           BNE   :EDLNCR4   nope
                  >914  
4B08: A2 00       >915           LDX   #0         was it 'DONE'?
4B0A: 20 2C 4D    >916           JSR   CMPSTR     
4B0D: B0 0C =4B1B >917           BCS   :EDLNCR5   yes
                  >918  
4B0F: 38          >919  :EDLNCR4 SEC   return     with end address of line
4B10: A5 02       >920           LDA   TEMP2      address = start + length + 1 (for CR)
4B12: 65 00       >921           ADC   TEMP       
4B14: AA          >922           TAX              
4B15: A9 00       >923           LDA   #0         
4B17: 65 01       >924           ADC   TEMP+1     
4B19: 18          >925           CLC   return     status: clc = all well
4B1A: 60          >926           RTS              
                  >927  
4B1B: A6 00       >928  :EDLNCR5 LDX   TEMP       get old address
4B1D: A5 01       >929           LDA   TEMP+1     
4B1F: 60          >930           RTS   return     status: sec = exit edit mode
                  >931  
                  >932  *-------------------------------
                  >933  * handle a tab
                  >934  *-------------------------------
                  >935  
4B20: CC 4D 4C    >936  EDLN0    CPY   VIDLEN     
4B23: F0 0A =4B2F >937           BEQ   :EDLN0A    at end of line?, no more
                  >938  
4B25: A9 20       >939           LDA   #' '       do a space
4B27: 20 F6 49    >940           JSR   GETED2     
4B2A: 98          >941           TYA              
4B2B: 29 07       >942           AND   #7         are we at a 1/8 inc?
4B2D: D0 F1 =4B20 >943           BNE   EDLN0      nope
4B2F: 60          >944  :EDLN0A  RTS              
                  >945  
                  >946  *-------------------------------
                  >947  * go forward 1 space
                  >948  *-------------------------------
                  >949  
4B30: 38          >950  EDLN2    SEC   cant       do fs
4B31: C4 02       >951           CPY   TEMP2      
4B33: F0 07 =4B3C >952           BEQ   :EDLN2A    at end of line?, yes
                  >953  
4B35: B1 00       >954           LDA   (TEMP),Y   get char
4B37: 20 7B 17    >955           JSR   COUT       output it
4B3A: C8          >956           INY   move       pointer
4B3B: 18          >957           CLC   can        do fs
4B3C: 60          >958  :EDLN2A  RTS              
                  >959  
                  >960  *-------------------------------
                  >961  * truncate contents of line
                  >962  *-------------------------------
                  >963  
4B3D: A2 00       >964  EDLN3    LDX   #0         kill 0 chars
4B3F: C4 02       >965  :EDLN3A  CPY   TEMP2      
4B41: F0 09 =4B4C >966           BEQ   :EDLN3B    are we done, yes
                  >967  
4B43: A9 20       >968           LDA   #' '       
4B45: 20 7B 17    >969           JSR   COUT       
4B48: E8          >970           INX   count      it
4B49: C8          >971           INY              
4B4A: D0 F3 =4B3F >972           BNE   :EDLN3A    move forward
                  >973  
4B4C: E0 00       >974  :EDLN3B  CPX   #0         
4B4E: F0 09 =4B59 >975           BEQ   :EDLN3C    done?, yes
                  >976  
4B50: 20 E5 4E    >977           JSR   BSOUT      do bs
4B53: C6 02       >978           DEC   TEMP2      move back line count
4B55: 88          >979           DEY   move       back data pointer
4B56: CA          >980           DEX              
4B57: D0 F3 =4B4C >981           BNE   :EDLN3B    count down, loop if not done
                  >982  
4B59: 60          >983  :EDLN3C  RTS              
                  >984  
                  >985  *-------------------------------
                  >986  * delete entire line
                  >987  *-------------------------------
                  >988  
4B5A: 20 3D 4B    >989  EDLN4    JSR   EDLN3      hack line
4B5D: A5 02       >990           LDA   TEMP2      no data to kill
4B5F: F0 08 =4B69 >991           BEQ   :EDLN4B    
                  >992  
4B61: 20 D6 4E    >993  :EDLN4A  JSR   PRBS       destructive bs
4B64: 88          >994           DEY   back       up data pointer
4B65: C6 02       >995           DEC   TEMP2      
4B67: D0 F8 =4B61 >996           BNE   :EDLN4A    decrease line length
                  >997  
4B69: 60          >998  :EDLN4B  RTS              
                  >999  
                  >1000 *-------------------------------
                  >1001 * delete 1 character
                  >1002 *-------------------------------
                  >1003 
4B6A: C4 02       >1004 EDLN5    CPY   TEMP2      
4B6C: F0 25 =4B93 >1005          BEQ   :EDLN5D    at end of line?
                  >1006 
4B6E: 84 07       >1007          STY   SAVE_Y     
4B70: C6 02       >1008          DEC   TEMP2      decrease line count
4B72: A2 01       >1009          LDX   #1         
4B74: C4 02       >1010 :EDLN5A  CPY   TEMP2      
4B76: F0 0E =4B86 >1011          BEQ   :EDLN5B    done
                  >1012 
4B78: C8          >1013          INY              
4B79: B1 00       >1014          LDA   (TEMP),Y   move each char back
4B7B: 88          >1015          DEY              
4B7C: 91 00       >1016          STA   (TEMP),Y   
4B7E: C8          >1017          INY              
4B7F: E8          >1018          INX              
4B80: 20 7B 17    >1019          JSR   COUT       show char
4B83: 4C 74 4B    >1020          JMP   :EDLN5A    
                  >1021 
4B86: A9 20       >1022 :EDLN5B  LDA   #' '       delete last char
4B88: 20 7B 17    >1023          JSR   COUT       
4B8B: A4 07       >1024          LDY   SAVE_Y     
                  >1025 
4B8D: 20 E5 4E    >1026 :EDLN5C  JSR   BSOUT      
4B90: CA          >1027          DEX              
4B91: D0 FA =4B8D >1028          BNE   :EDLN5C    
                  >1029 
4B93: 60          >1030 :EDLN5D  RTS              
                  >1031 
                  >1032 *-------------------------------
                  >1033 * insert 1 character
                  >1034 *-------------------------------
                  >1035 
4B94: C4 02       >1036 EDLN6    CPY   TEMP2      
4B96: F0 2C =4BC4 >1037          BEQ   :EDLN6C    at the end of the line?
                  >1038 
4B98: A5 02       >1039          LDA   TEMP2      are we at max line width?
4B9A: CD 4D 4C    >1040          CMP   VIDLEN     
4B9D: F0 25 =4BC4 >1041          BEQ   :EDLN6C    yes
                  >1042 
4B9F: 84 07       >1043          STY   SAVE_Y     
4BA1: A2 00       >1044          LDX   #0         start counter
4BA3: A9 20       >1045          LDA   #' '       show a space first
4BA5: 20 7B 17    >1046 :EDLN6A  JSR   COUT       
4BA8: E8          >1047          INX   inc        count
                  >1048 
4BA9: 48          >1049          PHA              
4BAA: B1 00       >1050          LDA   (TEMP),Y   
4BAC: 85 03       >1051          STA   TEMP2+1    get new char and save
4BAE: 68          >1052          PLA              
4BAF: 91 00       >1053          STA   (TEMP),Y   save old char
4BB1: A5 03       >1054          LDA   TEMP2+1    
                  >1055 
4BB3: C8          >1056          INY              
4BB4: C4 02       >1057          CPY   TEMP2      
4BB6: 90 ED =4BA5 >1058          BLT   :EDLN6A    
4BB8: F0 EB =4BA5 >1059          BEQ   :EDLN6A    done?
                  >1060 
4BBA: E6 02       >1061          INC   TEMP2      add 1 to line count
4BBC: A4 07       >1062          LDY   SAVE_Y     
4BBE: 20 E5 4E    >1063 :EDLN6B  JSR   BSOUT      backup
4BC1: CA          >1064          DEX              
4BC2: D0 FA =4BBE >1065          BNE   :EDLN6B    
                  >1066 
4BC4: 60          >1067 :EDLN6C  RTS   done       
                  >1068 
                  >1069 *-------------------------------
                  >1070 * goto beginning of line
                  >1071 *-------------------------------
                  >1072 
4BC5: C0 00       >1073 EDLN7    CPY   #0         
4BC7: F0 06 =4BCF >1074          BEQ   EDLN7B     at beginning?, yes
                  >1075 
4BC9: 20 E5 4E    >1076 :EDLN7A  JSR   BSOUT      back up
4BCC: 88          >1077          DEY              
4BCD: D0 FA =4BC9 >1078          BNE   :EDLN7A    
                  >1079 
4BCF: 60          >1080 EDLN7B   RTS              
                  >1081 
                  >1082 *-------------------------------
                  >1083 * list a line
                  >1084 *-------------------------------
                  >1085 
4BD0: A0 00       >1086 LSTLINE  LDY   #0         use show to eol
                  >1087 
                  >1088 *-------------------------------
                  >1089 * goto end of line
                  >1090 *-------------------------------
                  >1091 
4BD2: C4 02       >1092 EDLN8    CPY   TEMP2      
4BD4: F0 F9 =4BCF >1093          BEQ   EDLN7B     at end of line?, yes
                  >1094 
4BD6: B1 00       >1095          LDA   (TEMP),Y   
4BD8: 20 7B 17    >1096          JSR   COUT       print char (move forward)
4BDB: C8          >1097          INY   keep       checking
4BDC: 4C D2 4B    >1098          JMP   EDLN8      
                  >1099 
                  >1100 *-------------------------------
                  >1101 * back up to last word
                  >1102 *-------------------------------
                  >1103 
4BDF: C0 00       >1104 EDLN9    CPY   #0         
4BE1: F0 0A =4BED >1105          BEQ   :EDLN9A    at beginning?, yes
                  >1106 
4BE3: 20 E5 4E    >1107          JSR   BSOUT      back up
4BE6: 88          >1108          DEY              
4BE7: B1 00       >1109          LDA   (TEMP),Y   back 1 word?
4BE9: C9 20       >1110          CMP   #' '       
4BEB: D0 F2 =4BDF >1111          BNE   EDLN9      no
                  >1112 
4BED: 60          >1113 :EDLN9A  RTS              
                  >1114 
                  >1115 *-------------------------------
                  >1116 * goto next word
                  >1117 *-------------------------------
                  >1118 
4BEE: C4 02       >1119 EDLN10   CPY   TEMP2      
4BF0: F0 0C =4BFE >1120          BEQ   :EDLN10A   at end?, yes
                  >1121 
4BF2: B1 00       >1122          LDA   (TEMP),Y   move forward
4BF4: 20 7B 17    >1123          JSR   COUT       
4BF7: C8          >1124          INY              
4BF8: B1 00       >1125          LDA   (TEMP),Y   
4BFA: C9 20       >1126          CMP   #' '       
4BFC: D0 F0 =4BEE >1127          BNE   EDLN10     at end of word?, no
                  >1128 
4BFE: 60          >1129 :EDLN10A RTS              
                  >1130 
                  >1131 *-------------------------------
                  >1132 * center line of text
                  >1133 *-------------------------------
                  >1134 
4BFF: A5 02       >1135 EDLN11   LDA   TEMP2      any data?, no
4C01: F0 22 =4C25 >1136          BEQ   EDLN11B    
                  >1137 
4C03: 20 C5 4B    >1138          JSR   EDLN7      move cursor to first char
4C06: 20 8D 4C    >1139          JSR   CENTER     center text
4C09: B0 1A =4C25 >1140          BCS   EDLN11B    problem
                  >1141 
4C0B: A5 02       >1142          LDA   TEMP2      
4C0D: 48          >1143          PHA              
4C0E: A5 03       >1144          LDA   TEMP2+1    
4C10: 85 02       >1145          STA   TEMP2      save new length
4C12: 20 D0 4B    >1146          JSR   LSTLINE    show the line
4C15: 68          >1147          PLA              
4C16: 85 02       >1148          STA   TEMP2      
                  >1149 
4C18: A5 03       >1150          LDA   TEMP2+1    
4C1A: C5 02       >1151          CMP   TEMP2      
4C1C: B0 03 =4C21 >1152          BGE   EDLN11A    is new line smaller?, no
4C1E: 20 3D 4B    >1153          JSR   EDLN3      hack rest of line
                  >1154 
4C21: A5 03       >1155 EDLN11A  LDA   TEMP2+1    
4C23: 85 02       >1156          STA   TEMP2      
4C25: 60          >1157 EDLN11B  RTS              
                  >1158 
                  >1159 *-------------------------------
                  >1160 * back up 1 char
                  >1161 *-------------------------------
                  >1162 
4C26: C0 00       >1163 EDLN1    CPY   #0         
4C28: F0 FB =4C25 >1164          BEQ   EDLN11B    at beginning of line?, yes
                  >1165 
4C2A: 2C 4C 4C    >1166          BIT   NONBS      destruct bs mode
4C2D: 30 11 =4C40 >1167          BMI   EDLN13     
4C2F: 50 0F =4C40 >1168          BVC   EDLN13     unknown mode
                  >1169 
4C31: 88          >1170          DEY              
4C32: 4C E5 4E    >1171          JMP   BSOUT      do bs
                  >1172 
                  >1173 *-------------------------------
                  >1174 * handle delete character
                  >1175 *-------------------------------
                  >1176 
4C35: C0 00       >1177 EDLN12   CPY   #0         
4C37: F0 EC =4C25 >1178          BEQ   EDLN11B    at beginning?
                  >1179 
4C39: 88          >1180          DEY   backup     
4C3A: 20 E5 4E    >1181          JSR   BSOUT      
4C3D: 4C 6A 4B    >1182          JMP   EDLN5      delete char
                  >1183 
4C40: 88          >1184 EDLN13   DEY              
4C41: C6 02       >1185          DEC   TEMP2      
4C43: 4C D6 4E    >1186          JMP   PRBS       
                  >1187 
4C46: 00          >1188 EDSTACK  DB    0          
4C47: 00          >1189 EXE_DOT  DB    0          
4C48: 00          >1190 SHWLN    DB    0          
4C49: 00          >1191 WWRAP    DB    0          
4C4A: FF          >1192 WWFLAG   DB    -1         
4C4B: 00          >1193 WWEXTRA  DB    0          
4C4C: 00          >1194 NONBS    DB    0          
4C4D: 27          >1195 VIDLEN   DB    39         
4C4E: 00          >1196 PROMPT   DB    0          
4C4F: 00          >1197 DOT_SAVE DB    0          
4C50: 00          >1198 DOT_E    DB    0          
4C51: 44 4F 4E C5 >1199 QTEXT    DCI   'DONE'     
                  >1200 
                  >1201 *-------------------------------
                  >1202 * easy dispatch routine [must save Y]
                  >1203 *-------------------------------
                  >1204 
4C55: 85 06       >1205 MATCH    STA   SAVE_X     save match char
4C57: 84 07       >1206          STY   SAVE_Y     
4C59: 68          >1207          PLA              
4C5A: 85 13       >1208          STA   TEMP3      get address of data-1
4C5C: 68          >1209          PLA              
4C5D: 85 14       >1210          STA   TEMP3+1    
                  >1211 
4C5F: A0 01       >1212          LDY   #1         
4C61: B1 13       >1213 :MATCH2  LDA   (TEMP3),Y  
4C63: F0 13 =4C78 >1214          BEQ   :MATCH4    
                  >1215 
4C65: C5 06       >1216          CMP   SAVE_X     
4C67: F0 05 =4C6E >1217          BEQ   :MATCH3    
                  >1218 
4C69: C8          >1219          INY   y          = y + 3
4C6A: C8          >1220          INY              
4C6B: C8          >1221          INY              
4C6C: D0 F3 =4C61 >1222          BNE   :MATCH2    loop
                  >1223 
4C6E: C8          >1224 :MATCH3  INY              
4C6F: B1 13       >1225          LDA   (TEMP3),Y  
4C71: AA          >1226          TAX              
4C72: C8          >1227          INY              
4C73: B1 13       >1228          LDA   (TEMP3),Y  
4C75: 4C 82 4C    >1229          JMP   :MATCH5    do it
                  >1230 
4C78: C8          >1231 :MATCH4  INY   increase   count
4C79: 18          >1232          CLC              
4C7A: 98          >1233          TYA              
4C7B: 65 13       >1234          ADC   TEMP3      add in offset
4C7D: AA          >1235          TAX              
4C7E: A9 00       >1236          LDA   #0         
4C80: 65 14       >1237          ADC   TEMP3+1    
                  >1238 
4C82: 86 13       >1239 :MATCH5  STX   TEMP3      save address
4C84: 85 14       >1240          STA   TEMP3+1    
4C86: A4 07       >1241          LDY   SAVE_Y     
4C88: A5 06       >1242          LDA   SAVE_X     
4C8A: 6C 13 00    >1243          JMP   (TEMP3)    return to caller
                  >1244 
                  >1245 *-------------------------------
                  >1246 * center a line of text
                  >1247 *-------------------------------
                  >1248 
4C8D: A2 00       >1249 CENTER   LDX   #0         start index's
                  >1250 
4C8F: A0 FF       >1251          LDY   #-1        
4C91: C8          >1252 :CENTER2 INY              
4C92: C4 02       >1253          CPY   TEMP2      
4C94: F0 1E =4CB4 >1254          BEQ   :CENTER8   
                  >1255 
4C96: B1 00       >1256          LDA   (TEMP),Y   gobble leading spaces
4C98: C9 20       >1257          CMP   #' '       
4C9A: F0 F5 =4C91 >1258          BEQ   :CENTER2   
                  >1259 
4C9C: B1 00       >1260 :CENTER3 LDA   (TEMP),Y   
4C9E: 9D 80 02    >1261          STA   LNBUF+128,X get data and save
4CA1: E8          >1262          INX              
4CA2: C8          >1263          INY              
4CA3: C9 20       >1264          CMP   #' '       
4CA5: F0 02 =4CA9 >1265          BEQ   :CENTER4   
                  >1266 
4CA7: 86 03       >1267          STX   TEMP2+1    update length
4CA9: C4 02       >1268 :CENTER4 CPY   TEMP2      
4CAB: D0 EF =4C9C >1269          BNE   :CENTER3   done?, no
                  >1270 
4CAD: 38          >1271          SEC              
4CAE: AD 4D 4C    >1272          LDA   VIDLEN     find number of spaces to add
4CB1: E5 03       >1273          SBC   TEMP2+1    
4CB3: 4A          >1274          LSR   A          
4CB4: 08          >1275 :CENTER8 PHP              
4CB5: A0 00       >1276          LDY   #0         go to beginning of line
4CB7: 28          >1277          PLP              
4CB8: 38          >1278          SEC              
4CB9: F0 1A =4CD5 >1279          BEQ   CENTER7    don't add any
                  >1280 
4CBB: AA          >1281          TAX              
4CBC: 18          >1282          CLC              
4CBD: 65 03       >1283          ADC   TEMP2+1    get new total length
4CBF: 85 03       >1284          STA   TEMP2+1    
                  >1285 
4CC1: A9 20       >1286          LDA   #' '       
4CC3: 91 00       >1287 :CENTER5 STA   (TEMP),Y   add in leading spaces
4CC5: C8          >1288          INY              
4CC6: CA          >1289          DEX              
4CC7: D0 FA =4CC3 >1290          BNE   :CENTER5   
                  >1291 
4CC9: BD 80 02    >1292 :CENTER6 LDA   LNBUF+128,X 
4CCC: 91 00       >1293          STA   (TEMP),Y   copy data back
4CCE: E8          >1294          INX              
4CCF: C8          >1295          INY              
4CD0: C4 03       >1296          CPY   TEMP2+1    
4CD2: D0 F5 =4CC9 >1297          BNE   :CENTER6   done?, no
                  >1298 
4CD4: 18          >1299          CLC              
4CD5: 60          >1300 CENTER7  RTS              
                  >1301 
                  >1302 *-------------------------------
                  >1303 * print small help file
                  >1304 *-------------------------------
                  >1305 
4CD6: A2 12       >1306 DOT_HLP  LDX   #legaldot  
4CD8: 4C B4 19    >1307          JMP   PREDMSG    
                  >1308 
                  >1309 *-------------------------------
                  >1310 * input a command
                  >1311 *-------------------------------
                  >1312 
4CDB: A9 80       >1313 GETCMD   LDA   #%10000000 
4CDD: 8D 99 16    >1314          STA   INPMODE    set upper, no blank line
4CE0: 20 C4 13    >1315          JSR   INPLN      get input
4CE3: A9 A0       >1316          LDA   #%10100000 
4CE5: 8D 99 16    >1317          STA   INPMODE    upper, blanks ok
4CE8: AD 00 02    >1318          LDA   LNBUF      
4CEB: 24 61       >1319          BIT   LOGOFF     any problems?
4CED: 10 E6 =4CD5 >1320          BPL   CENTER7    no
4CEF: 4C C4 49    >1321          JMP   ED_EX      quit editor
                  >1322 
                  >1323 *-------------------------------
                  >1324 * find a line number
                  >1325 *-------------------------------
                  >1326 
4CF2: 86 02       >1327 FINDLN   STX   TEMP2      save line number
4CF4: 85 03       >1328          STA   TEMP2+1    
4CF6: A0 00       >1329          LDY   #<EDBUF    point to editor
4CF8: 84 00       >1330          STY   TEMP       
4CFA: A9 9E       >1331          LDA   #>EDBUF    
4CFC: 85 01       >1332          STA   TEMP+1     
                  >1333 
4CFE: A5 02       >1334 :FINDLN2 LDA   TEMP2      count down lines
4D00: D0 02 =4D04 >1335          BNE   :FNDLN2A   temp2 = temp2 - 1
4D02: C6 03       >1336          DEC   TEMP2+1    count down high
4D04: C6 02       >1337 :FNDLN2A DEC   TEMP2      
4D06: A5 02       >1338          LDA   TEMP2      
4D08: 05 03       >1339          ORA   TEMP2+1    are we done?
4D0A: D0 07 =4D13 >1340          BNE   :FINDLN3   no
                  >1341 
4D0C: 84 00       >1342          STY   TEMP       
4D0E: A6 00       >1343          LDX   TEMP       get address of line
4D10: A5 01       >1344          LDA   TEMP+1     
4D12: 60          >1345          RTS              
                  >1346 
4D13: B1 00       >1347 :FINDLN3 LDA   (TEMP),Y   get byte
4D15: C8          >1348          INY              
4D16: D0 02 =4D1A >1349          BNE   :FINDLN4   
4D18: E6 01       >1350          INC   TEMP+1     
                  >1351 
4D1A: C9 0D       >1352 :FINDLN4 CMP   #cr        
4D1C: D0 F5 =4D13 >1353          BNE   :FINDLN3   
4D1E: F0 DE =4CFE >1354          BEQ   :FINDLN2   done?..
                  >1355 
                  >1356 *-------------------------------
                  >1357 * get length of line
                  >1358 *-------------------------------
                  >1359 
4D20: A0 FF       >1360 FNDLEN   LDY   #-1        
4D22: C8          >1361 :FNDLEN2 INY              
4D23: B1 00       >1362          LDA   (TEMP),Y   count length of line
4D25: C9 0D       >1363          CMP   #cr        
4D27: D0 F9 =4D22 >1364          BNE   :FNDLEN2   
                  >1365 
4D29: 98          >1366          TYA              
4D2A: 18          >1367 CMPSTR3  CLC   no         match
4D2B: 60          >1368          RTS              
                  >1369 
                  >1370 *-------------------------------
                  >1371 * compare data with string
                  >1372 *-------------------------------
                  >1373 
4D2C: A0 00       >1374 CMPSTR   LDY   #0         start at byte 0
4D2E: B1 00       >1375 CMPSTR2  LDA   (TEMP),Y   
4D30: C8          >1376          INY              
4D31: 20 6E 17    >1377          JSR   CONV       make into upper
4D34: 5D 51 4C    >1378          EOR   QTEXT,X    check against exit text
4D37: E8          >1379          INX              
4D38: 0A          >1380          ASL   A          
4D39: D0 EF =4D2A >1381          BNE   CMPSTR3    no match
4D3B: 90 F1 =4D2E >1382          BCC   CMPSTR2    keep checking
4D3D: 60          >1383          RTS              
                  >1384 
                  >1385 *-------------------------------
                  >1386 * handle single argument
                  >1387 *-------------------------------
                  >1388 
4D3E: A5 54       >1389 XARG     LDA   EDLINE     is there data?
4D40: 05 55       >1390          ORA   EDLINE+1   
4D42: F0 15 =4D59 >1391          BEQ   XYCLR      no
                  >1392 
4D44: 20 F9 4D    >1393          JSR   CHKLAST    
                  >1394 
4D47: A5 1D       >1395          LDA   ARGPTR     set up pointers
4D49: 85 13       >1396          STA   TEMP3      
4D4B: A5 1E       >1397          LDA   ARGPTR+1   
4D4D: 85 14       >1398          STA   TEMP3+1    
                  >1399 
4D4F: 20 2A 1B    >1400          JSR   ZNUMIN     get number
4D52: 86 50       >1401          STX   X_ARG      save
4D54: 85 51       >1402          STA   X_ARG+1    
                  >1403 
4D56: 4C DF 4D    >1404          JMP   CHKRNG     get legality
                  >1405 
4D59: 38          >1406 XYCLR    SEC              
4D5A: 60          >1407          RTS              
                  >1408 
                  >1409 *-------------------------------
                  >1410 * handle arguments
                  >1411 *-------------------------------
                  >1412 
4D5B: A9 01       >1413 XYARG    LDA   #<1        first pointer to 1
4D5D: 85 50       >1414          STA   X_ARG      
4D5F: A9 00       >1415          LDA   #>1        
4D61: 85 51       >1416          STA   X_ARG+1    
                  >1417 
4D63: 20 F9 4D    >1418          JSR   CHKLAST    
                  >1419 
4D66: A5 54       >1420          LDA   EDLINE     second pointer to last line #
4D68: 85 52       >1421          STA   Y_ARG      
4D6A: A5 55       >1422          LDA   EDLINE+1   
4D6C: 85 53       >1423          STA   Y_ARG+1    
                  >1424 
4D6E: 05 52       >1425          ORA   Y_ARG      check for no data
4D70: F0 E7 =4D59 >1426          BEQ   XYCLR      problem
                  >1427 
4D72: A5 1D       >1428          LDA   ARGPTR     point to data
4D74: 85 13       >1429          STA   TEMP3      
4D76: A5 1E       >1430          LDA   ARGPTR+1   
4D78: 85 14       >1431          STA   TEMP3+1    
                  >1432 
4D7A: A0 00       >1433          LDY   #0         
4D7C: B1 13       >1434          LDA   (TEMP3),Y  blank line?
4D7E: C9 0D       >1435          CMP   #cr        
4D80: F0 59 =4DDB >1436          BEQ   :XYARG7    yes
4D82: C9 2C       >1437          CMP   #','       
4D84: F0 20 =4DA6 >1438          BEQ   :XYARG2    check separator
4D86: C9 2D       >1439          CMP   #'-'       
4D88: F0 1C =4DA6 >1440          BEQ   :XYARG2    
                  >1441 
4D8A: 20 2A 1B    >1442          JSR   ZNUMIN     get first number
4D8D: 86 50       >1443          STX   X_ARG      
4D8F: 86 52       >1444          STX   Y_ARG      
4D91: 85 51       >1445          STA   X_ARG+1    
4D93: 85 53       >1446          STA   Y_ARG+1    
4D95: 20 DF 4D    >1447          JSR   CHKRNG     
4D98: B0 3E =4DD8 >1448          BCS   :XYARG6    out of range
                  >1449 
4D9A: A0 00       >1450          LDY   #0         
4D9C: B1 13       >1451          LDA   (TEMP3),Y  any more?
4D9E: C9 2C       >1452          CMP   #','       
4DA0: F0 04 =4DA6 >1453          BEQ   :XYARG2    yes
4DA2: C9 2D       >1454          CMP   #'-'       
4DA4: D0 31 =4DD7 >1455          BNE   :XYARG5    no
                  >1456 
4DA6: E6 13       >1457 :XYARG2  INC   TEMP3      
4DA8: D0 02 =4DAC >1458          BNE   :XYARG4    inc pointer
4DAA: E6 14       >1459          INC   TEMP3+1    
                  >1460 
4DAC: A5 54       >1461 :XYARG4  LDA   EDLINE     save ending editor line
4DAE: 85 52       >1462          STA   Y_ARG      
4DB0: A5 55       >1463          LDA   EDLINE+1   
4DB2: 85 53       >1464          STA   Y_ARG+1    
                  >1465 
4DB4: A0 00       >1466          LDY   #0         is it xx- format?
4DB6: B1 13       >1467          LDA   (TEMP3),Y  
4DB8: C9 0D       >1468          CMP   #cr        
4DBA: F0 1B =4DD7 >1469          BEQ   :XYARG5    yes
                  >1470 
4DBC: 20 2A 1B    >1471          JSR   ZNUMIN     
4DBF: 86 52       >1472          STX   Y_ARG      save second number
4DC1: 85 53       >1473          STA   Y_ARG+1    
4DC3: 20 DF 4D    >1474          JSR   CHKRNG     
4DC6: B0 10 =4DD8 >1475          BCS   :XYARG6    
                  >1476 
4DC8: A5 51       >1477          LDA   X_ARG+1    check high byte
4DCA: C5 53       >1478          CMP   Y_ARG+1    
4DCC: 90 09 =4DD7 >1479          BLT   :XYARG5    all is ok
                  >1480 
4DCE: A5 52       >1481          LDA   Y_ARG      check low byte
4DD0: C5 50       >1482          CMP   X_ARG      
4DD2: B0 03 =4DD7 >1483          BGE   :XYARG5    if =>, ok
                  >1484 
4DD4: 38          >1485          SEC              
4DD5: B0 01 =4DD8 >1486          BCS   :XYARG6    x_arg > y_arg
                  >1487 
4DD7: 18          >1488 :XYARG5  CLC              
4DD8: A9 01       >1489 :XYARG6  LDA   #1         not just a return
4DDA: 60          >1490          RTS              
                  >1491 
4DDB: 18          >1492 :XYARG7  CLC              
4DDC: A9 00       >1493          LDA   #0         just a return
4DDE: 60          >1494          RTS              
                  >1495 
                  >1496 *-------------------------------
                  >1497 * make sure line number is in range
                  >1498 *-------------------------------
                  >1499 
4DDF: 86 06       >1500 CHKRNG   STX   SAVE_X     save data
4DE1: 85 07       >1501          STA   SAVE_Y     
4DE3: 05 06       >1502          ORA   SAVE_X     is there a number?
4DE5: F0 10 =4DF7 >1503          BEQ   CHKRNG2    no, it's 0
                  >1504 
4DE7: A5 55       >1505          LDA   EDLINE+1   check high
4DE9: C5 07       >1506          CMP   SAVE_Y     
4DEB: 90 0A =4DF7 >1507          BLT   CHKRNG2    its out of range
                  >1508 
4DED: A6 54       >1509          LDX   EDLINE     check low
4DEF: E4 06       >1510          CPX   SAVE_X     
4DF1: 90 04 =4DF7 >1511          BLT   CHKRNG2    its out of range
                  >1512 
4DF3: 18          >1513          CLC   all's well 
4DF4: A9 01       >1514          LDA   #1         clear return flag
4DF6: 60          >1515          RTS              
                  >1516 
4DF7: 38          >1517 CHKRNG2  SEC   out        of range
4DF8: 60          >1518          RTS              
                  >1519 
                  >1520 *-------------------------------
                  >1521 * check for 'last line' reference
                  >1522 *-------------------------------
                  >1523 
4DF9: 2C 47 4C    >1524 CHKLAST  BIT   EXE_DOT    execing dot command?
4DFC: 10 F9 =4DF7 >1525          BPL   CHKRNG2    no
4DFE: A0 00       >1526          LDY   #0         
4E00: B1 1D       >1527          LDA   (ARGPTR),Y get byte
4E02: 20 6E 17    >1528          JSR   CONV       
4E05: C9 4C       >1529          CMP   #'L'       
4E07: D0 EE =4DF7 >1530          BNE   CHKRNG2    no match, return
                  >1531 
4E09: 68          >1532          PLA              
4E0A: 68          >1533          PLA              
4E0B: A6 54       >1534          LDX   EDLINE     
4E0D: 86 50       >1535          STX   X_ARG      
4E0F: 86 52       >1536          STX   Y_ARG      
4E11: A5 55       >1537          LDA   EDLINE+1   
4E13: 85 51       >1538          STA   X_ARG+1    
4E15: 85 53       >1539          STA   Y_ARG+1    
4E17: 4C DF 4D    >1540          JMP   CHKRNG     make sure line is legal
                  >1541 
4E1A: 60          >1542          RTS              
                  >1543 
                  >1544 *-------------------------------
                  >1545 * move up xarg pointer and see if were done
                  >1546 *-------------------------------
                  >1547 
4E1B: A5 50       >1548 INCXARG  LDA   X_ARG      done?
4E1D: C5 52       >1549          CMP   Y_ARG      
4E1F: D0 08 =4E29 >1550          BNE   :INCXA2    no
                  >1551 
4E21: A5 51       >1552          LDA   X_ARG+1    done?
4E23: C5 53       >1553          CMP   Y_ARG+1    
4E25: D0 02 =4E29 >1554          BNE   :INCXA2    no
                  >1555 
4E27: 38          >1556          SEC   we         are done
4E28: 60          >1557          RTS              
                  >1558 
4E29: E6 50       >1559 :INCXA2  INC   X_ARG      
4E2B: D0 02 =4E2F >1560          BNE   :INCXA3    move counter
4E2D: E6 51       >1561          INC   X_ARG+1    
                  >1562 
4E2F: 18          >1563 :INCXA3  CLC   still      ok
4E30: 60          >1564 INCXA4   RTS              
                  >1565 
                  >1566 *-------------------------------
                  >1567 * show last 3 lines
                  >1568 *-------------------------------
                  >1569 
4E31: A5 54       >1570 SHWLAST  LDA   EDLINE     point to last line
4E33: 85 52       >1571          STA   Y_ARG      
4E35: A5 55       >1572          LDA   EDLINE+1   
4E37: 85 53       >1573          STA   Y_ARG+1    
4E39: 05 52       >1574          ORA   Y_ARG      
4E3B: F0 F3 =4E30 >1575          BEQ   INCXA4     no data
                  >1576 
4E3D: 38          >1577          SEC              
4E3E: A5 52       >1578          LDA   Y_ARG      
4E40: E9 02       >1579          SBC   #2         
4E42: 85 50       >1580          STA   X_ARG      get X line number
4E44: AA          >1581          TAX              
4E45: A5 53       >1582          LDA   Y_ARG+1    
4E47: E9 00       >1583          SBC   #0         
4E49: 85 51       >1584          STA   X_ARG+1    
4E4B: 20 DF 4D    >1585          JSR   CHKRNG     is it ok?
4E4E: 90 07 =4E57 >1586          BCC   :SHWLST2   yes
                  >1587 
4E50: A2 01       >1588          LDX   #1         
4E52: 86 50       >1589          STX   X_ARG      start at line 1
4E54: CA          >1590          DEX              
4E55: 86 51       >1591          STX   X_ARG+1    
                  >1592 
4E57: 4C 54 48    >1593 :SHWLST2 JMP   ED_SHLN    show last 3 lines...
                  >1594 
                  >1595 *-------------------------------
                  >1596 * delete Y bytes of text
                  >1597 *-------------------------------
                  >1598 
4E5A: 86 13       >1599 DEL_TXT  STX   TEMP3      save pointer
4E5C: 85 14       >1600          STA   TEMP3+1    
4E5E: 84 07       >1601 DEL_TX0  STY   SAVE_Y     save # of chars to kill
                  >1602 
4E60: A5 13       >1603          LDA   TEMP3      save old pointer
4E62: 48          >1604          PHA              
4E63: A5 14       >1605          LDA   TEMP3+1    
4E65: 48          >1606          PHA              
                  >1607 
4E66: A4 07       >1608 :DEL_TX2 LDY   SAVE_Y     
4E68: B1 13       >1609          LDA   (TEMP3),Y  get char
4E6A: A0 00       >1610          LDY   #0         
4E6C: 91 13       >1611          STA   (TEMP3),Y  save char
                  >1612 
4E6E: E6 13       >1613          INC   TEMP3      
4E70: D0 02 =4E74 >1614          BNE   :DEL_TX3   
4E72: E6 14       >1615          INC   TEMP3+1    
                  >1616 
4E74: C9 00       >1617 :DEL_TX3 CMP   #0         
4E76: D0 EE =4E66 >1618          BNE   :DEL_TX2   loop till end of editor
                  >1619 
4E78: 68          >1620          PLA              
4E79: 85 14       >1621          STA   TEMP3+1    restore old pointer
4E7B: 68          >1622          PLA              
4E7C: 85 13       >1623          STA   TEMP3      
4E7E: 60          >1624 DEL_TX4  RTS              
                  >1625 
                  >1626 *-------------------------------
                  >1627 * insert Y bytes of text
                  >1628 *-------------------------------
                  >1629 
4E7F: 86 13       >1630 INS_TXT  STX   TEMP3      save pointer
4E81: 85 14       >1631          STA   TEMP3+1    
4E83: 84 07       >1632 INS_TX0  STY   SAVE_Y     save # of chars to insert
                  >1633 
4E85: A0 00       >1634          LDY   #0         
4E87: B1 13       >1635          LDA   (TEMP3),Y  flag last char
4E89: 09 80       >1636          ORA   #hibit     
4E8B: 91 13       >1637          STA   (TEMP3),Y  
                  >1638 
4E8D: B1 13       >1639 :INS_TX2 LDA   (TEMP3),Y  at end of data?
4E8F: F0 08 =4E99 >1640          BEQ   :INS_TX3   yes
                  >1641 
4E91: E6 13       >1642          INC   TEMP3      
4E93: D0 F8 =4E8D >1643          BNE   :INS_TX2   move through data
4E95: E6 14       >1644          INC   TEMP3+1    
4E97: D0 F4 =4E8D >1645          BNE   :INS_TX2   
                  >1646 
4E99: A0 00       >1647 :INS_TX3 LDY   #0         
4E9B: B1 13       >1648          LDA   (TEMP3),Y  get byte
4E9D: 48          >1649          PHA              
4E9E: A4 07       >1650          LDY   SAVE_Y     
4EA0: 29 7F       >1651          AND   #clrhi     
4EA2: 91 13       >1652          STA   (TEMP3),Y  move it
4EA4: 68          >1653          PLA              
4EA5: 30 D7 =4E7E >1654          BMI   DEL_TX4    
                  >1655 
4EA7: A5 13       >1656          LDA   TEMP3      
4EA9: D0 02 =4EAD >1657          BNE   :INS_TX4   
4EAB: C6 14       >1658          DEC   TEMP3+1    count back
4EAD: C6 13       >1659 :INS_TX4 DEC   TEMP3      
4EAF: 4C 99 4E    >1660          JMP   :INS_TX3   
                  >1661 
                  >1662 *-------------------------------
                  >1663 * find end of editor
                  >1664 *-------------------------------
                  >1665 
4EB2: A9 9E       >1666 FINDEND  LDA   #>EDBUF    point to start of editor
4EB4: 85 1A       >1667          STA   EDPTR+1    
4EB6: A0 00       >1668          LDY   #<EDBUF    
4EB8: 84 19       >1669          STY   EDPTR      
4EBA: 84 54       >1670          STY   EDLINE     
4EBC: 84 55       >1671          STY   EDLINE+1   zero line counter
                  >1672 
4EBE: B1 19       >1673 :FINDEN2 LDA   (EDPTR),Y  done?
4EC0: F0 11 =4ED3 >1674          BEQ   :FINDEN4   yes
                  >1675 
4EC2: C9 0D       >1676          CMP   #cr        
4EC4: D0 06 =4ECC >1677          BNE   :FINDEN3   end of line?, no
                  >1678 
4EC6: E6 54       >1679          INC   EDLINE     
4EC8: D0 02 =4ECC >1680          BNE   :FINDEN3   inc number of lines
4ECA: E6 55       >1681          INC   EDLINE+1   
                  >1682 
4ECC: C8          >1683 :FINDEN3 INY              
4ECD: D0 EF =4EBE >1684          BNE   :FINDEN2   
4ECF: E6 1A       >1685          INC   EDPTR+1    
4ED1: D0 EB =4EBE >1686          BNE   :FINDEN2   search through
                  >1687 
4ED3: 84 19       >1688 :FINDEN4 STY   EDPTR      
4ED5: 60          >1689          RTS              
                  >1690 
                  >1691 *-------------------------------
                  >1692 * print a backspace
                  >1693 *-------------------------------
                  >1694 
4ED6: A9 08       >1695 PRBS     LDA   #bs        
4ED8: 2C 4C 4C    >1696          BIT   NONBS      is it a destruct bs?
4EDB: 30 0A =4EE7 >1697          BMI   PRNONBS    yes
                  >1698 
4EDD: 20 7B 17    >1699          JSR   COUT       print bs
4EE0: A9 20       >1700          LDA   #' '       
4EE2: 20 7B 17    >1701          JSR   COUT       
4EE5: A9 08       >1702 BSOUT    LDA   #bs        
4EE7: 4C 7B 17    >1703 PRNONBS  JMP   COUT       do non-destruct bs
                  >1704 
4EEA: 2C 47 4C    >1705 PRCRIF   BIT   EXE_DOT    
4EED: 10 2F =4F1E >1706          BPL   CHKLST2    dont do it
                  >1707 
4EEF: A9 0D       >1708 PRCRLF   LDA   #cr        print return
4EF1: D0 F4 =4EE7 >1709          BNE   PRNONBS    
                  >1710 
                  >1711 *-------------------------------
                  >1712 * show the line number
                  >1713 *-------------------------------
                  >1714 
4EF3: A6 50       >1715 SHOWLN   LDX   X_ARG      print line number
4EF5: A5 51       >1716          LDA   X_ARG+1    
4EF7: 20 3E 1A    >1717          JSR   DECOUT     
4EFA: A9 3E       >1718          LDA   #'>'       show prompt
4EFC: 20 7B 17    >1719          JSR   COUT       
4EFF: 4C EF 4E    >1720          JMP   PRCRLF     add a return
                  >1721 
                  >1722 *-------------------------------
                  >1723 * check and see if they want to list
                  >1724 *-------------------------------
                  >1725 
4F02: AD 00 02    >1726 CHKLIST  LDA   LNBUF      get input
4F05: 20 6E 17    >1727          JSR   CONV       make upper
4F08: C9 4C       >1728          CMP   #'L'       
4F0A: 18          >1729          CLC              
4F0B: D0 11 =4F1E >1730          BNE   CHKLST2    they dont want to list
4F0D: A2 0B       >1731          LDX   #list?     
4F0F: 20 B4 19    >1732          JSR   PREDMSG    
4F12: 20 C4 13    >1733          JSR   INPLN      read input
                  >1734 
4F15: A9 FF       >1735          LDA   #-1        
4F17: 8D 48 4C    >1736          STA   SHWLN      show line numbers
                  >1737 
4F1A: 20 4C 48    >1738          JSR   ED_LST1    do list
4F1D: 38          >1739          SEC   show       list done
4F1E: 60          >1740 CHKLST2  RTS              
                  >1741 
                  >1742 *-------------------------------
                  >1743 * continue message
                  >1744 *-------------------------------
                  >1745 
4F1F: A2 06       >1746 CONT     LDX   #continue  
4F21: 20 B4 19    >1747          JSR   PREDMSG    
4F24: A9 00       >1748          LDA   #0         
4F26: 8D 48 4C    >1749          STA   SHWLN      dont show line numbers
4F29: 20 31 4E    >1750          JSR   SHWLAST    show last 3 lines
4F2C: 4C B2 4E    >1751          JMP   FINDEND    reset pointers
                  >1752 
                  >1753 *-------------------------------
                  >1754 * ---- editor i/o routines -----
                  >1755 *-------------------------------
                  >1756 
4F2F: A9 00       >1757 EDIN3    LDA   #<EDBUF    
4F31: 85 19       >1758          STA   EDPTR      reset pointers
4F33: A9 9E       >1759          LDA   #>EDBUF    
4F35: 85 1A       >1760          STA   EDPTR+1    reset pointers
4F37: C6 1F       >1761          DEC   DEVCLR     clear flag
                  >1762 
                  >1763 *-------------------------------
                  >1764 * get a character from the edit buffer
                  >1765 *-------------------------------
                  >1766 
4F39: 24 1F       >1767 EDINP    BIT   DEVCLR     reset?
4F3B: 10 F2 =4F2F >1768          BPL   EDIN3      yes
                  >1769 
4F3D: 84 07       >1770          STY   SAVE_Y     save Y
4F3F: A0 00       >1771          LDY   #0         
4F41: B1 19       >1772          LDA   (EDPTR),Y  
4F43: F0 06 =4F4B >1773          BEQ   :EDIN2     if eof
                  >1774 
4F45: E6 19       >1775          INC   EDPTR      
4F47: D0 02 =4F4B >1776          BNE   :EDIN2     point to next byte
4F49: E6 1A       >1777          INC   EDPTR+1    
4F4B: A4 07       >1778 :EDIN2   LDY   SAVE_Y     restore Y
4F4D: 60          >1779          RTS              
                  >1780 
                  >1781 *-------------------------------
                  >1782 * add a character to editor buffer
                  >1783 *-------------------------------
                  >1784 
4F4E: 84 07       >1785 EDOUT    STY   SAVE_Y     save Y
                  >1786 
4F50: A4 19       >1787          LDY   EDPTR      are we at end?
4F52: C0 FF       >1788          CPY   #<EBUFEND  
4F54: D0 06 =4F5C >1789          BNE   :EDOUT2    no
                  >1790 
4F56: A4 1A       >1791          LDY   EDPTR+1    at end?
4F58: C0 AD       >1792          CPY   #>EBUFEND  
4F5A: F0 11 =4F6D >1793          BEQ   :EDOUT3    yes
                  >1794 
4F5C: A0 00       >1795 :EDOUT2  LDY   #0         
4F5E: 91 19       >1796          STA   (EDPTR),Y  save byte
4F60: C8          >1797          INY              
                  >1798 
4F61: 48          >1799          PHA   save       end marker
4F62: A9 00       >1800          LDA   #0         
4F64: 91 19       >1801          STA   (EDPTR),Y  
4F66: 68          >1802          PLA              
                  >1803 
4F67: E6 19       >1804          INC   EDPTR      
4F69: D0 02 =4F6D >1805          BNE   :EDOUT3    inc pointers to next byte
4F6B: E6 1A       >1806          INC   EDPTR+1    
                  >1807 
4F6D: A4 07       >1808 :EDOUT3  LDY   SAVE_Y     restore and return
4F6F: 60          >1809          RTS              
                  >1810 
4F70: 32 30 30 30 >1811 SERNUM   REV   'GP2140002' 
                  >1812 SEREND                    
                  >1813 
4F79: 0D 0D       >1814 COPNOT   HEX   0D0D       
4F7B: 6E 30 32 2E >1815          REV   'GBBS Pro (C)86-2019 Kevin Smallwood V2.20n' 
                  >1816 COPEND                    
4FA5: 00 00 00 00 >1817          DS    \          
                   43   
                   44            DS    \          fill
                   45   
                   46            PUT   FILTER     
                  >2    ********************************
                  >3    *                              *
                  >4    * ACOS.OBJ - Profanity Filter  *
                  >5    *                              *
                  >6    ********************************
                                  3-MAR-23   9:23:30 AM
                  >8    *-------------------------------
                  >9    
5000: 46 55 43 CB >10   FILTER   DCI   'FUCK'     
5004: 53 48 49 D4 >11            DCI   'SHIT'     
5008: 44 41 4D CE >12            DCI   'DAMN'     
500C: 41 53 53 48 >13            DCI   'ASSHOLE'  
5013: 43 4F 43 CB >14            DCI   'COCK'     
5017: 53 55 43 CB >15            DCI   'SUCK'     
501B: 50 52 49 43 >16            DCI   'PRICK'    
5020: 00          >17            DB    00         
5021: 0D          >18            DB    cr         
5022: 47 42 42 53 >19            ASC   'GBBS Pro V:2.30 (C) 1986-2019 by Kevin M. Smallwood   '0D 
                  >20   * ASC 'GBBS Pro V:2.20 (C) 1986-1989 by L&L Productions, Inc.'0D
                  >21   * ASC 'GBBS Pro V:1.4 (C) 1986-1989 by L & L Productions'0D
                  >22   * ASC 'Lance Taylor-Warren, fixes by A.Wells & L.Roathe'0D00
5059: 00 00 00 00 >23            DS    \          
          =5100    47   CODEND   =     *          
                   48   
                   49            PUT   INIT       
                  >2    ********************************
                  >3    *                              *
                  >4    *     ACOS.OBJ - Init Code     *
                  >5    *                              *
                  >6    ********************************
                                  3-MAR-23   9:23:30 AM
                  >8    *-------------------------------
                  >9    
5100: 20 12 51    >10   START1   JSR   MOVECODE   ;do memory move
5103: 20 00 12    >11            JSR   FATAL      ;init stuff
5106: 20 74 12    >12            JSR   FATAL5     ;move file name (no return)
5109: 4C 82 12    >13            JMP   FATAL6     
                  >14   
510C: 20 12 51    >15   START2   JSR   MOVECODE   ;move memory
510F: 4C 03 12    >16            JMP   FATAL1     ;init w/o doing modem
                  >17   
                  >18   *-------------------------------
                  >19   * do memory move and setup
                  >20   *-------------------------------
                  >21   
5112: AD 83 C0    >22   MOVECODE LDA   SETRAM     ;select main lc bank
5115: AD 83 C0    >23            LDA   SETRAM     
                  >24   
5118: A9 46       >25            LDA   #<ZDATA    ;point to data
511A: 85 00       >26            STA   TEMP       
511C: A9 51       >27            LDA   #>ZDATA    
511E: 85 01       >28            STA   TEMP+1     
                  >29   
5120: A9 00       >30            LDA   #<SYMTXT   ;point to dest
5122: 85 02       >31            STA   TEMP2      
5124: A9 D5       >32            LDA   #>SYMTXT   
5126: 85 03       >33            STA   TEMP2+1    
                  >34   
5128: A0 00       >35            LDY   #0         ;start offset
512A: A2 0B       >36            LDX   #>END_MV+$256 
512C: B1 00       >37   :DO_IN2  LDA   (TEMP),Y   
512E: 91 02       >38            STA   (TEMP2),Y  ;copy byte
5130: C8          >39            INY              
5131: D0 F9 =512C >40            BNE   :DO_IN2    
                  >41   
5133: E6 01       >42            INC   TEMP+1     
5135: E6 03       >43            INC   TEMP2+1    
5137: CA          >44            DEX              
5138: D0 F2 =512C >45            BNE   :DO_IN2    ;count down
                  >46   
513A: A0 50       >47            LDY   #80        
513C: B9 4D 5A    >48   :INIT3   LDA   PG3JMP,Y   
513F: 99 80 03    >49            STA   ENTPOINT,Y ;copy jump table into place
5142: 88          >50            DEY              
5143: 10 F7 =513C >51            BPL   :INIT3     
                  >52   
                  >53   *            LDA   #<IRQ_FIX
                  >54   *            STA   IRQVECT
                  >55   *            LDA   #>IRQ_FIX
                  >56   *            STA   IRQVECT+1
5145: 60          >57            RTS              
                  >58   
                  >59   ZDATA    ORG   RAMCARD    
                  >60   
                  >61   *-------------------------------
                  >62   * ----- actual tokens -----
                  >63   *-------------------------------
                  >64   
D500: FF          >65   SYMTXT   DB    -1         ;reserved
D501: FF          >66            DB    -1         ;reserved
D502: FF          >67            DB    -1         ;reserved
D503: 45 4E C4    >68            DCI   'END'      ;end of module
D506: 47 4F 54 CF >69            DCI   'GOTO'     ;goto statement
D50A: 47 4F 53 55 >70            DCI   'GOSUB'    ;gosub statement
D50F: 50 55 53 C8 >71            DCI   'PUSH'     ;push statement
D513: 50 55 42 4C >72            DCI   'PUBLIC'   ;public directive
                  >73   
D519: BA          >74            DCI   ':'        ;colon
D51A: FF          >75            DB    -1         ;reserved
                  >76   
D51B: 43 4C 45 41 >77            DCI   'CLEAR'    ;use ascii with hi-bit clear
D520: 4C 49 4E CB >78            DCI   'LINK'     ;on text, set on last char
D524: 48 4F 4D C5 >79            DCI   'HOME'     ;home cmd, used wierd ways
D528: 50 52 49 4E >80            DCI   'PRINT'    ;print statement
D52D: 43 4F 50 D9 >81            DCI   'COPY'     ;copy a file
D531: 47 45 D4    >82            DCI   'GET'      ;get a character
D534: 49 4E 50 55 >83            DCI   'INPUT'    ;input a line
D539: 53 45 54 49 >84            DCI   'SETINT'   ;set interupt keys
D53F: 41 44 44 49 >85            DCI   'ADDINT'   ;add interupt keys
D545: 46 4C 41 C7 >86            DCI   'FLAG'     ;user flags
D549: 4E 49 42 42 >87            DCI   'NIBBLE'   ;nibble function
D54F: 42 59 54 C5 >88            DCI   'BYTE'     ;byte function
D553: 49 C6       >89            DCI   'IF'       ;if statement
D555: 54 48 45 CE >90            DCI   'THEN'     ;then statement
D559: 45 4C 53 C5 >91            DCI   'ELSE'     ;else statement
D55D: 52 45 54 55 >92            DCI   'RETURN'   ;return statement
D563: 50 4F D0    >93            DCI   'POP'      ;pop statement
D566: 4D 4F 44 45 >94            DCI   'MODEM'    ;modem statement
D56B: 4C 45 CE    >95            DCI   'LEN'      ;string length
D56E: 45 43 48 CF >96            DCI   'ECHO'     ;set video echo
D572: 4C 4F C7    >97            DCI   'LOG'      ;log to a drive
D575: 4F 50 45 CE >98            DCI   'OPEN'     ;open a file
D579: 43 4C 4F 53 >99            DCI   'CLOSE'    ;close a file
D57E: 4D 41 52 CB >100           DCI   'MARK'     ;get/set function
D582: 56 41 CC    >101           DCI   'VAL'      ;val function
D585: 46 52 45 C5 >102           DCI   'FREE'     ;free statement
D589: 50 4F 53 49 >103           DCI   'POSITION' ;position statement
D591: 53 45 D4    >104           DCI   'SET'      ;set statement
D594: 52 45 41 44 >105           DCI   'READY'    ;ready statement
D599: 52 45 41 C4 >106           DCI   'READ'     ;read statement
D59D: 57 52 49 54 >107           DCI   'WRITE'    ;write statement
D5A2: 4E 4F D4    >108           DCI   'NOT'      ;not statement
D5A5: 4B 45 D9    >109           DCI   'KEY'      ;key function
D5A8: 45 44 49 D4 >110           DCI   'EDIT'     ;edit statement
D5AC: 4D 53 C7    >111           DCI   'MSG'      ;msg function
D5AF: 52 45 57 49 >112           DCI   'REWIND'   ;rewind statement
D5B5: 54 4F 4E C5 >113           DCI   'TONE'     ;tone function
D5B9: 57 49 44 54 >114           DCI   'WIDTH'    ;width function
D5BE: 46 4F D2    >115           DCI   'FOR'      ;for statement
D5C1: 54 CF       >116           DCI   'TO'       ;to statement
D5C3: 53 54 45 D0 >117           DCI   'STEP'     ;step statement
D5C7: 4E 45 58 D4 >118           DCI   'NEXT'     ;next statement
D5CB: 49 4E 53 54 >119           DCI   'INSTR'    ;instr function
D5D0: 4B 49 4C CC >120           DCI   'KILL'     ;kill statement
D5D4: 4D 4F 56 C5 >121           DCI   'MOVE'     ;move statement
D5D8: 52 41 4D B2 >122           DCI   'RAM2'     ;ram2 value
D5DC: 52 41 CD    >123           DCI   'RAM'      ;ram value
D5DF: 43 52 45 41 >124           DCI   'CREATE'   ;create statement
D5E5: 43 52 55 4E >125           DCI   'CRUNCH'   ;crunch statement
D5EB: 55 50 44 41 >126           DCI   'UPDATE'   ;update statement
D5F1: 54 45 58 D4 >127           DCI   'TEXT'     ;text command
D5F5: 41 50 50 45 >128           DCI   'APPEND'   ;append statement
D5FB: 46 49 4C CC >129           DCI   'FILL'     ;fill statement
D5FF: 4F 4E 20 4E >130           DCI   'ON NOCAR' ;on no carrier
D607: 4F 4E 20 45 >131           DCI   'ON ERROR' ;on error
D60F: 45 52 D2    >132           DCI   'ERR'      ;error number
D612: 52 45 53 55 >133           DCI   'RESUME'   ;resume from error
D618: 49 4E 46 CF >134           DCI   'INFO'     ;info function
D61C: 43 4C 4F 43 >135           DCI   'CLOCK'    ;time function
D621: 55 53 C5    >136           DCI   'USE'      ;use statement
D624: 50 4F 4B C5 >137           DCI   'POKE'     ;poke statement
D628: 50 45 45 CB >138           DCI   'PEEK'     ;peek function
D62C: 45 4F C6    >139           DCI   'EOF'      ;eof function
D62F: 53 49 5A C5 >140           DCI   'SIZE'     ;size function
D633: 50 44 CC    >141           DCI   'PDL'      ;pdl function
D636: 52 41 4E 44 >142           DCI   'RANDOM'   ;random function
D63C: 41 53 C3    >143           DCI   'ASC'      ;ascii function
D63F: 43 41 4C CC >144           DCI   'CALL'     ;call statement
D643: 53 54 4F 52 >145           DCI   'STORE'    ;store statement
D648: 52 45 43 41 >146           DCI   'RECALL'   ;recall statement
                  >147           IF    NET        
                  >148           DCI   'LOCK'     ;lock statement
                  >149           DCI   'UNLOCK'   ;unlock statement
                  >150           FIN              
                  >151  
D64E: 43 48 52 A4 >152           DCI   'CHR$'     ;chr$ statement
D652: 44 41 54 45 >153           DCI   'DATE$'    ;date statement
D657: 54 49 4D 45 >154           DCI   'TIME$'    ;time$ statement
D65C: 46 4D 54 44 >155           DCI   'FMTDATE$' ;formatted date statement
D664: 57 48 45 4E >156           DCI   'WHEN$'    ;when$ statement
D669: 4C 45 46 54 >157           DCI   'LEFT$'    ;left$ statement
D66E: 52 49 47 48 >158           DCI   'RIGHT$'   ;right$ statement
D674: 4D 49 44 A4 >159           DCI   'MID$'     ;mid$ statement
D678: 53 54 52 A4 >160           DCI   'STR$'     ;str$ statement
D67C: 52 4E 44 A4 >161           DCI   'RND$'     ;rnd$ function
                  >162  
D680: 3C BE       >163           DCI   '<>'       ;<>
D682: 3E BC       >164           DCI   '><'       ;><
D684: 3C BD       >165           DCI   '<='       ;<=
D686: 3E BD       >166           DCI   '>='       ;>=
D688: 3D BC       >167           DCI   '=<'       ;=<
D68A: 3D BE       >168           DCI   '=>'       ;=>
D68C: BD          >169           DCI   '='        ;=
D68D: BC          >170           DCI   '<'        ;<
D68E: BE          >171           DCI   '>'        ;>
                  >172  
D68F: 41 4E C4    >173           DCI   'AND'      ;and operand
D692: 4F D2       >174           DCI   'OR'       ;or operand
D694: 45 4F D2    >175           DCI   'EOR'      ;eor operand
                  >176  
D697: AB          >177           DCI   '+'        ;plus
D698: AD          >178           DCI   '-'        ;minus
D699: AA          >179           DCI   '*'        ;multiplication
D69A: AF          >180           DCI   '/'        ;division
D69B: 4D 4F C4    >181           DCI   'MOD'      ;mod
D69E: 41 42 D3    >182           DCI   'ABS'      ;absolute value
D6A1: 00          >183           DB    0          
                  >184  
                  >185  *-------------------------------
                  >186  * token jump table
                  >187  *-------------------------------
                  >188  
D6A2: 00 00       >189  SYMADR   DW    0          ;00
          =0001   >190  number   =     *-SYMADR/2 
D6A4: A8 38       >191           DW    DO_LET     ;01
          =0002   >192  string   =     *-SYMADR/2 
D6A6: A8 38       >193           DW    DO_LET     ;02
          =0003   >194  end      =     *-SYMADR/2 
D6A8: DF 12       >195           DW    DO_END     ;03
          =0004   >196  goto     =     *-SYMADR/2 
D6AA: B8 37       >197           DW    DO_GOTO    ;04
          =0005   >198  gosub    =     *-SYMADR/2 
D6AC: C5 37       >199           DW    DO_GSB     ;05
          =0006   >200  push     =     *-SYMADR/2 
D6AE: FD 37       >201           DW    DO_PUSH    ;06
          =0007   >202  public   =     *-SYMADR/2 
D6B0: 01 37       >203           DW    ERR        ;07
                  >204  
          =0008   >205  chain    =     *-SYMADR/2 
D6B2: 06 37       >206           DW    NIL        ;08
          =0009   >207  chain2   =     *-SYMADR/2 
D6B4: 06 37       >208           DW    NIL        ;09
                  >209  
          =000A   >210  clear    =     *-SYMADR/2 
D6B6: 62 38       >211           DW    DO_CLR     ;0A
D6B8: 54 25       >212           DW    DO_LINK    ;0B
D6BA: EF 44       >213           DW    DO_HOME    ;0C
D6BC: 07 37       >214           DW    DO_PRNT    ;0D
D6BE: AE 27       >215           DW    DO_SHOW    ;0E
D6C0: 06 3D       >216           DW    DO_GET     ;0F
D6C2: 09 3A       >217           DW    DO_IN      ;10
D6C4: A9 3C       >218           DW    DO_SINT    ;11
D6C6: BA 3C       >219           DW    DO_AINT    ;12
D6C8: EC 3D       >220           DW    DO_FLAG    ;13
D6CA: 79 3E       >221           DW    DO_NIB     ;14
D6CC: DF 3E       >222           DW    DO_BYT     ;15
D6CE: 12 39       >223           DW    DO_IF      ;16
D6D0: 06 37       >224           DW    NIL        ;17
          =0018   >225  else     =     *-SYMADR/2 
D6D2: 2E 39       >226           DW    DO_ELSE    ;18
D6D4: 1A 38       >227           DW    DO_RET     ;19
D6D6: 11 38       >228           DW    DO_POP     ;1A
D6D8: 4C 39       >229           DW    DO_MDM     ;1B
D6DA: F7 39       >230           DW    DO_LEN     ;1C
D6DC: 28 3B       >231           DW    DO_ECHO    ;1D
D6DE: 63 2F       >232           DW    MOVNAME    ;1E
D6E0: BA 23       >233           DW    DO_OPEN    ;1F
D6E2: 16 24       >234           DW    DO_CLOS    ;20
D6E4: 0A 25       >235           DW    DO_MARK    ;21
D6E6: 74 3C       >236           DW    DO_VAL     ;22
D6E8: C2 20       >237           DW    DO_FRE     ;23
D6EA: E7 28       >238           DW    DO_POS     ;24
D6EC: 47 3D       >239           DW    DO_SET     ;25
D6EE: FD 29       >240           DW    DO_RDY     ;26
D6F0: 48 29       >241           DW    DO_READ    ;27
D6F2: 6E 29       >242           DW    DO_WRIT    ;28
D6F4: DC 3D       >243           DW    DO_NOT     ;29
          =002A   >244  key      =     *-SYMADR/2 
D6F6: 21 3F       >245           DW    DO_KEY     ;2A
D6F8: 23 45       >246           DW    DO_EDIT    ;2B
          =002C   >247  msg      =     *-SYMADR/2 
D6FA: 62 2A       >248           DW    DO_MSG     ;2C
D6FC: 27 2B       >249           DW    DO_RWD     ;2D
D6FE: 93 44       >250           DW    DO_TONE    ;2E
D700: 58 3F       >251           DW    DO_WID     ;2F
D702: 6A 3F       >252           DW    DO_FOR     ;30
          =0031   >253  to       =     *-SYMADR/2 
D704: 01 37       >254           DW    ERR        ;31
          =0032   >255  step     =     *-SYMADR/2 
D706: 01 37       >256           DW    ERR        ;32
D708: CF 3F       >257           DW    DO_NXT     ;33
D70A: 41 3B       >258           DW    DO_INST    ;34
D70C: 94 29       >259           DW    DO_KILL    ;35
D70E: 63 40       >260           DW    DO_MOVE    ;36
D710: 92 40       >261           DW    DO_RAM2    ;37
D712: 8B 40       >262           DW    DO_RAM     ;38
D714: 3D 2E       >263           DW    DO_MAKE    ;39
D716: 49 2E       >264           DW    DO_CNCH    ;3A
D718: 26 2F       >265           DW    DO_UP      ;3B
D71A: EB 44       >266           DW    DO_TEXT    ;3C
D71C: 07 24       >267           DW    DO_APP     ;3D
D71E: EC 40       >268           DW    DO_FILL    ;3E
D720: 0C 41       >269           DW    DO_NOCD    ;3F
D722: 2D 41       >270           DW    DO_ONERR   ;40
D724: 28 41       >271           DW    DO_ERRNO   ;41
D726: 49 41       >272           DW    DO_RESUM   ;42
D728: 88 41       >273           DW    DO_INFO    ;43
D72A: A5 43       >274           DW    DO_CLOK    ;44
D72C: 2F 2F       >275           DW    DO_USE     ;45
D72E: 72 44       >276           DW    DO_POKE    ;46
D730: 85 44       >277           DW    DO_PEEK    ;47
D732: F6 24       >278           DW    DO_EOF     ;48
D734: E3 24       >279           DW    DO_SIZE    ;49
D736: F2 44       >280           DW    DO_PDL     ;4A
D738: C4 40       >281           DW    DO_RND     ;4B
D73A: 09 45       >282           DW    DO_ASC     ;4C
D73C: 19 45       >283           DW    DO_CALL    ;4D
D73E: D8 25       >284           DW    DO_STOR    ;4E
D740: 24 26       >285           DW    DO_RCAL    ;4F
                  >286           IF    NET        
                  >287           DW    DO_LOCK    
                  >288           DW    DO_UNLK    
                  >289           FIN              
                  >290  
          =0050   >291  strtyp   =     *-SYMADR/2 
D742: 42 3C       >292           DW    DO_CHR     ;50
D744: 56 42       >293           DW    DO_DATE    ;51
D746: B5 42       >294           DW    DO_TIME    ;52
D748: BC 42       >295           DW    DO_FDATE   ;53
D74A: 28 42       >296           DW    DO_WHEN    ;54
D74C: CC 3B       >297           DW    DO_LFT     ;55
D74E: D2 3B       >298           DW    DO_RGT     ;56
D750: EA 3B       >299           DW    DO_MID     ;57
D752: 94 3D       >300           DW    DO_STR     ;58
D754: 99 40       >301           DW    DO_RNDS    ;59
          =005A   >302  compare  =     *-SYMADR/2 
D756: BD 22       >303           DW    CP_NOT     ;5A
D758: BD 22       >304           DW    CP_NOT     ;5B
D75A: E1 22       >305           DW    CP_LTEQ    ;5C
D75C: F0 22       >306           DW    CP_GTEQ    ;5D
D75E: E1 22       >307           DW    CP_LTEQ    ;5E
D760: F0 22       >308           DW    CP_GTEQ    ;5F
          =0060   >309  equal    =     *-SYMADR/2 
D762: B4 22       >310           DW    CP_EQ      ;60
D764: C9 22       >311           DW    CP_LT      ;61
D766: D5 22       >312           DW    CP_GT      ;62
                  >313  
          =0063   >314  logic    =     *-SYMADR/2 
D768: FF 22       >315           DW    CP_AND     ;63
D76A: 12 23       >316           DW    CP_OR      ;64
D76C: 25 23       >317           DW    CP_EOR     ;65
                  >318  
          =0066   >319  math     =     *-SYMADR/2 
D76E: 6D 21       >320           DW    DO_PLUS    ;66
          =0067   >321  minus    =     *-SYMADR/2 
D770: 85 21       >322           DW    DO_SUB     ;67
D772: A6 21       >323           DW    DO_MULT    ;68
D774: 2A 22       >324           DW    DO_DIVD    ;69
D776: 30 22       >325           DW    DO_MOD     ;6A
D778: 95 22       >326           DW    DO_ABS     ;6B
D77A: 00 00       >327           DW    0          ;6C
                  >328  
                  >329  *-------------------------------
                  >330  * system error messages
                  >331  *-------------------------------
                  >332  
D77C: FF          >333  ERRMSGS  DB    -1         
D77D: 53 74 61 72 >334           DCI   'Starting Module Not Found' 
D796: 4D 6F 64 75 >335           DCI   'Module Too Large' 
D7A6: 4C 61 62 65 >336           DCI   'Label Not Found' 
D7B5: 53 79 6D 62 >337           DCI   'Symbol Table Full' 
D7C6: 53 79 6E 74 >338           DCI   'Syntax Error' 
D7D2: 4D 69 73 73 >339           DCI   'Missing Symbol' 
D7E0: 55 6E 64 65 >340           DCI   'Undefined Label' 
D7EF: 4D 69 73 73 >341           DCI   'Missing Data' 
D7FB: 54 79 70 65 >342           DCI   'Type Mismatch' 
D808: 4F 76 65 72 >343           DCI   'Overflow > 32767' 
D818: 44 69 76 69 >344           DCI   'Division By 0' 
D825: 53 74 72 69 >345           DCI   'String Too Long' 
D834: 47 6F 73 75 >346           DCI   'Gosub Stack Full' 
D844: 52 65 74 75 >347           DCI   'Return Without Gosub' 
D858: 42 61 64 20 >348           DCI   'Bad Device Number' 
D869: 49 6C 6C 65 >349           DCI   'Illegal Filename' 
D879: 46 6F 72 20 >350           DCI   'For Stack Full' 
D887: 4E 65 78 74 >351           DCI   'Next Without For' 
D897: 4C 69 6E 6B >352           DCI   'Link Label Not Found' 
D8AB: 4D 65 73 73 >353           DCI   'Message File Not Found' 
D8C1: 45 4E 44 20 >354           DCI   'END of Program' 
D8CF: 42 61 64 20 >355           DCI   'Bad Drive Specifier' 
D8E2: 55 6E 61 62 >356           DCI   'Unable to Load External' 
D8F9: 55 6E 63 6C >357           DCI   'Unclosed quote at EOF......' 
                  >358  
                  >359  *-------------------------------
                  >360  * misc. messages
                  >361  *-------------------------------
                  >362  
D914: FF          >363  MISCMSGS DB    -1         
D915: 0D 0D       >364           DB    cr,cr      
D917: 53 79 73 6F >365           ASC   'Sysop is on-line...'0D8D 
D92C: 0D          >366           DB    cr         
D92D: 53 79 73 6F >367           ASC   'Sysop is off-line...'0D8D 
D943: 0D 0D       >368           DB    cr,cr      
D945: 53 6F 72 72 >369           ASC   'Sorry, time limit exceeded'8D 
D960: 2E 2E 2E 70 >370           ASC   '...please wait...'0D8D 
D973: 2E 2E 2E 65 >371           ASC   '...exiting exec mode...'0D8D 
D98C: 0D          >372           DB    cr         
D98D: 45 72 72 6F >373           ASC   'Error: Help file could not be opened'8D 
D9B2: 0D          >374           DB    cr         
D9B3: 46 69 6C 65 >375           ASC   'File Write Error'8D 
D9C4: 0D          >376           DB    cr         
D9C5: 4F 6E 65 20 >377           ASC   'One moment please...'8D 
                  >378  
                  >379  *-------------------------------
                  >380  * editor messages
                  >381  *-------------------------------
                  >382  
D9DA: FF          >383  EDMSGS   DB    -1         
D9DB: 0D          >384           DB    cr         
D9DC: 45 64 69 74 >385           DCI   'Editing (?=Help):' 
D9ED: 0D          >386           DB    cr         
D9EE: 54 68 61 74 >387           ASC   'That is 4k worth'8D 
D9FF: 0D          >388           DB    cr         
DA00: 49 6C 6C 65 >389           ASC   'Illegal Command'8D 
DA10: 0D          >390           DB    cr         
DA11: 41 62 6F 72 >391           DCI   'Abort: Are you sure?' 
DA25: 0D          >392           DB    cr         
DA26: 41 62 6F 72 >393           ASC   'Aborted'8D 
DA2E: 0D          >394           DB    cr         
DA2F: 43 6F 6E 74 >395           ASC   'Continue message now...'0D8D 
DA48: 0D          >396           DB    cr         
DA49: 44 65 6C 65 >397           DCI   'Delete Line (L,x-y):' 
DA5D: 0D          >398           DB    cr         
DA5E: 45 64 69 74 >399           DCI   'Edit Line (L,x):' 
DA6E: 0D          >400           DB    cr         
DA6F: 49 6C 6C 65 >401           ASC   'Illegal line number'8D 
DA83: 0D          >402           DB    cr         
DA84: 49 6E 73 65 >403           DCI   'Insert Line (L,x):' 
DA96: 0D          >404           DB    cr         
DA97: 4C 69 73 74 >405           DCI   'List Line (x-y):' 
DAA7: 0D          >406           DB    cr         
DAA8: 49 6E 73 65 >407           ASC   'Insert text: Type "DONE" When Finished'0D8D 
DAD0: 0D          >408           DB    cr         
DAD1: 4E 65 77 3A >409           DCI   'New: Erase and start over?' 
DAEB: 0D          >410           DB    cr         
DAEC: 45 6E 74 65 >411           ASC   'Enter message now...'0D8D 
DB02: 0D          >412           DB    cr         
DB03: 52 65 61 64 >413           DCI   'Read File (name):' 
DB14: 0D          >414           DB    cr         
DB15: 57 72 69 74 >415           DCI   'Write File (name):' 
DB27: 0D          >416           DB    cr         
DB28: 28 2A 3E 20 >417           ASC   '(*> ACOS Editor Help <*)'0D0D 
DB42: 41 29 62 6F >418           ASC   'A)bort, C)ontinue, D)elete, E)dit'0D 
DB64: 48 29 65 6C >419           ASC   'H)elp, I)nsert, L)ist, N)ew, S)ave'0D 
DB87: 5A 29 20 53 >420           ASC   'Z) Space Used'8D 
DB95: 4C 65 67 61 >421           ASC   'Legal (.) Dot Commands:'0D0D 
DBAE: 2E 41 20 3D >422           ASC   '.A = Abort  ' 
DBBA: 2E 48 20 3D >423           ASC   '.H = Help  ' 
DBC5: 2E 44 78 2D >424           ASC   '.Dx-Y = Delete'0D 
DBD4: 2E 4E 20 3D >425           ASC   '.N = New    ' 
DBE0: 2E 4F 20 3D >426           ASC   '.O = Ok    ' 
DBEB: 2E 45 78 20 >427           ASC   '.Ex   = Edit'0D 
DBF8: 2E 5A 20 3D >428           ASC   '.Z = Space  ' 
DC04: 2E 53 20 3D >429           ASC   '.S = Save  ' 
DC0F: 2E 49 78 20 >430           ASC   '.Ix   = Insert'0D 
DC1E: 2E 50 20 3D >431           ASC   '.P = Prompt            ' 
DC35: 2E 4C 78 2D >432           ASC   '.Lx-Y = List'0D8D 
                  >433  
                  >434  *-------------------------------
                  >435  * compiler messages
                  >436  *-------------------------------
                  >437  
DC43: FF          >438  COMPMSGS DB    -1         
DC44: 4F 6E 65 20 >439           DCI   'One moment, compiling segment.' 
DC62: 2E AE       >440           DCI   '..'       
DC64: 08 08 08 08 >441           DS    32,bs      
DC84: 20 20 20 20 >442           DS    32,' '     
DCA4: 08 08 08 08 >443           DS    31,bs      
DCC3: 88          >444           DB    bs+hibit   
                  >445  
DCC4: 83          >446  MODEBYT  DB    %10000011  ;default, get 1 byte only
DCC5: C1          >447           DB    %11000001  ;upper / no blanks / no comma
DCC6: A0          >448           DB    %10100000  ;upper and return
DCC7: 20          >449           DB    %00100000  ;accept all and return
DCC8: 60          >450           DB    %01100000  ;no blanks / no comma / return
                  >451  
DCC9: C3 14       >452  INPVEC   DW    KEYIN      ;console keyboard
DCCB: 5B 24       >453           DW    DISKIN1    ;disk channel 1
DCCD: 64 24       >454           DW    DISKIN2    ;disk channel 2
DCCF: 25 3B       >455           DW    NO_INP     ;console input
DCD1: 15 0E       >456           DW    MDMIN      ;modem input
DCD3: 25 3B       >457           DW    NO_INP     ;line printer
DCD5: A1 2B       >458           DW    RDMSG      ;msg input
DCD7: 0F 2B       >459           DW    RDMAIL     ;read mail
DCD9: 39 4F       >460           DW    EDINP      ;editor input
DCDB: 25 3B       >461           DW    NO_INP     ;no input from screen
DCDD: DC 1C       >462           DW    RAMIN      ;ram drive input
                  >463  
DCDF: 7B 17       >464  OUTVEC   DW    COUT       ;console output
DCE1: 6D 24       >465           DW    DSKOUT1    ;disk channel 1
DCE3: 78 24       >466           DW    DSKOUT2    ;disk channel 2
DCE5: 06 09       >467           DW    VIDCOUT    ;local console
DCE7: 16 1D       >468           DW    ZMDMOUT    ;modem output
DCE9: 04 0C       >469           DW    PRCOUT     ;line printer
DCEB: 6F 2C       >470           DW    WRMSG      ;msg output
DCED: 27 3B       >471           DW    NO_OUT     ;read mail [none]
DCEF: 4E 4F       >472           DW    EDOUT      ;editor output
DCF1: 5C 18       >473           DW    TOPPRINT   ;print user stats
DCF3: EC 1C       >474           DW    RAMOUT     ;ram drive output
                  >475  
DCF5: 2D 20       >476  JSTRCP   DA    ST_NOT     
DCF7: 2D 20       >477           DA    ST_NOT     
DCF9: 42 20       >478           DA    ST_LTEQ    
DCFB: 4B 20       >479           DA    ST_GTEQ    
DCFD: 42 20       >480           DA    ST_LTEQ    
DCFF: 4B 20       >481           DA    ST_GTEQ    
DD01: 27 20       >482           DA    ST_EQ      
DD03: 36 20       >483           DA    ST_LT      
DD05: 3C 20       >484           DA    ST_GT      
                  >485  
DD07: FF 00 00 FF >486  DEVTBL   HEX   FF0000FFFFFF0000FFFFFF 
DD12: 47 50 32 31 >487           ASC   'GP214182' ;fake serial number for peepers
                  >488  
                  >489  * screen top mask
                  >490  
DD1A: 23 2E 2E 2E >491  TOPMASK  ASC   '#..... ...............................  ' 
DD42: 53 74 61 74 >492           ASC   'Stats: CT=.. CM=... UP=.. DL=... BP=... ' 
DD6A: 50 68 3A 20 >493           ASC   'Ph: ............ ........ ....-******** ' 
DD92: 46 6C 67 3A >494           ASC   'Flg: .................................. ' 
                  >495  
DDBA: 00 03 06 09 >496  DAYINDEX DB    0,3,6,9,12,15,18 
                  >497  
DDC1: 53 75 6E    >498  DAYS     ASC   'Sun'      
DDC4: 4D 6F 6E    >499           ASC   'Mon'      
DDC7: 54 75 65    >500           ASC   'Tue'      
DDCA: 57 65 64    >501           ASC   'Wed'      
DDCD: 54 68 75    >502           ASC   'Thu'      
DDD0: 46 72 69    >503           ASC   'Fri'      
DDD3: 53 61 74    >504           ASC   'Sat'      
                  >505  
DDD6: 00 03 06 09 >506  MTHINDEX DB    0,3,6,9,12,15,18,21,24,27,30,33 
                  >507  
DDE2: 4A 61 6E    >508  MONTHS   ASC   'Jan'      
DDE5: 46 65 62    >509           ASC   'Feb'      
DDE8: 4D 61 72    >510           ASC   'Mar'      
DDEB: 41 70 72    >511           ASC   'Apr'      
DDEE: 4D 61 79    >512           ASC   'May'      
DDF1: 4A 75 6E    >513           ASC   'Jun'      
DDF4: 4A 75 6C    >514           ASC   'Jul'      
DDF7: 41 75 67    >515           ASC   'Aug'      
DDFA: 53 65 70    >516           ASC   'Sep'      
DDFD: 4F 63 74    >517           ASC   'Oct'      
DE00: 4E 6F 76    >518           ASC   'Nov'      
DE03: 44 65 63    >519           ASC   'Dec'      
                  >520  
DE06: 00          >521  TOPBUF   DB    0          
                  >522  
          =DE07   >523  DUMMY    =     *          ;standard memory allocation
                  >524  
                  >525           DUM   DUMMY      
                  >526  
DE07: 00 00 00 00 >527           DS    159        ;finish up TOPBUF
                  >528  
DEA6: 00 00 00 00 >529  GSBSTK   DS    $20        ;gosub stack area
                  >530  
DEC6: 00 00 00 00 >531  FORVAR   DS    $10        ;for stack area
DED6: 00 00 00 00 >532  FOREND   DS    $10        
DEE6: 00 00 00 00 >533  FORSTP   DS    $10        
DEF6: 00 00 00 00 >534  FORLOC   DS    $10        
                  >535  
DF06: 00 00 00 00 >536  DEVUSE   DS    11         
                  >537  
DF11: 00 00 00 00 >538  NUM      DS    7          
DF18: 00 00 00 00 >539  TXTNUM   DS    6          
DF1E: 00 00 00 00 >540  FLPOS    DS    6          
                  >541  
DF24: 00 00 00 00 >542  DATA     DS    4          
DF28: 00 00       >543  NUMB     DA    0          
DF2A: 00          >544  NEGFLG   DB    0          
DF2B: 00          >545  FREMEM   DB    0          
                  >546  
DF2C: 00          >547  NOCDFLG  DB    0          
DF2D: 00 00       >548  NOCDVEC  DA    0          
                  >549  
DF2F: 00          >550  ONERRFLG DB    0          
DF30: 00 00       >551  ONERRVEC DA    0          
DF32: 00 00       >552  FROMERR  DA    0          ;where error occurred
                  >553  
DF34: 00          >554  NULLS    DB    0          
DF35: 00          >555  REMOTE   DB    0          
                  >556  
DF36: 00          >557  SYMNUM   DB    0          
DF37: 00          >558  LBLNUM   DB    0          
DF38: 00          >559  LNCNT    DB    0          
DF39: 00          >560  LNCNT2   DB    0          
DF3A: 00          >561  TOKTYP   DB    0          
                  >562  
DF3B: 00          >563  CPASS    DB    0          
                  >564  
DF3C: 00 00       >565  REMAIN   DA    0          
DF3E: 00          >566  SIGN     DB    0          
DF3F: 00 00 00    >567  RESULT   DS    3          
                  >568  
DF42: 00          >569  MSGREF   DB    0          ;is message file ready to go?
                  >570  
DF43: 00          >571  MSGINFO  DB    0          ;# of bit blocks (512k each)
DF44: 00          >572           DB    0          ;# of dir blocks (32 entries each)
DF45: 00 00       >573           DW    0          ;# of free blocks
DF47: 00 00       >574           DW    0          ;# of files
DF49: 00 00       >575           DW    0          ;# of newest message
                  >576  
DF4B: 00          >577  MSGPTR   DB    0          ;point to message data
DF4C: 00          >578  BYTE8    DB    0          ;7 -> 8 conversion counter
DF4D: 00          >579  CHAR8    DB    0          ;7 -> 8 conversion data
DF4E: 00 00       >580  RMXBLK   DW    0          ;read mail block
DF50: 00          >581  RDEND    DB    0          ;at end of data?
                  >582  
DF51: 00          >583  MSGPTR2  DB    0          ;for write data
DF52: 00          >584  BYTE82   DB    0          ;second set of pointers
DF53: 00          >585           DB    0          ;second char8 buffer - not needed for write
DF54: 00 00       >586  WRKBLK   DW    0          ;current working write block num
DF56: 00          >587  WRTEND   DB    0          ;at end of data?
                  >588  
DF57: 00          >589  RWDPTR   DB    0          ;point to rewind data
DF58: 00          >590  RWDBYT8  DB    0          
DF59: 00          >591  RWDCHR8  DB    0          
DF5A: 00 00       >592  RWDBLK   DW    0          
                  >593  
DF5C: 00 00       >594  DIRSEG   DA    0          ;current directory segment
DF5E: 00          >595  BITSEG   DB    0          ;current bit-map segment
                  >596  
DF5F: 00 00       >597  MSGNUM   DW    0          ;current message number
DF61: 00 00       >598  POSBLK   DW    0          ;postion block counter
                  >599  
DF63: 00          >600  MSGINIT  DB    0          ;is message currently being read?
                  >601  
DF64: 00 00 00 00 >602  CHATBUF  DS    90         ;storage area for chat routine
                  >603  
                  >604  LASTBYT                   
                  >605           DEND             
                  >606           ORG              
          =0907   >607  END_MV   =     *-ZDATA    
                  >608  
                  >609  PG3JMP   ORG   $380       
                  >610  
0380: 4C CC 16    >611  ENTPOINT JMP   GETBYT     
0383: 4C E4 16    >612           JMP   CHKBYT     
0386: 4C F3 16    >613           JMP   GOBCOM     
0389: 4C AB 1D    >614           JMP   INPNUM     
038C: 4C 07 1F    >615           JMP   INPSTR     
038F: 4C 63 2F    >616           JMP   MOVNAME    
0392: 4C E1 12    >617           JMP   BADERR     
0395: 4C FA 1C    >618           JMP   SETIVEC    
0398: 4C CC 15    >619           JMP   GET        
039B: 4C 43 18    >620           JMP   GETCHR     
039E: 4C C4 13    >621           JMP   INPLN      
03A1: 4C 08 1D    >622           JMP   SETOVEC    
03A4: 4C 7B 17    >623           JMP   COUT       
03A7: 4C 35 1A    >624           JMP   DECOUT0    
03AA: 4C 88 30    >625           JMP   CREATE     
03AD: 4C B6 30    >626           JMP   OPEN       
03B0: 4C D8 30    >627           JMP   CLOSE      
03B3: 4C 1F 31    >628           JMP   RDBYTE     
03B6: 4C 6A 31    >629           JMP   WRBYTE     
03B9: 4C 42 31    >630           JMP   RDBLK      
03BC: 4C 38 31    >631           JMP   WRBLK      
03BF: 4C 02 31    >632           JMP   RDLINE     
03C2: 4C F9 31    >633           JMP   GETMARK    
03C5: 4C D5 31    >634           JMP   SETMARK    
03C8: 4C D6 2F    >635           JMP   LOGSPEC    
                  >636  
03CB: 72 30       >637           DA    FLNAME     
03CD: 00          >638  REFNUM   DB    0          
03CE: 00 AE       >639           DA    FBUF2      
                   50   
                   51            DSK   ENCODE     
                   52   
                   53            PUT   ENCODE     
                  >2    ********************************
                  >3    *                              *
                  >4    * ACOS.OBJ - Copyright Encode  *
                  >5    *                              *
                  >6    ********************************
                  >7    
                  >8             ORG   $300       
                  >9    
0300: A9 79       >10   COPCODE  LDA   #<COPNOT   
0302: 85 00       >11            STA   TEMP       
0304: A9 4F       >12            LDA   #>COPNOT   
0306: 85 01       >13            STA   TEMP+1     
0308: A0 2C       >14            LDY   #COPEND-COPNOT 
030A: 88          >15            DEY              
030B: B1 00       >16   :LOOP    LDA   (TEMP),Y   
030D: 2A          >17            ROL   A          
030E: 49 2C       >18            EOR   #COPEND-COPNOT 
0310: 91 00       >19            STA   (TEMP),Y   
0312: 88          >20            DEY              
0313: 10 F6 =030B >21            BPL   :LOOP      
                  >22   
0315: A9 70       >23            LDA   #<SERNUM   
0317: 85 00       >24            STA   TEMP       
0319: A9 4F       >25            LDA   #>SERNUM   
031B: 85 01       >26            STA   TEMP+1     
031D: A0 09       >27            LDY   #SEREND-SERNUM 
031F: 88          >28            DEY              
0320: B1 00       >29   :LOOP2   LDA   (TEMP),Y   
0322: 2A          >30            ROL   A          
0323: 49 09       >31            EOR   #SEREND-SERNUM 
0325: 91 00       >32            STA   (TEMP),Y   
0327: 88          >33            DEY              
0328: 10 F6 =0320 >34            BPL   :LOOP2     
032A: 60          >35            RTS              
                  >36   
                  >37   


End Merlin-16 assembly, 21192 bytes, 0 errors, 11639 lines, 937 symbols.

Elapsed time = 31 seconds.

Symbol table, alphabetical order:

   ADD_L11 =$36AF      ADD_L12 =$361B      ADD_LBL =$3622      ADD_SYM =$35C5
   AINT0   =$3CD3      AINT1   =$3CE7      AINT2   =$3CFE      AINT3   =$3D01
   ALLOC   =$2D0A      ANU_ON  =$C05B      APPEND  =$31CF      ARGPTR  =$1D
   ARGTYP  =$1ED8      AUTORST =$13BD      BADERR  =$12E1      BBS_PRG =$13A6
   BFOPEN  =$30B8      BINDEC8 =$1A23      BITBUF  =$B780      BITMAP  =$BF58
   BITSEG  =$DF5E      BITVAL  =$3E6F      BLKBUF  =$B800      BLKBUF2 =$B880
   BSOUT   =$4EE5      BUFADR  =$30D5      BUF_X   =$62        BYTE8   =$DF4C
   BYTE82  =$DF52      BYTPTR  =$67        CENTER  =$4C8D      CENTER7 =$4CD5
   CH      =$24        CHAR8   =$DF4D      CHAT2   =$1CAA      CHATBUF =$DF64
   CHK4SN  =$4451      CHKBYT  =$16E4      CHKDCD  =$170D      CHKDSK  =$24DD
   CHKEOF  =$31AB      CHKFRE  =$20BB      CHKLAST =$4DF9      CHKLIST =$4F02
   CHKLST2 =$4F1E      CHKRNG  =$4DDF      CHKRNG2 =$4DF7      CHKTIME =$1726
   CLEAR   =$3871      CLK0    =$43C2      CLK1    =$43CA      CLK1A   =$43CD
   CLK2    =$43D0      CLKBASE =$6F        CLKJMP  =$43BC      CLKRTN  =$43C9
   CLOSE   =$30D8      CLRBUF  =$183A      CLRDEV  =$3832      CLRKEY  =$3859
   CLRSTK  =$3852      CLRTOP  =$18BA      CMD     =$0C        CMPEQ   =$2369
   CMPGT   =$2399      CMPLT   =$237F      CMPSTR  =$4D2C      CMPSTR2 =$4D2E
   CMPSTR3 =$4D2A      CODEND  =$5100      COMP8   =$2726      COMPMSGS=$DC43
   COMPRES =$266A      CONT    =$4F1F      CONV    =$176E      CONV2   =$177A
   CONVSEC =$43FA      COPEND  =$4FA5      COPNOT  =$4F79      COUT    =$177B
   COUT0   =$179D      COUT0C  =$179A      COUT1   =$17AA      COUT1A  =$17CA
   COUT1B  =$17CD      COUT1C  =$17BF      COUT2   =$17CF      COUT3   =$1818
   CPASS   =$DF3B      CP_AND  =$22FF      CP_END  =$235D      CP_EOR  =$2325
   CP_EQ   =$22B4      CP_GT   =$22D5      CP_GTEQ =$22F0      CP_LT   =$22C9
   CP_LTEQ =$22E1      CP_LTGT =$234C      CP_NOT  =$22BD      CP_OR   =$2312
   CP_ST   =$2338      CREATE  =$3088      CROUT   =$14A9      CR_ERR  =$47B7
   CR_ERR0 =$4828      CR_RET  =$47B6      CR_RET2 =$470D      CV      =$25
   DATA    =$DF24      DATEPTR =$4393      DATESTR =$42AD      DAYINDEX=$DDBA
   DAYS    =$DDC1      DEALLOC =$2D65      DECOUT  =$1A3E      DECOUT0 =$1A35
   DECOUT1 =$1A50      DELFILE =$3210      DEL_TX0 =$4E5E      DEL_TX4 =$4E7E
   DEL_TXT =$4E5A      DEVCLR  =$1F        DEVNAM  =$0815      DEVTBL  =$DD07
   DEVUSE  =$DF06      DIRBUF  =$B900      DIRSEG  =$DF5C      DISKIN1 =$245B
   DISKIN2 =$2464      DOCHAT  =$5D        DOT_DEL =$46E6      DOT_E   =$4C50
   DOT_E1  =$4711      DOT_ED  =$4730      DOT_HLP =$4CD6      DOT_INS =$47CC
   DOT_LST =$4833      DOT_OK  =$4931      DOT_PMT =$48B4      DOT_SAVE=$4C4F
   DO_ABS  =$2295      DO_ABS1 =$22A1      DO_ABS2 =$22B3      DO_AINT =$3CBA
   DO_APP  =$2407      DO_ASC  =$4509      DO_BELL =$1C03      DO_BYT  =$3EDF
   DO_CALL =$4519      DO_CHAT =$1C9F      DO_CHR  =$3C42      DO_CL3  =$2432
   DO_CL6  =$245A      DO_CLOK =$43A5      DO_CLOS =$2416      DO_CLR  =$3862
   DO_CNCH =$2E49      DO_DATE =$4256      DO_DIV1 =$2242      DO_DIVD =$222A
   DO_DT2  =$426A      DO_ECHO =$3B28      DO_EDIT =$4523      DO_ELSE =$392E
   DO_END  =$12DF      DO_EOF  =$24F6      DO_ERRNO=$4128      DO_EXEC =$1C55
   DO_FDATE=$42BC      DO_FILL =$40EC      DO_FLAG =$3DEC      DO_FOR  =$3F6A
   DO_FRE  =$20C2      DO_GET  =$3D06      DO_GOTO =$37B8      DO_GSB  =$37C5
   DO_GT2  =$37BF      DO_HOME =$44EF      DO_IF   =$3912      DO_IF3  =$3926
   DO_IF4  =$3911      DO_IN   =$3A09      DO_INFO =$4188      DO_INP  =$3B22
   DO_INST =$3B41      DO_ISTR =$3C25      DO_KEY  =$3F21      DO_KILL =$2994
   DO_LEN  =$39F7      DO_LET  =$38A8      DO_LFT  =$3BCC      DO_LINK =$2554
   DO_MAKE =$2E3D      DO_MARK =$250A      DO_MATH =$219A      DO_MDM  =$394C
   DO_MID  =$3BEA      DO_MLD2 =$21AC      DO_MLDV =$21C4      DO_MOD  =$2230
   DO_MOVE =$4063      DO_MSG  =$2A62      DO_MUL0 =$21E9      DO_MULT =$21A6
   DO_NIB  =$3E79      DO_NOCD =$410C      DO_NOT  =$3DDC      DO_NXT  =$3FCF
   DO_ONERR=$412D      DO_OPEN =$23BA      DO_OUT  =$37B5      DO_PDL  =$44F2
   DO_PEEK =$4485      DO_PLUS =$216D      DO_POKE =$4472      DO_POP  =$3811
   DO_POS  =$28E7      DO_PRNT =$3707      DO_PUSH =$37FD      DO_RAM  =$408B
   DO_RAM2 =$4092      DO_RCAL =$2624      DO_RDY  =$29FD      DO_READ =$2948
   DO_RESUM=$4149      DO_RET  =$381A      DO_RET2 =$382E      DO_RET3 =$382F
   DO_RGT  =$3BD2      DO_RND  =$40C4      DO_RNDS =$4099      DO_RWD  =$2B27
   DO_SED  =$3CA6      DO_SET  =$3D47      DO_SHOW =$27AE      DO_SINT =$3CA9
   DO_SIZE =$24E3      DO_STOR =$25D8      DO_STR  =$3D94      DO_SUB  =$2185
   DO_TEXT =$44EB      DO_TIME =$42B5      DO_TONE =$4493      DO_UP   =$2F26
   DO_USE  =$2F2F      DO_VAL  =$3C74      DO_WHEN =$4228      DO_WID  =$3F58
   DO_WRIT =$296E      DO_XSTR =$3C1C      DRVCHD  =$306E      DRVNUM  =$306F
   DRVOFF0 =$3070      DRVOFF1 =$3071      DSKOUT1 =$246D      DSKOUT2 =$2478
   DUMMY   =$DE07      EBUFEND =$ADFF      EDBUF   =$9E00      EDIN3   =$4F2F
   EDINP   =$4F39      EDJMP   =$453D      EDLINE  =$54        EDLN0   =$4B20
   EDLN1   =$4C26      EDLN10  =$4BEE      EDLN11  =$4BFF      EDLN11A =$4C21
   EDLN11B =$4C25      EDLN12  =$4C35      EDLN13  =$4C40      EDLN2   =$4B30
   EDLN3   =$4B3D      EDLN4   =$4B5A      EDLN5   =$4B6A      EDLN6   =$4B94
   EDLN7   =$4BC5      EDLN7B  =$4BCF      EDLN8   =$4BD2      EDLN9   =$4BDF
   EDLNCR  =$4A73      EDLNCR0 =$4A8B      EDLNCR1 =$4AC7      EDLNCR2 =$4AFB
   EDMSGS  =$D9DA      EDOUT   =$4F4E      EDPTR   =$19        EDSIZE  =$1000
   EDSTACK =$4C46      ED_ABT  =$46B0      ED_CLR  =$4577      ED_CMD  =$461D
   ED_CMD2 =$4630      ED_CON1 =$46C1      ED_CONT =$46C7      ED_DEL  =$46D9
   ED_ED   =$4723      ED_ERR  =$470E      ED_EX   =$49C4      ED_HLP  =$4671
   ED_HLP2 =$4676      ED_INS  =$47BF      ED_LN   =$45DC      ED_LNCR =$45D9
   ED_LOC  =$4597      ED_LST  =$482B      ED_LST1 =$484C      ED_MODE =$45B5
   ED_NEW  =$4881      ED_NEW2 =$48C3      ED_OK   =$4936      ED_RD   =$48D6
   ED_RD3  =$48F5      ED_RD4  =$48FB      ED_RTS  =$46D8      ED_RW   =$48C4
   ED_SHLN =$4854      ED_SPC  =$4587      ED_STX  =$4549      ED_USED =$489E
   ED_WIDTH=$459E      ED_WRT  =$4900      ENDMOD  =$9E00      END_MV  =$0907
   ENTPOINT=$0380      ERR     =$3701      ERRMSGS =$D77C      ERRNO   =$DE
   ERROR   =$1991      ERROR2  =$19B3      ERVAL   =$0A        EXEC    =$1C
   EXEC2   =$1C7A      EXE_DOT =$4C47      EXTERN  =$28CB      EXTERN2 =$28E2
   EX_TOK  =$1958      FATAL   =$1200      FATAL1  =$1203      FATAL5  =$1274
   FATAL6  =$1282      FBUF1   =$B200      FBUF2   =$AE00      FILTER  =$5000
   FINDEND =$4EB2      FINDLN  =$4CF2      FINISH  =$2A48      FLGPTR  =$3E77
   FLNAME  =$3072      FLPOS   =$DF1E      FLUSH   =$30E5      FMTDATE =$4394
   FNDLEN  =$4D20      FOREND  =$DED6      FORLOC  =$DEF6      FORLVL  =$79
   FORSTP  =$DEE6      FORVAR  =$DEC6      FREMEM  =$DF2B      FROMERR =$DF32
   GET     =$15CC      GET2    =$1632      GET3    =$1647      GET3B   =$165E
   GET4    =$15C9      GET5    =$1593      GET6    =$159C      GET6A   =$15AC
   GET7    =$15B6      GET8    =$15BD      GET8A   =$1661      GET8B   =$167E
   GET9    =$15C2      GETBITS =$2D8B      GETBYT  =$16CC      GETCHR  =$1843
   GETCMD  =$4CDB      GETDATE =$0D02      GETDEV  =$2485      GETDEV2 =$24D8
   GETED1  =$49ED      GETED2  =$49F6      GETEDL2 =$49EB      GETEDLN =$49C9
   GETEOF  =$3195      GETMARK =$31F9      GETNUMB =$1DFF      GETPFX  =$3082
   GETRAW  =$16BD      GETSIZ  =$31C5      GETTIME =$0D05      GOBBLE  =$16F5
   GOBBLE2 =$16EE      GOBBYT  =$1705      GOBCOM  =$16F3      GOBEQU  =$16EF
   GO_ERR  =$3F67      GSBLVL  =$78        GSBSTK  =$DEA6      GTSTRINF=$1F59
   HIMEM   =$73        HLPFILE =$46A6      IFGOB   =$3937      IFOPEN  =$23F2
   IMMDEF  =$6B        INCHAT  =$5E        INCTMP  =$1706      INCXA4  =$4E30
   INCXARG =$4E1B      INF0    =$41B4      INF1    =$41BA      INF2    =$41D6
   INF3    =$41DC      INF4    =$41EE      INF5    =$41F8      INF6    =$4210
   INFOJMP =$41A6      INPARG  =$1EA1      INPLN   =$13C4      INPLN7  =$14AB
   INPLN8  =$14AE      INPLNA  =$13BF      INPMATH =$1DD8      INPMODE =$1699
   INPMTH1 =$1DDB      INPNARG =$1E8F      INPNM2  =$1E86      INPNM3  =$1E81
   INPNUM  =$1DAB      INPNUM0 =$1E0D      INPNUM2 =$1E6E      INPPAR  =$1DEA
   INPPAR2 =$1E05      INPSARG =$1E99      INPSTR  =$1F07      INPSTR0 =$1F60
   INPTYP  =$19F2      INPVEC  =$DCC9      INSTR2  =$1EF7      INS_TX0 =$4E83
   INS_TXT =$4E7F      INTBUF  =$B600      INTCHR  =$1819      INTOUT  =$34
   INVERT  =$23B3      INVFLG  =$32        IRQVECT =$FFFE      IRQ_A   =$13BE
   JGET2   =$15B3      JSTRCP  =$DCF5      KBDSTRB =$C010      KEYIN   =$14C3
   KEYIN2  =$14C8      KEYIN5  =$1532      L1      =$0100      L2      =$0200
   L3      =$0300      L4      =$0400      L5      =$0500      L6      =$0600
   L7      =$0700      L8      =$0800      L9      =$0900      LABEL   =$00
   LASTCHR =$5C        LASTIN  =$1B        LBLNUM  =$DF37      LBLTAB  =$9E00
   LDCHCV  =$16AD      LD_MOD  =$3250      LD_MOD1 =$32B7      LD_MOD2 =$32BC
   LIST    =$1B5B      LNBUF   =$0200      LNCNT   =$DF38      LNCNT2  =$DF39
   LNKLBL  =$25CF      LOGOFF  =$61        LOGSPEC =$2FD6      LOMEM   =$69
   LORESMD =$C056      LSTLINE =$4BD0      LSTNUM  =$1BE6      LSTPTR  =$11
   LSTTOK  =$2F        LSTTXT  =$6C        LSTVAR  =$1BE7      MATCH   =$4C55
   MDM0    =$396A      MDM1    =$39D1      MDM1_2  =$39E7      MDM2    =$39EF
   MDMANS  =$0E0F      MDMDCD  =$0E1B      MDMDTR  =$0E24      MDMHANG =$0E12
   MDMIN   =$0E15      MDMINIT =$0E06      MDMJMP  =$3964      MDMOUT  =$0E18
   MDMRING =$0E0C      MDMRSET =$0E09      MDMSLOT =$0E00      MIDMEM  =$6D
   MISCMSGS=$D914      MLI     =$BF00      MLIDATE =$BF90      MLITIME =$BF92
   MODEBYT =$DCC4      MONRND  =$4E        MONTHS  =$DDE2      MOVECODE=$5112
   MOVNAME =$2F63      MOVNM0  =$2F66      MSG     =$2AD4      MSGBUF  =$BB00
   MSGINFO =$DF43      MSGINIT =$DF63      MSGNUM  =$DF5F      MSGPTR  =$DF4B
   MSGPTR2 =$DF51      MSGREF  =$DF42      MSG_X   =$58        MSG_Y   =$59
   MTHINDEX=$DDD6      MTH_CNST=$4387      NEGFLG  =$DF2A      NEGXA   =$22A5
   NIBPTR  =$65        NIL     =$3706      NOCDFLG =$DF2C      NOCDVEC =$DF2D
   NOLBLDEF=$12DB      NONBS   =$4C4C      NO_INP  =$3B25      NO_OUT  =$3B27
   NULLS   =$DF34      NUM     =$DF11      NUMB    =$DF28      NUMIN   =$1AC1
   NUMIN2  =$1AD9      NUMIN4  =$1AEC      NXTCHR  =$080F      OLDCH   =$5A
   OLDCV   =$5B        OLDEXEC =$1C9D      OLDRMT  =$1C9E      ONERRFLG=$DF2F
   ONERRVEC=$DF30      OPEN    =$30B6      OUTVEC  =$DCDF      PAUSE   =$1BE8
   PDLS    =$C064      PG3JMP  =$5A4D      POSBLK  =$DF61      POSMSG  =$3182
   PR      =$1928      PRBACK  =$14B4      PRBS    =$4ED6      PRCHR   =$1BFC
   PRCMPMSG=$19BF      PRCOUT  =$0C04      PRCRIF  =$4EEA      PRCRLF  =$4EEF
   PREDMSG =$19B4      PRGPTR  =$04        PRINIT  =$0C01      PRMSG   =$19CA
   PRMSG2  =$19D2      PRN     =$0A        PRNONBS =$4EE7      PROMPT  =$4C4E
   PRTOPL2 =$1890      PRTOPL3 =$1897      PRTOPL5 =$18B6      PRTOPLN =$1881
   PTRIG   =$C070      PUTA    =$436E      PUTAX   =$436A      PUTCHR  =$181A
   PWHIDE  =$33        P_BYTE  =$3227      P_CLOSE =$321D      P_CREAT =$3244
   P_DEL   =$3241      P_MARK  =$3228      P_NEW1  =$322D      P_OPEN  =$3217
   P_QUIT  =$13B6      P_RBYT  =$321F      P_RDBLK =$3239      P_RDLN  =$3231
   QTEXT   =$4C51      QUIT    =$7F        RAMCARD =$D500      RAMDRV  =$B680
   RAMIN   =$1CDC      RAMOUT  =$1CEC      RAMPTR  =$75        RDBIT   =$2DB5
   RDBLK   =$3142      RDBYTE  =$311F      RDEND   =$DF50      RDKEY   =$1537
   RDLINE  =$3102      RDLNSET =$30F2      RDMAIL  =$2B0F      RDMSG   =$2BA1
   RDMSG2  =$2BCE      RDMSG3  =$2BDC      RDMSG4  =$2BEB      REFNUM  =$03CD
   REFTAB  =$2483      REMAIN  =$DF3C      REMOTE  =$DF35      RESET   =$12C9
   RESETVEC=$03F2      REST3   =$1370      REST4   =$137B      RESTART1=$1307
   RESULT  =$DF3F      RMXBLK  =$DF4E      RND     =$C9        ROLTIME =$A8C0
   RSTLINE =$1C3D      RUNMOD1 =$128F      RUNMOD2 =$129A      RWBLK   =$3149
   RWDBLK  =$DF5A      RWDBYT8 =$DF58      RWDCHR8 =$DF59      RWDPTR  =$DF57
   RWTYPE  =$3166      SAVE_X  =$06        SAVE_Y  =$07        SAVNUMB =$1E06
   SCRATCH =$0300      SDUMP   =$156C      SECON   =$43E3      SEREND  =$4F79
   SERNUM  =$4F70      SETBLK  =$2DD7      SETDATE =$0D08      SETDRV  =$2FF4
   SETIVEC =$1CFA      SETMARK =$31D5      SETMSG  =$2B5C      SETMSG1 =$2B79
   SETMSG2 =$2BEE      SETMSG3 =$2BF0      SETMSGX =$2B77      SETOVEC =$1D08
   SETPFX  =$3085      SETPOS  =$31D7      SETPOS2 =$31E6      SETRAM  =$C083
   SETROM  =$C082      SHERR   =$1973      SHOWLINE=$1903      SHOWLN  =$4EF3
   SHOW_X  =$76        SHWIN   =$28E3      SHWLAST =$4E31      SHWLN   =$4C48
   SHWOUT  =$28E4      SHWREF  =$28E5      SHWRTS  =$27AD      SHWTRC  =$169B
   SHWTXT  =$169A      SHW_CNT =$77        SIGN    =$DF3E      SOFTEV  =$03F4
   SPCINIT =$0E02      SPKR    =$C030      START   =$0800      START1  =$5100
   START2  =$510C      STATE4  =$342A      STPCHR  =$080E      STRCMP  =$1FDC
   STRCMP9 =$201E      STRCOPY =$1FB9      STREQ   =$2054      STRGT   =$2094
   STRLEN  =$0F        STRLOC  =$0D        STRLT   =$206D      STRRTS  =$20BA
   ST_EQ   =$2027      ST_GT   =$203C      ST_GTEQ =$204B      ST_LT   =$2036
   ST_LTEQ =$2042      ST_NOT  =$202D      SVCHCV  =$169C      SVDATA  =$39FC
   SVLINE  =$1C23      SVSTR   =$429E      SWPBLK  =$2E16      SYMADR  =$D6A2
   SYMNUM  =$DF36      SYMTAB  =$A600      SYMTXT  =$D500      SYNTAX  =$12D7
   TEMP    =$00        TEMP2   =$02        TEMP3   =$13        TIMEON  =$71
   TIMEOUT =$1533      TOKEN   =$36B6      TOKTYP  =$DF3A      TOPBUF  =$DE06
   TOPMASK =$DD1A      TOPPRINT=$185C      TOPRIGHT=$0427      TOPSEG  =$1927
   TOPSEGNO=$18DB      TOPSEGS =$1923      TOPSHOW =$18DC      TOVAL   =$0801
   TST_ALF =$1751      TST_GSB =$37E2      TST_NUM =$1760      TTLLEN  =$10
   TXTNUM  =$DF18      TYPBUF  =$B700      TYPIN   =$63        TYPOUT  =$64
   UNCOMP  =$2727      USERVEC =$03F5      VARSET  =$1D25      VARSET3 =$1D47
   VARSTR  =$08        VECTOR  =$15        VECTOR2 =$56        VIDBAN  =$090C
   VIDCHAT =$0927      VIDCLS  =$0903      VIDCOUT =$0906      VIDECHO =$3B40
   VIDINIT =$0900      VIDKEY  =$0921      VIDLEN  =$4C4D      VIDLST  =$090F
   VIDPOS  =$0924      VIDRD   =$091E      VIDRDFN =$0918      VIDRDKY =$0915
   VIDRDST =$0912      VIDSCRL =$0909      VIDWND  =$091B      VNAME   =$81
   VPTR    =$83        WAIT    =$1C17      WEEK_MOD=$437F      WHNPTR  =$17
   WIDTH   =$0810      WIDTH2  =$45B4      WNDBTM  =$23        WNDTOP  =$22
   WNDWDTH =$21        WOK     =$3F65      WRBLK   =$3138      WRBYTE  =$316A
   WRKBLK  =$DF54      WRMSG   =$2C6F      WRMSG0  =$2C9A      WRMSG0A =$2C7C
   WRMSG1  =$2CA5      WRMSG1A =$2CAE      WRMSG1B =$2CE8      WRMSG2  =$2CEA
   WRMSG3  =$2CF0      WRMSG4  =$2D04      WRTBIT  =$2DC6      WRTDIR  =$2DF4
   WRTEND  =$DF56      WRTMSG  =$2BF5      WRTMSG0 =$2C04      WRTMSG1 =$2C0F
   WRTMSG2 =$2C40      WRTMSG2A=$2C52      WRTMSG3 =$2C59      WRTMSG4 =$2C63
   WRTMSG5 =$2C09      WRTMSG6 =$2C6A      WWEXTRA =$4C4B      WWFLAG  =$4C4A
   WWRAP   =$4C49      XARG    =$4D3E      XINT    =$3CAA      XNUMIN  =$1AFB
   XTERNAL =$28E6      XYARG   =$4D5B      XYCLR   =$4D59      X_ARG   =$50
   X_DATE  =$437E      Y_ARG   =$52        ZDATA   =$5146      ZMDMOUT =$1D16
   ZNUMIN  =$1B2A      ]LOOP   =$4466      a2data  =$2D        a2obj   =$2B
   abort?  =$04        aborted =$05        badcmd  =$03        baddev  =$0F
   baddrive=$16        badfn   =$10        badln   =$09        badtype =$09
   badwrite=$07        badxtrn =$17        bartog  =$0F        bel     =$07
   bol     =$02        bs      =$08        bytsused=$13        can     =$18
   chain   =$08        chain2  =$09        chat    =$01        clb     =$1E
   clear   =$0A        clrhi   =$7F        comfile =$8001      compare =$5A
   compile1=$01        compile2=$02        compwipe=$03        continue=$06
   cr      =$0D        ctr     =$03        ctrl    =$40        dc      =$04
   del     =$7F        delete? =$07        divby0  =$0B        edit?   =$08
   edithelp=$11        editing =$01        else    =$18        end     =$03
   endprog =$15        enter   =$0E        eol     =$05        eot     =$04
   equal   =$60        execon  =$16        exitexec=$05        ff      =$0C
   forfull =$11        fs      =$15        gosub   =$05        goto    =$04
   hak     =$14        hangon  =$04        hibit   =$80        ic      =$06
   insert  =$0C        insert? =$0A        key     =$2A        lblnf   =$03
   legaldot=$12        lf      =$0A        list?   =$0B        logic   =$63
   logout  =$0C        lwd     =$11        math    =$66        minus   =$67
   msg     =$2C        new?    =$0D        nodata  =$08        nofile  =$06
   nogosub =$0E        nolabel =$07        nolink  =$13        nomsg   =$14
   noquote =$18        nosymbol=$06        notype  =$00        num2big =$0A
   number  =$01        nwd     =$17        packfile=$8002      pass    =$1F
   prnscr  =$10        public  =$07        push    =$06        readfn? =$0F
   revtop  =$12        seg2big =$02        step    =$32        str2big =$0C
   string  =$02        strtyp  =$50        symfull =$04        syntax  =$05
   sysopoff=$02        sysopon =$01        tab     =$09        thats4k =$02
   timeup  =$03        to      =$31        toglpw  =$1D        txt     =$04
   writefn?=$10        xoff    =$13     

Symbol table, numerical order:

   LABEL   =$00        TEMP    =$00        notype  =$00        number  =$01
   compile1=$01        sysopon =$01        chat    =$01        editing =$01
   seg2big =$02        sysopoff=$02        compile2=$02        thats4k =$02
   string  =$02        TEMP2   =$02        bol     =$02        ctr     =$03
   lblnf   =$03        compwipe=$03        end     =$03        timeup  =$03
   badcmd  =$03        abort?  =$04        symfull =$04        eot     =$04
   goto    =$04        txt     =$04        dc      =$04        hangon  =$04
   PRGPTR  =$04        syntax  =$05        gosub   =$05        exitexec=$05
   aborted =$05        eol     =$05        push    =$06        nosymbol=$06
   nofile  =$06        ic      =$06        SAVE_X  =$06        continue=$06
   delete? =$07        public  =$07        badwrite=$07        SAVE_Y  =$07
   nolabel =$07        bel     =$07        chain   =$08        VARSTR  =$08
   bs      =$08        edit?   =$08        nodata  =$08        chain2  =$09
   badln   =$09        tab     =$09        badtype =$09        num2big =$0A
   insert? =$0A        ERVAL   =$0A        lf      =$0A        PRN     =$0A
   clear   =$0A        list?   =$0B        divby0  =$0B        insert  =$0C
   CMD     =$0C        str2big =$0C        logout  =$0C        ff      =$0C
   new?    =$0D        cr      =$0D        STRLOC  =$0D        enter   =$0E
   nogosub =$0E        baddev  =$0F        readfn? =$0F        STRLEN  =$0F
   bartog  =$0F        prnscr  =$10        badfn   =$10        TTLLEN  =$10
   writefn?=$10        forfull =$11        edithelp=$11        lwd     =$11
   LSTPTR  =$11        revtop  =$12        legaldot=$12        bytsused=$13
   nolink  =$13        TEMP3   =$13        xoff    =$13        nomsg   =$14
   hak     =$14        endprog =$15        fs      =$15        VECTOR  =$15
   execon  =$16        baddrive=$16        badxtrn =$17        WHNPTR  =$17
   nwd     =$17        else    =$18        noquote =$18        can     =$18
   EDPTR   =$19        LASTIN  =$1B        EXEC    =$1C        toglpw  =$1D
   ARGPTR  =$1D        clb     =$1E        pass    =$1F        DEVCLR  =$1F
   WNDWDTH =$21        WNDTOP  =$22        WNDBTM  =$23        CH      =$24
   CV      =$25        key     =$2A        a2obj   =$2B        msg     =$2C
   a2data  =$2D        LSTTOK  =$2F        to      =$31        step    =$32
   INVFLG  =$32        PWHIDE  =$33        INTOUT  =$34        ctrl    =$40
   MONRND  =$4E        strtyp  =$50        X_ARG   =$50        Y_ARG   =$52
   EDLINE  =$54        VECTOR2 =$56        MSG_X   =$58        MSG_Y   =$59
   compare =$5A        OLDCH   =$5A        OLDCV   =$5B        LASTCHR =$5C
   DOCHAT  =$5D        INCHAT  =$5E        equal   =$60        LOGOFF  =$61
   BUF_X   =$62        logic   =$63        TYPIN   =$63        TYPOUT  =$64
   NIBPTR  =$65        math    =$66        BYTPTR  =$67        minus   =$67
   LOMEM   =$69        IMMDEF  =$6B        LSTTXT  =$6C        MIDMEM  =$6D
   CLKBASE =$6F        TIMEON  =$71        HIMEM   =$73        RAMPTR  =$75
   SHOW_X  =$76        SHW_CNT =$77        GSBLVL  =$78        FORLVL  =$79
   clrhi   =$7F        del     =$7F        QUIT    =$7F        hibit   =$80
   VNAME   =$81        VPTR    =$83        RND     =$C9        ERRNO   =$DE
   L1      =$0100      LNBUF   =$0200      L2      =$0200      SCRATCH =$0300
   L3      =$0300      ENTPOINT=$0380      REFNUM  =$03CD      RESETVEC=$03F2
   SOFTEV  =$03F4      USERVEC =$03F5      L4      =$0400      TOPRIGHT=$0427
   L5      =$0500      L6      =$0600      L7      =$0700      START   =$0800
   L8      =$0800      TOVAL   =$0801      STPCHR  =$080E      NXTCHR  =$080F
   WIDTH   =$0810      DEVNAM  =$0815      L9      =$0900      VIDINIT =$0900
   VIDCLS  =$0903      VIDCOUT =$0906      END_MV  =$0907      VIDSCRL =$0909
   VIDBAN  =$090C      VIDLST  =$090F      VIDRDST =$0912      VIDRDKY =$0915
   VIDRDFN =$0918      VIDWND  =$091B      VIDRD   =$091E      VIDKEY  =$0921
   VIDPOS  =$0924      VIDCHAT =$0927      PRINIT  =$0C01      PRCOUT  =$0C04
   GETDATE =$0D02      GETTIME =$0D05      SETDATE =$0D08      MDMSLOT =$0E00
   SPCINIT =$0E02      MDMINIT =$0E06      MDMRSET =$0E09      MDMRING =$0E0C
   MDMANS  =$0E0F      MDMHANG =$0E12      MDMIN   =$0E15      MDMOUT  =$0E18
   MDMDCD  =$0E1B      MDMDTR  =$0E24      EDSIZE  =$1000      FATAL   =$1200
   FATAL1  =$1203      FATAL5  =$1274      FATAL6  =$1282      RUNMOD1 =$128F
   RUNMOD2 =$129A      RESET   =$12C9      SYNTAX  =$12D7      NOLBLDEF=$12DB
   DO_END  =$12DF      BADERR  =$12E1      RESTART1=$1307      REST3   =$1370
   REST4   =$137B      BBS_PRG =$13A6      P_QUIT  =$13B6      AUTORST =$13BD
   IRQ_A   =$13BE      INPLNA  =$13BF      INPLN   =$13C4      CROUT   =$14A9
   INPLN7  =$14AB      INPLN8  =$14AE      PRBACK  =$14B4      KEYIN   =$14C3
   KEYIN2  =$14C8      KEYIN5  =$1532      TIMEOUT =$1533      RDKEY   =$1537
   SDUMP   =$156C      GET5    =$1593      GET6    =$159C      GET6A   =$15AC
   JGET2   =$15B3      GET7    =$15B6      GET8    =$15BD      GET9    =$15C2
   GET4    =$15C9      GET     =$15CC      GET2    =$1632      GET3    =$1647
   GET3B   =$165E      GET8A   =$1661      GET8B   =$167E      INPMODE =$1699
   SHWTXT  =$169A      SHWTRC  =$169B      SVCHCV  =$169C      LDCHCV  =$16AD
   GETRAW  =$16BD      GETBYT  =$16CC      CHKBYT  =$16E4      GOBBLE2 =$16EE
   GOBEQU  =$16EF      GOBCOM  =$16F3      GOBBLE  =$16F5      GOBBYT  =$1705
   INCTMP  =$1706      CHKDCD  =$170D      CHKTIME =$1726      TST_ALF =$1751
   TST_NUM =$1760      CONV    =$176E      CONV2   =$177A      COUT    =$177B
   COUT0C  =$179A      COUT0   =$179D      COUT1   =$17AA      COUT1C  =$17BF
   COUT1A  =$17CA      COUT1B  =$17CD      COUT2   =$17CF      COUT3   =$1818
   INTCHR  =$1819      PUTCHR  =$181A      CLRBUF  =$183A      GETCHR  =$1843
   TOPPRINT=$185C      PRTOPLN =$1881      PRTOPL2 =$1890      PRTOPL3 =$1897
   PRTOPL5 =$18B6      CLRTOP  =$18BA      TOPSEGNO=$18DB      TOPSHOW =$18DC
   SHOWLINE=$1903      TOPSEGS =$1923      TOPSEG  =$1927      PR      =$1928
   EX_TOK  =$1958      SHERR   =$1973      ERROR   =$1991      ERROR2  =$19B3
   PREDMSG =$19B4      PRCMPMSG=$19BF      PRMSG   =$19CA      PRMSG2  =$19D2
   INPTYP  =$19F2      BINDEC8 =$1A23      DECOUT0 =$1A35      DECOUT  =$1A3E
   DECOUT1 =$1A50      NUMIN   =$1AC1      NUMIN2  =$1AD9      NUMIN4  =$1AEC
   XNUMIN  =$1AFB      ZNUMIN  =$1B2A      LIST    =$1B5B      LSTNUM  =$1BE6
   LSTVAR  =$1BE7      PAUSE   =$1BE8      PRCHR   =$1BFC      DO_BELL =$1C03
   WAIT    =$1C17      SVLINE  =$1C23      RSTLINE =$1C3D      DO_EXEC =$1C55
   EXEC2   =$1C7A      OLDEXEC =$1C9D      OLDRMT  =$1C9E      DO_CHAT =$1C9F
   CHAT2   =$1CAA      RAMIN   =$1CDC      RAMOUT  =$1CEC      SETIVEC =$1CFA
   SETOVEC =$1D08      ZMDMOUT =$1D16      VARSET  =$1D25      VARSET3 =$1D47
   INPNUM  =$1DAB      INPMATH =$1DD8      INPMTH1 =$1DDB      INPPAR  =$1DEA
   GETNUMB =$1DFF      INPPAR2 =$1E05      SAVNUMB =$1E06      INPNUM0 =$1E0D
   INPNUM2 =$1E6E      INPNM3  =$1E81      INPNM2  =$1E86      INPNARG =$1E8F
   INPSARG =$1E99      INPARG  =$1EA1      ARGTYP  =$1ED8      INSTR2  =$1EF7
   INPSTR  =$1F07      GTSTRINF=$1F59      INPSTR0 =$1F60      STRCOPY =$1FB9
   STRCMP  =$1FDC      STRCMP9 =$201E      ST_EQ   =$2027      ST_NOT  =$202D
   ST_LT   =$2036      ST_GT   =$203C      ST_LTEQ =$2042      ST_GTEQ =$204B
   STREQ   =$2054      STRLT   =$206D      STRGT   =$2094      STRRTS  =$20BA
   CHKFRE  =$20BB      DO_FRE  =$20C2      DO_PLUS =$216D      DO_SUB  =$2185
   DO_MATH =$219A      DO_MULT =$21A6      DO_MLD2 =$21AC      DO_MLDV =$21C4
   DO_MUL0 =$21E9      DO_DIVD =$222A      DO_MOD  =$2230      DO_DIV1 =$2242
   DO_ABS  =$2295      DO_ABS1 =$22A1      NEGXA   =$22A5      DO_ABS2 =$22B3
   CP_EQ   =$22B4      CP_NOT  =$22BD      CP_LT   =$22C9      CP_GT   =$22D5
   CP_LTEQ =$22E1      CP_GTEQ =$22F0      CP_AND  =$22FF      CP_OR   =$2312
   CP_EOR  =$2325      CP_ST   =$2338      CP_LTGT =$234C      CP_END  =$235D
   CMPEQ   =$2369      CMPLT   =$237F      CMPGT   =$2399      INVERT  =$23B3
   DO_OPEN =$23BA      IFOPEN  =$23F2      DO_APP  =$2407      DO_CLOS =$2416
   DO_CL3  =$2432      DO_CL6  =$245A      DISKIN1 =$245B      DISKIN2 =$2464
   DSKOUT1 =$246D      DSKOUT2 =$2478      REFTAB  =$2483      GETDEV  =$2485
   GETDEV2 =$24D8      CHKDSK  =$24DD      DO_SIZE =$24E3      DO_EOF  =$24F6
   DO_MARK =$250A      DO_LINK =$2554      LNKLBL  =$25CF      DO_STOR =$25D8
   DO_RCAL =$2624      COMPRES =$266A      COMP8   =$2726      UNCOMP  =$2727
   SHWRTS  =$27AD      DO_SHOW =$27AE      EXTERN  =$28CB      EXTERN2 =$28E2
   SHWIN   =$28E3      SHWOUT  =$28E4      SHWREF  =$28E5      XTERNAL =$28E6
   DO_POS  =$28E7      DO_READ =$2948      DO_WRIT =$296E      DO_KILL =$2994
   DO_RDY  =$29FD      FINISH  =$2A48      DO_MSG  =$2A62      MSG     =$2AD4
   RDMAIL  =$2B0F      DO_RWD  =$2B27      SETMSG  =$2B5C      SETMSGX =$2B77
   SETMSG1 =$2B79      RDMSG   =$2BA1      RDMSG2  =$2BCE      RDMSG3  =$2BDC
   RDMSG4  =$2BEB      SETMSG2 =$2BEE      SETMSG3 =$2BF0      WRTMSG  =$2BF5
   WRTMSG0 =$2C04      WRTMSG5 =$2C09      WRTMSG1 =$2C0F      WRTMSG2 =$2C40
   WRTMSG2A=$2C52      WRTMSG3 =$2C59      WRTMSG4 =$2C63      WRTMSG6 =$2C6A
   WRMSG   =$2C6F      WRMSG0A =$2C7C      WRMSG0  =$2C9A      WRMSG1  =$2CA5
   WRMSG1A =$2CAE      WRMSG1B =$2CE8      WRMSG2  =$2CEA      WRMSG3  =$2CF0
   WRMSG4  =$2D04      ALLOC   =$2D0A      DEALLOC =$2D65      GETBITS =$2D8B
   RDBIT   =$2DB5      WRTBIT  =$2DC6      SETBLK  =$2DD7      WRTDIR  =$2DF4
   SWPBLK  =$2E16      DO_MAKE =$2E3D      DO_CNCH =$2E49      DO_UP   =$2F26
   DO_USE  =$2F2F      MOVNAME =$2F63      MOVNM0  =$2F66      LOGSPEC =$2FD6
   SETDRV  =$2FF4      DRVCHD  =$306E      DRVNUM  =$306F      DRVOFF0 =$3070
   DRVOFF1 =$3071      FLNAME  =$3072      GETPFX  =$3082      SETPFX  =$3085
   CREATE  =$3088      OPEN    =$30B6      BFOPEN  =$30B8      BUFADR  =$30D5
   CLOSE   =$30D8      FLUSH   =$30E5      RDLNSET =$30F2      RDLINE  =$3102
   RDBYTE  =$311F      WRBLK   =$3138      RDBLK   =$3142      RWBLK   =$3149
   RWTYPE  =$3166      WRBYTE  =$316A      POSMSG  =$3182      GETEOF  =$3195
   CHKEOF  =$31AB      GETSIZ  =$31C5      APPEND  =$31CF      SETMARK =$31D5
   SETPOS  =$31D7      SETPOS2 =$31E6      GETMARK =$31F9      DELFILE =$3210
   P_OPEN  =$3217      P_CLOSE =$321D      P_RBYT  =$321F      P_BYTE  =$3227
   P_MARK  =$3228      P_NEW1  =$322D      P_RDLN  =$3231      P_RDBLK =$3239
   P_DEL   =$3241      P_CREAT =$3244      LD_MOD  =$3250      LD_MOD1 =$32B7
   LD_MOD2 =$32BC      STATE4  =$342A      ADD_SYM =$35C5      ADD_L12 =$361B
   ADD_LBL =$3622      ADD_L11 =$36AF      TOKEN   =$36B6      ERR     =$3701
   NIL     =$3706      DO_PRNT =$3707      DO_OUT  =$37B5      DO_GOTO =$37B8
   DO_GT2  =$37BF      DO_GSB  =$37C5      TST_GSB =$37E2      DO_PUSH =$37FD
   DO_POP  =$3811      DO_RET  =$381A      DO_RET2 =$382E      DO_RET3 =$382F
   CLRDEV  =$3832      CLRSTK  =$3852      CLRKEY  =$3859      DO_CLR  =$3862
   CLEAR   =$3871      DO_LET  =$38A8      DO_IF4  =$3911      DO_IF   =$3912
   DO_IF3  =$3926      DO_ELSE =$392E      IFGOB   =$3937      DO_MDM  =$394C
   MDMJMP  =$3964      MDM0    =$396A      MDM1    =$39D1      MDM1_2  =$39E7
   MDM2    =$39EF      DO_LEN  =$39F7      SVDATA  =$39FC      DO_IN   =$3A09
   DO_INP  =$3B22      NO_INP  =$3B25      NO_OUT  =$3B27      DO_ECHO =$3B28
   VIDECHO =$3B40      DO_INST =$3B41      DO_LFT  =$3BCC      DO_RGT  =$3BD2
   DO_MID  =$3BEA      DO_XSTR =$3C1C      DO_ISTR =$3C25      DO_CHR  =$3C42
   DO_VAL  =$3C74      DO_SED  =$3CA6      DO_SINT =$3CA9      XINT    =$3CAA
   DO_AINT =$3CBA      AINT0   =$3CD3      AINT1   =$3CE7      AINT2   =$3CFE
   AINT3   =$3D01      DO_GET  =$3D06      DO_SET  =$3D47      DO_STR  =$3D94
   DO_NOT  =$3DDC      DO_FLAG =$3DEC      BITVAL  =$3E6F      FLGPTR  =$3E77
   DO_NIB  =$3E79      DO_BYT  =$3EDF      DO_KEY  =$3F21      DO_WID  =$3F58
   WOK     =$3F65      GO_ERR  =$3F67      DO_FOR  =$3F6A      DO_NXT  =$3FCF
   DO_MOVE =$4063      DO_RAM  =$408B      DO_RAM2 =$4092      DO_RNDS =$4099
   DO_RND  =$40C4      DO_FILL =$40EC      DO_NOCD =$410C      DO_ERRNO=$4128
   DO_ONERR=$412D      DO_RESUM=$4149      DO_INFO =$4188      INFOJMP =$41A6
   INF0    =$41B4      INF1    =$41BA      INF2    =$41D6      INF3    =$41DC
   INF4    =$41EE      INF5    =$41F8      INF6    =$4210      DO_WHEN =$4228
   DO_DATE =$4256      DO_DT2  =$426A      SVSTR   =$429E      DATESTR =$42AD
   DO_TIME =$42B5      DO_FDATE=$42BC      PUTAX   =$436A      PUTA    =$436E
   X_DATE  =$437E      WEEK_MOD=$437F      MTH_CNST=$4387      DATEPTR =$4393
   FMTDATE =$4394      DO_CLOK =$43A5      CLKJMP  =$43BC      CLK0    =$43C2
   CLKRTN  =$43C9      CLK1    =$43CA      CLK1A   =$43CD      CLK2    =$43D0
   SECON   =$43E3      CONVSEC =$43FA      CHK4SN  =$4451      ]LOOP   =$4466
   DO_POKE =$4472      DO_PEEK =$4485      DO_TONE =$4493      DO_TEXT =$44EB
   DO_HOME =$44EF      DO_PDL  =$44F2      DO_ASC  =$4509      DO_CALL =$4519
   DO_EDIT =$4523      EDJMP   =$453D      ED_STX  =$4549      ED_CLR  =$4577
   ED_SPC  =$4587      ED_LOC  =$4597      ED_WIDTH=$459E      WIDTH2  =$45B4
   ED_MODE =$45B5      ED_LNCR =$45D9      ED_LN   =$45DC      ED_CMD  =$461D
   ED_CMD2 =$4630      ED_HLP  =$4671      ED_HLP2 =$4676      HLPFILE =$46A6
   ED_ABT  =$46B0      ED_CON1 =$46C1      ED_CONT =$46C7      ED_RTS  =$46D8
   ED_DEL  =$46D9      DOT_DEL =$46E6      CR_RET2 =$470D      ED_ERR  =$470E
   DOT_E1  =$4711      ED_ED   =$4723      DOT_ED  =$4730      CR_RET  =$47B6
   CR_ERR  =$47B7      ED_INS  =$47BF      DOT_INS =$47CC      CR_ERR0 =$4828
   ED_LST  =$482B      DOT_LST =$4833      ED_LST1 =$484C      ED_SHLN =$4854
   ED_NEW  =$4881      ED_USED =$489E      DOT_PMT =$48B4      ED_NEW2 =$48C3
   ED_RW   =$48C4      ED_RD   =$48D6      ED_RD3  =$48F5      ED_RD4  =$48FB
   ED_WRT  =$4900      DOT_OK  =$4931      ED_OK   =$4936      ED_EX   =$49C4
   GETEDLN =$49C9      GETEDL2 =$49EB      GETED1  =$49ED      GETED2  =$49F6
   EDLNCR  =$4A73      EDLNCR0 =$4A8B      EDLNCR1 =$4AC7      EDLNCR2 =$4AFB
   EDLN0   =$4B20      EDLN2   =$4B30      EDLN3   =$4B3D      EDLN4   =$4B5A
   EDLN5   =$4B6A      EDLN6   =$4B94      EDLN7   =$4BC5      EDLN7B  =$4BCF
   LSTLINE =$4BD0      EDLN8   =$4BD2      EDLN9   =$4BDF      EDLN10  =$4BEE
   EDLN11  =$4BFF      EDLN11A =$4C21      EDLN11B =$4C25      EDLN1   =$4C26
   EDLN12  =$4C35      EDLN13  =$4C40      EDSTACK =$4C46      EXE_DOT =$4C47
   SHWLN   =$4C48      WWRAP   =$4C49      WWFLAG  =$4C4A      WWEXTRA =$4C4B
   NONBS   =$4C4C      VIDLEN  =$4C4D      PROMPT  =$4C4E      DOT_SAVE=$4C4F
   DOT_E   =$4C50      QTEXT   =$4C51      MATCH   =$4C55      CENTER  =$4C8D
   CENTER7 =$4CD5      DOT_HLP =$4CD6      GETCMD  =$4CDB      FINDLN  =$4CF2
   FNDLEN  =$4D20      CMPSTR3 =$4D2A      CMPSTR  =$4D2C      CMPSTR2 =$4D2E
   XARG    =$4D3E      XYCLR   =$4D59      XYARG   =$4D5B      CHKRNG  =$4DDF
   CHKRNG2 =$4DF7      CHKLAST =$4DF9      INCXARG =$4E1B      INCXA4  =$4E30
   SHWLAST =$4E31      DEL_TXT =$4E5A      DEL_TX0 =$4E5E      DEL_TX4 =$4E7E
   INS_TXT =$4E7F      INS_TX0 =$4E83      FINDEND =$4EB2      PRBS    =$4ED6
   BSOUT   =$4EE5      PRNONBS =$4EE7      PRCRIF  =$4EEA      PRCRLF  =$4EEF
   SHOWLN  =$4EF3      CHKLIST =$4F02      CHKLST2 =$4F1E      CONT    =$4F1F
   EDIN3   =$4F2F      EDINP   =$4F39      EDOUT   =$4F4E      SERNUM  =$4F70
   SEREND  =$4F79      COPNOT  =$4F79      COPEND  =$4FA5      FILTER  =$5000
   CODEND  =$5100      START1  =$5100      START2  =$510C      MOVECODE=$5112
   ZDATA   =$5146      PG3JMP  =$5A4D      comfile =$8001      packfile=$8002
   EDBUF   =$9E00      LBLTAB  =$9E00      ENDMOD  =$9E00      SYMTAB  =$A600
   ROLTIME =$A8C0      EBUFEND =$ADFF      FBUF2   =$AE00      FBUF1   =$B200
   INTBUF  =$B600      RAMDRV  =$B680      TYPBUF  =$B700      BITBUF  =$B780
   BLKBUF  =$B800      BLKBUF2 =$B880      DIRBUF  =$B900      MSGBUF  =$BB00
   MLI     =$BF00      BITMAP  =$BF58      MLIDATE =$BF90      MLITIME =$BF92
   KBDSTRB =$C010      SPKR    =$C030      LORESMD =$C056      ANU_ON  =$C05B
   PDLS    =$C064      PTRIG   =$C070      SETROM  =$C082      SETRAM  =$C083
   SYMTXT  =$D500      RAMCARD =$D500      SYMADR  =$D6A2      ERRMSGS =$D77C
   MISCMSGS=$D914      EDMSGS  =$D9DA      COMPMSGS=$DC43      MODEBYT =$DCC4
   INPVEC  =$DCC9      OUTVEC  =$DCDF      JSTRCP  =$DCF5      DEVTBL  =$DD07
   TOPMASK =$DD1A      DAYINDEX=$DDBA      DAYS    =$DDC1      MTHINDEX=$DDD6
   MONTHS  =$DDE2      TOPBUF  =$DE06      DUMMY   =$DE07      GSBSTK  =$DEA6
   FORVAR  =$DEC6      FOREND  =$DED6      FORSTP  =$DEE6      FORLOC  =$DEF6
   DEVUSE  =$DF06      NUM     =$DF11      TXTNUM  =$DF18      FLPOS   =$DF1E
   DATA    =$DF24      NUMB    =$DF28      NEGFLG  =$DF2A      FREMEM  =$DF2B
   NOCDFLG =$DF2C      NOCDVEC =$DF2D      ONERRFLG=$DF2F      ONERRVEC=$DF30
   FROMERR =$DF32      NULLS   =$DF34      REMOTE  =$DF35      SYMNUM  =$DF36
   LBLNUM  =$DF37      LNCNT   =$DF38      LNCNT2  =$DF39      TOKTYP  =$DF3A
   CPASS   =$DF3B      REMAIN  =$DF3C      SIGN    =$DF3E      RESULT  =$DF3F
   MSGREF  =$DF42      MSGINFO =$DF43      MSGPTR  =$DF4B      BYTE8   =$DF4C
   CHAR8   =$DF4D      RMXBLK  =$DF4E      RDEND   =$DF50      MSGPTR2 =$DF51
   BYTE82  =$DF52      WRKBLK  =$DF54      WRTEND  =$DF56      RWDPTR  =$DF57
   RWDBYT8 =$DF58      RWDCHR8 =$DF59      RWDBLK  =$DF5A      DIRSEG  =$DF5C
   BITSEG  =$DF5E      MSGNUM  =$DF5F      POSBLK  =$DF61      MSGINIT =$DF63
   CHATBUF =$DF64      IRQVECT =$FFFE   

